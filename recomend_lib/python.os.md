# Библиотека os
`os` — это стандартная библиотека Python, предоставляющая **инструменты для работы с операционной системой**. Она позволяет выполнять **системные команды**, **управлять файлами и директориями**, а также **получать информацию об окружении**.

## Основные возможности библиотеки os:
1. Работа с путями и файлами:
   - Создание, удаление, перемещение файлов и директорий.
   - Проверка существования файлов и директорий.

2. Работа с системными переменными:
   - Получение переменных окружения.
   - Управление путями для выполнения скриптов.

3. Информация о системе:
   - Узнать текущую рабочую директорию.
   - Получить информацию об операционной системе.

4. Выполнение системных команд:
   - Запуск внешних программ и системных процессов.
   - Основные функции и переменные:

## Методы библиотеки os

- `os.getcwd()`          Возвращает текущую рабочую директорию.
- `os.chdir(path)`       Меняет текущую рабочую директорию на указанную.
- `os.listdir(path)`	 Возвращает список файлов и папок в указанной директории.
- `os.mkdir(path)`	     Создает новую папку по указанному пути.
- `os.rmdir(path)`	     Удаляет пустую директорию.
- `os.remove(path)`	     Удаляет файл по указанному пути.
- `os.path.exists(path)` Проверяет, существует ли указанный путь.
- `os.path.join()`	     Соединяет несколько частей пути в один (кросс-платформенно).
- `os.getenv(key)`	     Получает значение переменной окружения.
- `os.environ`	         Словарь всех переменных окружения.
- `os.system(command)`	 Выполняет системную команду (например, запуск терминальных команд).

## Функции, которые используются чаще всего:
- `os.getcwd()` и `os.chdir(path)` — для работы с текущей директорией.
- `os.path.exists(path)` — проверка существования пути.
- `os.mkdir(path)` и `os.rmdir(path)` — для создания и удаления директорий.
- `os.path.join()` — построение путей (особенно при кроссплатформенной разработке).
- `os.listdir(path)` — список файлов и папок в директории.

## Пример использования #1
**Задача**:

Вы — разработчик, и вам нужно **написать программу, которая**:
- **Создает папку для хранения отчетов**.
- **Проверяет, существует ли файл с отчетом**.
- **Если файла нет, создает его и записывает базовые данные**.
```python
import os

# Имя директории для отчетов
reports_dir = "reports"

# Имя файла отчета
report_file = "report.txt"

# 1. Создаем папку для отчетов, если ее нет
if not os.path.exists(reports_dir):
    os.mkdir(reports_dir)
    print(f"Папка '{reports_dir}' создана.")

# Полный путь к файлу отчета
report_path = os.path.join(reports_dir, report_file)

# 2. Проверяем, существует ли файл отчета
if not os.path.exists(report_path):
    # Создаем файл и записываем данные
    with open(report_path, "w") as file:
        file.write("Отчет создан.\n")
        file.write("Дата: 2024-11-17\n")
    print(f"Файл '{report_file}' создан в папке '{reports_dir}'.")
else:
    print(f"Файл '{report_file}' уже существует.")

# 3. Вывод списка файлов в папке отчетов
print("Файлы в папке 'reports':", os.listdir(reports_dir))
```
### **Пример ввода и вывода**:

- Вывод программы, если папка и файл не существовали:

```arduino
Папка 'reports' создана.
Файл 'report.txt' создан в папке 'reports'.
Файлы в папке 'reports': ['report.txt']
```

- Вывод программы при повторном запуске:

```arduino
Файл 'report.txt' уже существует.
Файлы в папке 'reports': ['report.txt']
```

## Пример использования #2
### Использование `os` и `with` для работы с файлами
В этом примере добавим больше реализма: мы работаем с файлом настроек приложения. Скрипт:
  - Проверяет, существует ли файл `config.txt`.
  - Если файл **не существует**, **создаёт его и записывает базовые настройки**.
  - Если файл **существует**, **считывает настройки, изменяет одну из них и сохраняет изменения**.

```python
import os

# Имя файла настроек
config_file = "config.txt"

# 1. Проверяем, существует ли файл настроек
if not os.path.exists(config_file):
    # Если файл не существует, создаем его с базовыми настройками
    with open(config_file, "w") as file:
        file.write("theme=light\n")
        file.write("font_size=14\n")
        file.write("show_tutorial=True\n")
    print(f"Файл '{config_file}' создан с базовыми настройками.")
else:
    print(f"Файл '{config_file}' найден. Чтение настроек...")

# 2. Чтение и изменение настроек
new_lines = []
with open(config_file, "r") as file:
    for line in file:
        # Разделяем строку на ключ и значение
        key, value = line.strip().split("=")
        # Меняем тему на темную
        if key == "theme":
            value = "dark"
        new_lines.append(f"{key}={value}")

# 3. Сохраняем изменения обратно в файл
with open(config_file, "w") as file:
    for line in new_lines:
        file.write(line + "\n")

print(f"Настройки обновлены в файле '{config_file}'.")
```

### Объяснение кода:
1. Создание файла:
    - Если файла нет, он создаётся с базовыми настройками.
2. Чтение файла:
    - Используем with open(..., "r") для безопасного чтения. Строки разбиваются на ключи и значения.
3. Изменение данных:
    - Мы меняем значение настройки theme.
4. Запись файла:
    - Используем with open(..., "w") для записи изменений. Это перезаписывает содержимое файла.

### Результат работы программы
**пример файла config.txt перед изменением**:
```makefile
theme=light
font_size=14
show_tutorial=True
```
**После выполнения программы**:
```makefile
theme=dark
font_size=14
show_tutorial=True
```

## Почему os полезна?
Библиотека позволяет **автоматизировать рутинные операции с файлами и папками**, что особенно важно для скриптов и приложений, работающих с большими объемами данных или файловыми системами.

## Преимущества использования with:
- **Безопасность**: Автоматически закрывает файл, даже если произойдет ошибка.
- **Читаемость**: Лаконичный и понятный код.
- **Эффективность**: Исключает риск утечек ресурсов.

**Этот подход часто используется в реальных проектах для работы с файлами настроек, логами или данными**.