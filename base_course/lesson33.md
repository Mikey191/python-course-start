## Урок 33: Глобальные и локальные переменные. Импорт и работа с модулями в Python

### 33.1 Пространство имен (Namespace)

**Пространство имен (`namespace`)** — это **механизм, который связывает имена** (переменные, функции, классы) **с их значениями**. В Python **каждое имя существует в определенном пространстве имен**, чтобы избежать конфликтов между именами.

#### **Типы пространств имен**:

- **Локальное** (`Local`) — **существует внутри функции**. Переменные, объявленные внутри функции, принадлежат локальному пространству имен.
- **Глобальное** (`Global`) — **существует на уровне модуля**. Переменные, объявленные **вне всех функций, принадлежат глобальному пространству имен**.

**Пример**:

```python
x = 10  # Глобальное пространство имен

def my_function():
    x = 5  # Локальное пространство имен
    print(f"Локальная переменная x: {x}")

my_function()
print(f"Глобальная переменная x: {x}")
```

#### **Поиск имени выполняется в следующем порядке**:

1. **Локальное** пространство имен функции.
2. **Глобальное** пространство имен модуля.
3. **Встроенное** пространство имен Python (содержит встроенные функции Python, такие как `print()`, `len()`).

### 33.2 Глобальные переменные и оператор `global`

#### **Оператор `global`** позволяет изменять значение глобальной переменной внутри функции.

```python
counter = 0  # Глобальная переменная

def increment():
    global counter  # Даем доступ к глобальной переменной
    counter += 1

increment()
print(counter)  # Вывод: 1
```

#### **Оператор `global`** позволяет **создать глобальную переменную внутри функции**

```python
def create_global():
    global new_var
    new_var = "I am global now!"

create_global() # Создаем глобальную переменную
print(new_var)  # Вывод: I am global now!
```

### 33.3 Конфликт имен в Python: локальная и глобальная область видимости

**Если переменная с одинаковым именем объявлена и в `глобальной`, и в `локальной` области видимости, то Python будет использовать `локальную` переменную внутри функции, а глобальная переменная останется неизменной**.

**Пример конфликта имен**:

```python
my_str = "Global" # Глобальная переменная

def my_function():
    my_str = "Local" # Локальная переменная с таким же именем
    print(f"Локальная переменная my_str внутри функции: {my_str}")

# Вызов функции
my_function()

# Глобальная переменная остается неизменной
print(f"Глобальная переменная my_str вне функции: {my_str}")
```

#### **Ошибки при конфликте имен**

**Если попытаться изменить глобальную переменную внутри функции без использования `global`**, Python выдаст **ошибку** `UnboundLocalError`. Это происходит потому, что Python считает, что **вы пытаетесь использовать локальную переменную до ее объявления**.

```python
x = 10

def my_function():
    x += 5  # Ошибка: попытка изменить глобальную переменную без global
    print(x)

my_function()
```

**В случае конфликта имен между локальной и глобальной областью видимости Python всегда отдает приоритет локальной переменной**. Чтобы изменить глобальную переменную внутри функции, необходимо **использовать оператор `global`**.

### 33.4 Оператор `nonlocal`. Внешняя область видимости.

**Оператор `nonlocal` в Python используется для работы с переменными, которые находятся во `внешней области видимости`, но `не являются глобальными`**. Это позволяет изменять переменные, объявленные во внешней функции, из вложенной функции.

#### **Оператор nonlocal применяется в следующих случаях**:

- Когда у вас **есть вложенные функции** (функции внутри функций).
- Когда **нужно изменить значение переменной, объявленной во внешней функции, из внутренней функции**.
- Когда **переменная не является глобальной, но находится в области видимости внешней функции**.

#### **Как работает nonlocal?**

- Если вы **объявляете переменную с помощью `nonlocal`, Python ищет эту переменную во внешней области видимости** (но не в глобальной).
- Если **переменная найдена, она становится доступной для изменения внутри вложенной функции**.
- Если **переменная не найдена, Python выдаст ошибку `SyntaxError`**.

#### **Изменение переменной внешней функции**:

```python
def outer_function():
    x = 10  # Переменная во внешней функции

    def inner_function():
        nonlocal x  # Указываем, что будем использовать переменную из внешней функции
        x += 5  # Изменяем значение переменной
        print(f"Внутри inner_function: x = {x}")

    inner_function()
    print(f"Внутри outer_function: x = {x}")

outer_function()
```

#### **Несколько вложенных функций**:

**Оператор `nonlocal`** позволяет работать с переменными **на любом уровне вложенности**.

```python
def outer_function():
    x = 10  # Переменная во внешней функции

    def middle_function():
        def inner_function():
            nonlocal x  # Используем переменную из outer_function
            x += 5
            print(f"Внутри inner_function: x = {x}")

        inner_function()
        print(f"Внутри middle_function: x = {x}")

    middle_function()
    print(f"Внутри outer_function: x = {x}")

outer_function()
```

#### **Использование nonlocal для замыканий**:

**Оператор `nonlocal`** используется в `замыканиях` для **сохранения состояния между вызовами функций**.

```python
def counter():
    count = 0  # Переменная для хранения состояния

    def increment():
        nonlocal count
        count += 1
        return count

    return increment

# Создаем замыкание
counter_function = counter()

print(counter_function())  # Вывод: 1
print(counter_function())  # Вывод: 2
print(counter_function())  # Вывод: 3
```

### 33.5 Стандартные модули Python.

**Python предоставляет множество стандартных модулей, которые позволяют разработчикам использовать готовые функции и классы для выполнения различных задач**. Эти модули **являются частью стандартной библиотеки Python** и могут быть легко **импортированы в ваши программы**.

#### **Модуль `random`**

**Модуль `random` предоставляет функции для генерации случайных чисел**. Он полезен в играх, симуляциях и других приложениях, где требуется случайность.

```python
import random

# Генерация случайного числа от 1 до 10
random_number = random.randint(1, 10) # генерирует случайное целое число в заданном диапазоне.
print(f"Случайное число: {random_number}")

# Генерация случайного числа с плавающей точкой от 0 до 1
random_float = random.random() # возвращает случайное число с плавающей точкой от 0 до 1
print(f"Случайное число с плавающей точкой: {random_float}")

# Перемешивание списка
my_list = [1, 2, 3, 4, 5]
random.shuffle(my_list) # перемешивает элементы списка на месте
print(f"Перемешанный список: {my_list}")
```

#### **Модуль `datetime`**

**Модуль `datetime` предоставляет классы для работы с датами и временем**. Он позволяет выполнять операции с датами, форматировать их и получать текущее время.

```python
from datetime import datetime, timedelta

# Получение текущей даты и времени
now = datetime.now() # возвращает текущую дату и время
print(f"Текущая дата и время: {now}")

# Форматирование даты
formatted_date = now.strftime("%Y-%m-%d %H:%M:%S") # используется для форматирования даты в строку
print(f"Отформатированная дата: {formatted_date}")

# Добавление 7 дней к текущей дате
future_date = now + timedelta(days=7) # позволяет выполнять арифметические операции с датами, например, добавлять или вычитать дни
print(f"Дата через 7 дней: {future_date}")
```

#### **Модуль `os`**

**Модуль `os` предоставляет функции для взаимодействия с операционной системой**. Он позволяет работать с файловой системой, управлять процессами и получать информацию о среде выполнения.

```python
import os

# Получение текущей рабочей директории
current_directory = os.getcwd() # возвращает путь к текущей рабочей директории
print(f"Текущая рабочая директория: {current_directory}")

# Список файлов в текущей директории
files = os.listdir(current_directory) # возвращает список файлов и папок в указанной директории
print(f"Файлы в текущей директории: {files}")

# Создание новой директории
new_directory = "new_folder"
os.makedirs(new_directory, exist_ok=True) # создает новую директорию, если она не существует
print(f"Создана директория: {new_directory}")
```

### 33.6 Операторы `import`, `from` и `as`

**В Python для работы с модулями и пакетами используются операторы `import`, `from` и `as`**. Эти операторы позволяют разработчикам **организовывать код, повторно использовать функции и классы, а также улучшать читаемость и структуру программ**.

#### **Оператор `import`**

**Оператор `import` используется для импорта целого модуля**. После импорта модуля, все его **функции и классы доступны через его имя**.

```python
import math

# Используем функцию sqrt из модуля math
result = math.sqrt(16)
print(f"Квадратный корень из 16: {result}")
```

#### **Оператор `from`**

**Оператор `from` позволяет импортировать конкретные функции или классы из модуля**. Это удобно, когда вам нужны только определенные элементы из модуля, и вы хотите избежать необходимости указывать имя модуля каждый раз.

```python
from math import pi, sin

# Используем импортированные функции и константы напрямую
print(f"Число π: {pi}")
print(f"Синус 90 градусов: {sin(90)}")
```

#### **Оператор `as`**

**Оператор `as` позволяет задать псевдоним для модуля или функции**. Это может быть полезно для **сокращения длинных имен или для избежания конфликтов имен**, особенно если вы импортируете несколько модулей с одинаковыми именами.

```python
import numpy as np

# Используем псевдоним np для доступа к функциям модуля numpy
array = np.array([1, 2, 3, 4])
print(f"Созданный массив: {array}")
```

#### Сравнение методов импорта

- `import module_name`: **Импортирует весь модуль**. Используется, когда нужно много функций из модуля, и вы хотите сохранить ясность кода.
- `from module_name import function_name`: **Импортирует конкретные функции или классы**. Удобно, когда нужны только определенные элементы.
- `import module_name as alias`: **Импортирует модуль с псевдонимом**. Полезно для сокращения длинных имен или избежания конфликтов.

### 33.7 Создание собственных модулей.

`Модуль в Python` — **это файл с расширением `.py`, который содержит код на языке Python**. Он может **включать функции, классы и переменные, которые могут быть использованы в других файлах**. **Создание модулей** позволяет **структурировать код и разделять его на более мелкие, управляемые части**.

#### **Создание собственного модуля**

- **Создание файла модуля**: `my_module.py`
- **Определение функций в модуле**:
  - `greet(name)`: принимает имя и возвращает приветствие.
  - `add(a, b)`: принимает два числа и возвращает их сумму.
  - `multiply(a, b)`: принимает два числа и возвращает их произведение.

```python
# my_module.py

def greet(name):
    """Функция для приветствия пользователя."""
    return f"Привет, {name}!"

def add(a, b):
    """Функция для сложения двух чисел."""
    return a + b

def multiply(a, b):
    """Функция для умножения двух чисел."""
    return a * b
```

#### **Использование функций из собственного модуля**.

**Пример содержимого `main.py`**:

```python
# main.py

# Импортируем весь модуль
import my_module

# Используем функции из модуля
name = "Алиса"
greeting = my_module.greet(name)
print(greeting)  # Вывод: Привет, Алиса!

# Используем функции для математических операций
sum_result = my_module.add(5, 3)
print(f"Сумма: {sum_result}")  # Вывод: Сумма: 8

product_result = my_module.multiply(4, 7)
print(f"Произведение: {product_result}")  # Вывод: Произведение: 28
```

**Пример использования `from`**:

```python
# main.py

# Импортируем конкретные функции из модуля
from my_module import greet, add

# Используем импортированные функции
name = "Боб"
greeting = greet(name)
print(greeting)  # Вывод: Привет, Боб!

# Используем функцию для сложения
sum_result = add(10, 5)
print(f"Сумма: {sum_result}")  # Вывод: Сумма: 15
```

### 33.8 Константы в Python

**В Python `константы` представляют собой значения, которые не должны изменяться в течение выполнения программы**. Хотя в Python `нет встроенного механизма для объявления констант`, **существует общепринятая практика: константы обычно именуются с использованием заглавных букв и подчеркиваний для разделения слов**. Это позволяет разработчикам легко **отличать константы от обычных переменных**.

#### **Создание модуля с константами**

Создадим файл `constants.py`, в котором определим несколько констант:

```python
# constants.py

PI = 3.14159
E = 2.71828
GRAVITY = 9.81  # Ускорение свободного падения, м/с²
```

#### **Создание модуля с функциями**

Теперь создадим другой **модуль, который будет содержать функции, использующие эти константы**. Назовем его `math_functions.py`.

```python
# math_functions.py

from constants import PI, GRAVITY

def circle_area(radius):
    """Вычисляет площадь круга по заданному радиусу."""
    return PI * (radius ** 2)

def free_fall_time(height):
    """Вычисляет время падения с заданной высоты."""
    return (2 * height / GRAVITY) ** 0.5
```

#### **Использование модулей в основном файле**

Теперь **создадим основной файл `main.py`**.

```python
# main.py

from math_functions import circle_area, free_fall_time

# Пример использования функции для вычисления площади круга
radius = 5
area = circle_area(radius)
print(f"Площадь круга с радиусом {radius}: {area}")

# Пример использования функции для вычисления времени падения
height = 20
time = free_fall_time(height)
print(f"Время падения с высоты {height} м: {time:.2f} секунд")
```

### 33.9 Конструкция `if __name__ == "__main__"`

`Конструкция if __name__ == "__main__"` является важным элементом в Python, который **позволяет определить, выполняется ли файл как основная программа или импортируется как модуль в другой файл**. Это помогает **избежать выполнения определенного кода при импорте модуля**, что делает код более гибким и управляемым.

#### **Зачем нужна эта конструкция?**

1. **Разделение логики**: Конструкция позволяет **разделить код, который должен выполняться при запуске файла**, и **код, который должен выполняться только при импорте**. Это **особенно полезно для тестирования и отладки**.

2. **Управление импортом**: **Когда файл импортируется как модуль, код внутри блока `if __name__ == "__main__"` не будет выполнен**. Это п**редотвращает нежелательные побочные эффекты**, которые могут возникнуть при выполнении кода, предназначенного только для запуска.

3. **Удобство тестирования**: Вы можете **включать тесты или демонстрационные функции в файл**, который также может быть использован как модуль, не беспокоясь о том, что они будут выполнены при каждом импорте.

#### **Пример 1: Основная программа и модуль**

**Создадим два файла: `module.py` и `main.py`**.

```python
# module.py

def greet(name):
    return f"Привет, {name}!"

if __name__ == "__main__":
    # Этот код выполнится только при запуске module.py
    print(greet("Мир"))
```

```python
# main.py

from module import greet

# Используем функцию greet из модуля
print(greet("Алиса"))
```

**Объяснение**:

- Если вы запустите `module.py`, выведется `"Привет, Мир!"`.
- Если вы запустите `main.py`, выведется `"Привет, Алиса!"`, и код внутри `if __name__ == "__main__"` в `module.py` не выполнится.

#### Пример 2: Тестирование функций

**Вы можете использовать эту конструкцию для включения тестов в модуль**.

```python
# calculator.py

def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

if __name__ == "__main__":
    # Тестирование функций
    print("Тестирование функций:")
    print(f"2 + 3 = {add(2, 3)}")
    print(f"5 - 2 = {subtract(5, 2)}")
```

**Объяснение**:

- При запуске `calculator.py` будут выполнены тесты для функций `add` и `subtract`.
- Если вы импортируете `calculator` в другой файл, тесты не будут выполнены, и вы сможете использовать функции без лишнего вывода.

### 33.10 Примеры, приближенные к реальным проектам

#### **Пример 1: Создание 100 пользователей с рандомными именами**

- **Модуль `user_generator.py`**

  ```python
  import random
  import string

  # Генерирует случайное имя пользователя и пароль
  def generate_random_user():
      username = ''.join(random.choices(string.ascii_letters + string.digits, k=8))
      password = ''.join(random.choices(string.ascii_letters + string.digits, k=12))
      return username, password

  # Создает файл с заданным количеством пользователей
  def create_users_file(filename, count=100):
      with open(filename, 'w') as file:
          for _ in range(count):
              user = generate_random_user()
              file.write(f"{user[0]},{user[1]}\n")
  ```

- **Основной файл `main.py`**

  ```python
  from user_generator import create_users_file

  if __name__ == "__main__":
      create_users_file('users.txt', 100)
  ```

- **Объяснение кода**:

  - **Импортируем библиотеки**: `random` для генерации случайных данных и `string` для доступа к символам. Параметр `k` указывает на количество элементов, которые будут выбраны из заданного набора символов.
  - **Функция `generate_random_user`**: генерирует случайное имя пользователя и пароль, используя символы и цифры.
  - **Функция `create_users_file`**: создает файл и записывает в него 100 пользователей, вызывая `generate_random_user`.

- **Алгоритм работы модуля**:
  - Импортировать необходимые библиотеки.
  - Определить функцию для генерации случайных пользователей.
  - Определить функцию для создания файла и записи пользователей.
  - Запустить функцию создания файла.

#### **Пример 2: Создание уникального пользователя**

- **Модуль `unique_user_creator.py`**

  ```python
  # Проверяет, уникален ли логин в файле
  def is_unique(username, filename):
      with open(filename, 'r') as file:
          for line in file:
              if line.split(',')[0] == username:
                  return False
      return True

  # Создает нового пользователя с уникальным логином
  def create_user(filename):
      username = input("Введите логин: ")
      password = input("Введите пароль: ")

      if is_unique(username, filename):
          with open(filename, 'a') as file:
              file.write(f"{username},{password}\n")
          print("Пользователь успешно создан.")
      else:
          print("Логин уже существует. Попробуйте другой.")
  ```

- **Основной файл `main.py`**

  ```python
  from unique_user_creator import create_user

  if __name__ == "__main__":
      create_user('users.txt')
  ```

- **Объяснение кода**

  - **Функция `is_unique`**: проверяет, существует ли логин в файле.
  - **Функция `create_user`**: запрашивает у пользователя логин и пароль, проверяет уникальность и записывает в файл.

- **Алгоритм работы модуля**
  - Определить функцию для проверки уникальности логина.
  - Определить функцию для создания нового пользователя.
  - Запрашивать данные у пользователя и проверять их.
  - Записывать данные в файл, если логин уникален.

#### **Пример 3: Объединение двух предыдущих примеров**

- **Модуль `main.py`**

  ```python
  import sys
  from user_generator import create_users_file
  from unique_user_creator import create_user

  def main():
      if len(sys.argv) != 2:
          print("Использование: python main.py [rand|new]")
          return

      option = sys.argv[1]
      if option == 'rand':
          create_users_file('users.txt', 100)
          print("Создано 100 пользователей с рандомными данными.")
      elif option == 'new':
          create_user('users.txt')
      else:
          print("Неверный аргумент. Используйте 'rand' или 'new'.")

  if __name__ == "__main__":
      main()
  ```

- **Объяснение кода**

  - **Импортируем модули**: для генерации пользователей и создания уникальных пользователей.
  - **Функция `main`**: проверяет аргументы командной строки и вызывает соответствующие функции.

- **Алгоритм работы модуля**

  - Проверить количество аргументов командной строки.
  - В зависимости от аргумента (`rand` или `new`), вызвать соответствующую функцию.
  - Обработать неверные аргументы.
  - Запуск программы

- **Для создания 100 рандомных пользователей**:
  ```bash
  python main.py rand
  ```
- **Для создания нового уникального пользователя**:
  ```bash
  python main.py new
  ```

### Вопросы:

1. Что такое глобальная переменная в Python?
2. Что такое локальная переменная в Python?
3. Какое ключевое слово используется для изменения глобальной переменной внутри функции?
4. Что такое пространство имен (namespace) в Python?
5. Какая область видимости считается локальной?
6. Что произойдет, если в функции объявить переменную с тем же именем, что и глобальная переменная?
7. Каким образом можно импортировать функции из другого модуля? Приведите устно примеры синтаксиса.
8. Что делает конструкция `if __name__ == "__main__":`?
9. Что произойдет, если в функции использовать ключевое слово nonlocal?
10. Для чего используется оператор `from` ... `import` ... `as` ...?
11. Можно ли использовать глобальные и локальные переменные с одинаковыми именами в одной программе? Если да, то как Python решает, какую переменную использовать?
12. Какая разница между импортом `import module` и `from module import something`? Когда использовать каждый из них?

### Задачи:

1. Есть глобальная переменная `count`, равная `0`. Напишите функцию, которая увеличивает значение этой переменной на `1` при каждом вызове этой функции.

2. Создайте функцию, которая принимает строку, преобразует ее в список символов и возвращает количество уникальных символов. Используйте локальную переменную для хранения результата.

   - **Пример входных данных**:
     ```python
     "hello" # Уникальные символы: h, e, o
     ```

3. Создайте глобальный словарь `user_data`. Напишите функцию, которая добавляет в этот словарь новую пару ключ-значение, где ключ – имя пользователя, а значение – его возраст. Имя пользователя и возраст пользователь вводит через терминал. Вызовите функцию для проверки.

4. Напишите функцию `outer`, которая внутри себя содержит функцию `inner`. Внутри функции `outer` должна быть переменная-счетчик. Функция `inner` должна увеличивать переменную-счетчик. Вызовите функцию для проверки.

5. На вход программе подается строка. Создайте функцию, которая принимает строку и возвращает список случайно перемешанных символов из этой строки. Вызовите функцию для проверки.

6. На вход программе подаются слова, записанные в одну строчку через пробел. Создайте функцию, которая принимает список строк и создает файл `output.txt`. В этот файл записываются строки из списка, каждая с новой строки.

7. На вход программе подается строка - имя пользователя. Создайте модуль `user_utils.py`, содержащий функцию `validate_username`(username), которая проверяет, состоит ли имя пользователя только из букв и цифр. Импортируйте модуль и используйте его в основном файле.

8. Создайте модуль `calculator.py`, который выполняет операции сложения, вычитания, умножения и деления. Если модуль запускается напрямую, он должен принять два числа от пользователя и вывести результат их сложения. Если функции из модуля запускаются из файла `main.py` (основного файла) они должны исполнять свои действия.

9. Создайте функцию, которая принимает не ограниченное количество словарей, объединяет их в один и записывает результат в файл `merged.json`. Вызовите функцию для проверки.

10. \* Создайте модуль `user_generator.py`, который генерирует 100 пользователей с уникальными логинами и паролями и записывает их в файл `users.txt`.

11. \* Создайте модуль `user_creator.py`. В нем создайте функцию, которая принимает строку в формате `login:password` и добавляет пользователя в файл `users.txt`, если такого логина еще нет.

12. \* Создайте модуль `user_getter`. В нем создайте функцию, которая выводит всех пользователей из файла `users.txt`, в котором уже находятся минимум `100` пользователей.

13. \* Создайте модуль `user_manager.py` для управления пользователями. Модули из прошлых задач должны быть уже реализованны (`user_generator.py`, `user_creator.py`, `user_getter`). При запуске модуля `user_manager.py` с аргументами программа должна:
    - с аргументом `--generate` генерировать 100 случайных пользователей.
    - с вргументом `--add для` добавлять нового пользователя вручную.
    - с аргументом `--list` выводить всех пользователей.
