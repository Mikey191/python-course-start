## Урок 34: Обработка ошибок в Python. Исключения и конструкция `try/except`

### 1. **Что такое ошибка (исключение) в программировании?**

Когда мы пишем программы, мы ожидаем, что компьютер выполнит все инструкции в точной последовательности. Однако в реальности процесс выполнения может быть прерван из-за ошибок — ситуаций, когда интерпретатор Python сталкивается с чем-то неожиданным и не может продолжить работу.

**Ошибка — это событие, которое возникает во время выполнения программы и нарушает её нормальное выполнение**.

Когда ошибка возникает, Python автоматически создает объект исключения и, если этот объект не будет обработан, программа аварийно завершится. Такой сценарий называют "вызовом исключения" (throwing an exception).

#### Почему важно обрабатывать ошибки?

1. **Стабильность программы**

   - Программа, которая может перехватить и обработать ошибки, будет работать более стабильно и профессионально. Она не "падает" при первом сбое.

2. **Улучшение пользовательского опыта**

   - В продакшн-программах важно давать пользователю понятные сообщения об ошибках, а не показывать технические трассировки стека (tracebacks).

3. **Защита данных**

   - Неперехваченные ошибки могут повредить данные, прервать важные процессы или оставить незакрытыми файлы/соединения.

4. **Проектирование "живучих" систем**
   - Хорошие программы умеют "переживать" частичные ошибки и продолжают работать.

_Поэтому грамотная обработка ошибок — это не «дополнительная опция», а обязательная часть профессионального программирования_.

#### Ошибки `времени компиляции` и `времени выполнения`

В разных языках программирования различают два основных типа ошибок:

- **Ошибка времени компиляции (Compile-Time Error)**:

  - `Описание`: Ошибка, обнаруженная до запуска программы, обычно на этапе компиляции. Python — интерпретируемый язык, поэтому такие ошибки проявляются как синтаксические (SyntaxError).
  - `Пример`: Пропущенная скобка, неправильная структура кода

- **Ошибка времени выполнения (Runtime Error)**
  - `Описание`: Ошибка, которая возникает только при запуске программы, после начала её выполнения.
  - `Пример`: Деление на 0, обращение к несуществующему индексу

### 2. **Основные типы ошибок в Python**

1. **SyntaxError (Синтаксическая ошибка)**

   - **Что это**:

     - Ошибка в структуре кода. Python ожидает определенный синтаксис, а получает что-то некорректное.

   - **Когда возникает**:

     - Пропущена двоеточие в конструкции (if, for, def и т.д.).
     - Неправильное количество скобок.
     - Нарушение правил отступов.

   - **Пример**:

     ```python
     if 5 > 3
         print("Ошибка синтаксиса!")
     ```

   - **Ошибка**:
     - `SyntaxError: expected ':'`

2. **NameError (Ошибка имени)**

   - **Что это**:

     - Вы пытаетесь использовать переменную или функцию, которая не определена.

   - **Когда возникает**:

     - Ошибка в названии переменной.
     - Попытка использовать переменную до её создания.

   - **Пример**:

   ```python
   print(undeclared_variable)
   ```

   - **Ошибка**:
     - NameError: name 'undeclared_variable' is not defined

3. **TypeError (Ошибка типа)**

   - **Что это**:

     - Операция или функция применяется к объекту неподходящего типа.

   - **Когда возникает**:

     - Сложение строки и числа.
     - Вызов функции с аргументами неправильного типа.

   - **Пример**:

   ```python
   result = "строка" + 10
   ```

   - **Ошибка**:
     - `TypeError: can only concatenate str (not "int") to str`

4. **ValueError (Ошибка значения)**

   - **Что это**:

     - Функция получает аргумент правильного типа, но неподходящего значения.

   - **Когда возникает**:

     - Неверное преобразование строки в число.
     - Неправильное значение для функции.

   - **Пример**:

   ```python
   number = int("abc")
   ```

   - **Ошибка**:
     - `ValueError: invalid literal for int() with base 10: 'abc'`

5. **IndexError (Ошибка индекса)**

   - **Что это**:

     - Вы пытаетесь обратиться к элементу списка или строки по несуществующему индексу.

   - **Когда возникает**:

     - Индекс выходит за пределы диапазона элементов.

   - **Пример**:

   ```python
   lst = [1, 2, 3]
   print(lst[5])
   ```

   - **Ошибка**:
     - `IndexError: list index out of range`

6. **KeyError (Ошибка ключа)**

   - **Что это**:

     - Вы пытаетесь получить доступ к несуществующему ключу в словаре.

   - **Когда возникает**:

     - Ключ отсутствует в словаре.

   - **Пример**:

   ```python
   person = {"name": "Alice"}
   print(person["age"])
   ```

   - **Ошибка**:
     - `KeyError: 'age'`

7. **ZeroDivisionError (Ошибка деления на ноль)**

   - **Что это**:

     - Попытка разделить число на ноль.

   - **Когда возникает**:

     - Деление числа на 0.

   - **Пример**:

   ```python
   result = 5 / 0
   ```

   - **Ошибка**:
     - `ZeroDivisionError: division by zero`

### 3. **Конструкция `try/except`**

Конструкция `try/except` позволяет "поймать" ошибку, которая может возникнуть в блоке кода, и обработать её без аварийного завершения программы.

Это базовый способ перехвата и обработки исключений в Python.

Когда программа доходит до кода внутри try, она пытается его выполнить.
Если в процессе выполнения возникает ошибка, Python перемещается в соответствующий блок except, чтобы обработать её.

#### Общий синтаксис `try/except`

```python
try:
    # код, который может вызвать ошибку
except:
    # код, который выполняется при возникновении ошибки
```

#### Описание:

- `try`: Содержит код, который Python попытается выполнить. Ожидается, что здесь МОЖЕТ возникнуть ошибка.
- `except`: Содержит код, который выполнится только если в блоке try произошла ошибка. Здесь обычно предпринимаются действия по обработке ошибки: вывод сообщения, восстановление работы, игнорирование сбоя и т.д.

#### Пример: деление на ноль

Рассмотрим классическую ситуацию — деление на 0.

#### **Без обработки ошибок**:

```python
a = 10
b = 0
result = a / b
print("Результат:", result)
```

При запуске программа завершится аварийно с ошибкой:

```vbnet
ZeroDivisionError: division by zero
```

#### **С использованием конструкции `try/except`**:

```python
a = 10
b = 0

try:
    result = a / b
    print("Результат:", result)
except:
    print("Произошла ошибка при делении!")
```

- Что происходит в этом коде:

  - Python пытается выполнить `result = a / b` в блоке `try`.
  - При попытке деления на ноль возникает исключение `ZeroDivisionError`.
  - Поскольку ошибка произошла, Python **немедленно переходит к блоку `except`**.

- В блоке `except` выполняется код: **выводится сообщение "Произошла ошибка при делении!"**.

- Вывод программы:
  ```
  Произошла ошибка при делении!
  ```

> **И при этом программа не прерывается аварийно — она корректно завершает выполнение**.

#### Основные моменты, которые нужно запомнить:

- **Код в блоке `try` выполняется до первой ошибки**.
- **Если ошибка возникает — дальнейшие строки в `try` не выполняются, Python сразу переходит к блоку `except`**.
- **Если в блоке `try` ошибка не произошла, блок `except` пропускается**.

### 4. **Как обрабатывать разные типы ошибок**

Когда мы пишем код с обработкой ошибок, важно понимать, что не всегда все ошибки одинаковы.

Python может выдавать **десятки разных типов исключений**: деление на ноль, ошибка типов, ошибка индекса в списке, ошибка файла и многие другие.

- Поэтому мы можем:

  - **Ловить любую ошибку** (если нам неважно, какая именно возникла),
  - **Ловить конкретную ошибку** (если мы хотим обработать определённую ситуацию),
  - **Ловить разные типы ошибок отдельно**.

#### **Ловить любые ошибки (except без типа)**

Иногда в простых скриптах нужно просто "поймать" любую ошибку, чтобы программа не падала.

- **Пример**:

  ```python
  try:
      x = int(input("Введите число: "))
      y = 10 / x
      print("Результат:", y)
  except:
      print("Произошла ошибка!")
  ```

- **Как работает**:

  - Пользователь вводит значение.
  - Python пытается преобразовать его в целое число (int).
  - Потом делит 10 на это число.
  - Если в процессе возникнет ЛЮБАЯ ошибка (например, введена строка, или введён 0), выполнение сразу переходит в блок except.

- **Важно**: Ловить все ошибки — это удобно, но плохая практика для сложных программ, потому что:
  - Мы не знаем, какая именно ошибка произошла.
  - Сложнее отлаживать код.
  - Можно "поймать" и скрыть критические ошибки, которые должны быть замечены.

#### **Ловить конкретные ошибки (except с указанием типа)**

**Более правильный способ — перехватывать только те ошибки, которые мы ожидаем**.

- Пример:

  ```python
  try:
      x = int(input("Введите число: "))
      y = 10 / x
      print("Результат:", y)
  except ZeroDivisionError:
      print("Ошибка: Деление на ноль!")
  except ValueError:
      print("Ошибка: Нужно ввести именно число!")
  ```

- **Как работает**:

  - Если пользователь введет 0 — произойдет `ZeroDivisionError`.
  - Если пользователь введет буквы (например, "abc") — произойдет `ValueError`.

#### **Ловить несколько типов ошибок сразу**

Иногда бывает удобно обработать несколько типов ошибок одним except-блоком.

- Пример:

  ```python
  try:
      x = int(input("Введите число: "))
      y = 10 / x
      print("Результат:", y)
  except (ZeroDivisionError, ValueError):
      print("Ошибка: Неверный ввод или деление на ноль!")
  ```

- Объяснение:

  - В скобках указываются несколько типов ошибок.
  - Если возникнет любая из перечисленных ошибок (`ZeroDivisionError` или `ValueError`) — выполнится один и тот же код в except.

### 5. **Использование блока `else` в конструкции `try/except`**

> Когда `else` срабатывает и зачем он нужен?

#### 📌 Что такое `else` в конструкции `try/except`?

Многие начинающие разработчики не знают, что в конструкции `try/except` можно использовать ещё и блок `else`.
Этот блок выполняется только в том случае, если в блоке `try` **не возникло ни одной ошибки**.

```python
try:
    # Код, в котором может возникнуть ошибка
except SomeError:
    # Обработка ошибки
else:
    # Этот код выполнится, если ошибок в try не было!
```

#### ✅ Зачем нужен else?

- Использование блока else помогает разделить код, который:
- Может вызвать ошибку — помещается в try.
- Не вызывает ошибку, но должен выполняться, только если ошибок не было — помещается в else.
- Это делает код чище и логичнее.

#### 🔍 Простой пример: деление двух чисел

- Рассмотрим классический пример деления. В нём возможны две ошибки:

  - Пользователь ввёл не число — ValueError
  - Деление на ноль — ZeroDivisionError

- Мы хотим:

  - Поймать и обработать ошибки.
  - А если всё прошло хорошо — вывести результат деления.
  - Код без использования else:

```python
try:
    x = int(input("Введите делимое: "))
    y = int(input("Введите делитель: "))
    result = x / y
    print("Результат деления:", result)
except ZeroDivisionError:
    print("Ошибка: деление на ноль!")
except ValueError:
    print("Ошибка: нужно ввести числа!")
```

#### Что здесь не так?

- Всё отлично работает, но:

  - Весь "рабочий код" находится внутри блока try.

  - Трудно визуально отделить код, в котором может быть ошибка, от кода, который выполняется только при её отсутствии.

#### 💡 Теперь тот же пример, но с else:

```python
try:
    x = int(input("Введите делимое: "))
    y = int(input("Введите делитель: "))
    result = x / y
except ZeroDivisionError:
    print("Ошибка: деление на ноль!")
except ValueError:
    print("Ошибка: нужно ввести числа!")
else:
    print("Результат деления:", result)
```

#### Объяснение:

- Всё, что может вызвать ошибку (ввод чисел и деление), остаётся в `try`.
- Если всё прошло без исключений — управление передаётся в else, и только тогда результат выводится.
- Такой подход делает структуру кода ясной и логичной:

  - `try`: потенциально опасный код
  - `except`: обработка ошибок
  - `else`: "чистое" выполнение в случае успеха

#### 🚧 Важно: что НЕ стоит помещать в else?

Нельзя помещать в `else` код, который может вызвать новую ошибку — это сломает его смысл.

- Пример плохой практики:

```python
try:
    x = int(input("Введите число: "))
except ValueError:
    print("Ошибка ввода!")
else:
    # Ошибка может произойти тут!
    y = 10 / x
    print("Результат:", y)
```

> Здесь `y = 10 / x` может вызвать `ZeroDivisionError`, но мы его не обрабатываем, потому что он находится вне `try`.
> Лучше либо перенести деление в `try`, либо добавить дополнительную обработку ошибок.

#### 🧠 Итого:

| Блок     | Когда выполняется       | Назначение                 |
| -------- | ----------------------- | -------------------------- |
| `try`    | Всегда                  | Проверка "опасного" кода   |
| `except` | Если возникла ошибка    | Обработка исключений       |
| `else`   | Если **ошибок не было** | Выполнение кода при успехе |

#### ✅ Закрепим ещё одним примером:

```python
def divide_numbers():
    try:
        a = int(input("Введите первое число: "))
        b = int(input("Введите второе число: "))
        result = a / b
    except ValueError:
        print("Ошибка: ввод должен быть числом.")
    except ZeroDivisionError:
        print("Ошибка: деление на ноль.")
    else:
        print(f"Результат деления: {result}")

divide_numbers()
```

### 6. **Блок `finally`**

> Что это такое, зачем нужен, и когда применяется

#### 📌 Что такое finally?

Блок `finally` — это необязательная часть конструкции `try/except`, которая выполняется в любом случае:

- Произошла ошибка — выполнится.
- Ошибка не произошла — тоже выполнится.

#### Главная идея:

`finally` используется для завершающих действий, которые должны произойти вне зависимости от результата выполнения кода.

#### ✅ Синтаксис конструкции try/except/finally:

```python
try:
    # код, который может вызвать исключение
except SomeError:
    # обработка исключения
finally:
    # выполняется всегда — ошибка была или нет
```

#### 🔍 Где чаще всего используют finally?

- `finally` используется там, где нужно гарантированно освободить ресурсы:

  - Закрыть файл.
  - Закрыть соединение с базой данных.
  - Освободить сетевое подключение.
  - Очистить временные данные.
  - Завершить какой-то процесс.

#### 📎 Простейший пример: закрытие файла

Работа с файлами — один из самых типичных сценариев, где нужно использовать `finally`.

```python
try:
    file = open("example.txt", "r")
    data = file.read()
    print(data)
except FileNotFoundError:
    print("Файл не найден.")
finally:
    print("Закрытие файла...")
    file.close()
```

#### Что происходит:

- Открываем файл.
- Если файл не существует, возникает `FileNotFoundError`.
- Но вне зависимости от того, была ли ошибка или нет, файл всё равно закрывается.

#### 🧠 Почему нельзя просто писать file.close() после try?

Посмотри на пример без finally:

```python
file = open("example.txt", "r")
data = file.read()
file.close()
```

> Если в строке `file = open(...)` или `file.read()` произойдёт ошибка, выполнение кода прервётся, и `file.close()` никогда не будет вызван.
> Это приведёт к утечке ресурсов — файл останется открытым.

> Блок `finally` гарантирует выполнение `file.close()` — всегда, при любых обстоятельствах.

#### 🔁 Ещё пример: деление и закрытие соединения

Представим, что мы подключаемся к какому-то ресурсу (например, "виртуальное соединение") и хотим его закрыть даже при ошибке.

```python
def divide(a, b):
    print("Открываем соединение...")
    try:
        result = a / b
    except ZeroDivisionError:
        print("Ошибка: деление на ноль.")
    else:
        print("Результат:", result)
    finally:
        print("Закрываем соединение.")

divide(10, 2)
divide(10, 0)
```

#### Результат:

```plaintext
Открываем соединение...
Результат: 5.0
Закрываем соединение.

Открываем соединение...
Ошибка: деление на ноль.
Закрываем соединение.
```

#### 💡 Можно использовать try только с finally, без except

Иногда мы хотим выполнить "опасный" код и всегда выполнить финальные действия, но не хотим обрабатывать ошибку внутри текущей функции.

```python
def risky_action():
    try:
        print("Выполняем опасную операцию...")
        x = 1 / 0  # Ошибка!
    finally:
        print("Очищаем ресурсы...")

risky_action()
```

#### Результат:

```plaintext
Выполняем опасную операцию...
Очищаем ресурсы...
Traceback (most recent call last):
  ...
ZeroDivisionError: division by zero
```

> Ошибку никто не обработал, но finally всё равно выполнился. Это гарантия "завершения" действий.

#### 🧠 Итого:

| Блок      | Когда выполняется                     |
| --------- | ------------------------------------- |
| `try`     | Всегда, при запуске                   |
| `except`  | Если в `try` возникла ошибка          |
| `else`    | Если в `try` **не было ошибки**       |
| `finally` | **Всегда**, вне зависимости от ошибок |

#### 📎 Напоминание: когда не нужен `finally`?

Если ты работаешь с файлами или соединениями, чаще всего предпочтительнее использовать контекстный менеджер `with` (его мы уже обсуждали в теме про файлы).
Он автоматически закрывает файл, даже если возникла ошибка.

```python
with open("file.txt", "r") as file:
    data = file.read()
```

Но в ситуациях, когда ты не можешь использовать `with`, или работаешь с несколькими ресурсами, `finally` — твой инструмент!

#### Пример, где `finally` оказывается лучше, чем `with` — из-за сложной логики открытия ресурсов.

У нас есть два ресурса: файл и база данных. Но мы открываем их по условию, то есть они могут не использоваться одновременно.

- 🔧 Сценарий:
  - Если **включён лог-флаг** — мы открываем `лог-файл`.
  - Если **включён флаг работы с базой** — открываем `соединение с базой`.
  - В конце работы нужно **обязательно закрыть оба ресурса**, если они были открыты.

#### ❌ Попытка с with — неудобно и запутанно:

```python
if use_file and use_db:
    with open("log.txt", "w") as log, connect_to_db() as conn:
        ...
elif use_file:
    with open("log.txt", "w") as log:
        ...
elif use_db:
    with connect_to_db() as conn:
        ...
```

- Нужно дублировать код.
- 3 конструкции `with`.
- Трудно поддерживать и масштабировать.

#### ✅ Решение с `try/finally` — чисто и понятно:

```python
log = None
conn = None

try:
    if use_file:
        log = open("log.txt", "w")
        log.write("Логирование начато...\n")

    if use_db:
        conn = connect_to_db()
        # Предположим, у conn есть метод .execute()
        conn.execute("SELECT * FROM users")

    print("Работа завершена без ошибок.")

except Exception as e:
    print("Произошла ошибка:", e)

finally:
    if log:
        log.close()
        print("Файл закрыт.")

    if conn:
        conn.close()
        print("Соединение с базой закрыто.")
```

- 💡 Что даёт finally:
  - Он всегда выполнится, даже если произошла ошибка.
  - Удобно проверять: был ли ресурс открыт? — и закрывать его.
  - Не нужно дублировать with-блоки под разные случаи.

#### 📌 Вывод:

Если у тебя несколько объектов, открываемых по условию — finally становится единственным простым способом корректно управлять ресурсами.

В остальных (простых и однолинейных) случаях — конечно, with предпочтительнее.

### 7. Оператор raise: создание собственных исключений

Мы уже научились ловить ошибки, которые возникают в Python, но иногда бывает необходимо намеренно вызвать ошибку, чтобы сообщить о некорректной ситуации в логике программы.
Для этого в Python используется ключевое слово raise.

#### 🔹 Что делает `raise`?

- `raise` позволяет выбросить исключение вручную. Это может быть полезно:

  - для валидации входных данных (например, если данные не соответствуют ожиданиям);
  - для остановки выполнения функции, когда выполнение не имеет смысла;
  - для логического контроля над потоком программы.

#### 🔹 Синтаксис

```python
raise ТипИсключения("Сообщение об ошибке")
```

- Например:

```python
raise ValueError("Недопустимое значение")
```

> Этот код прерывает выполнение программы и выбрасывает исключение типа ValueError.

#### 🔸 Пример: проверка возраста пользователя

```python
def process_age(age):
    if age < 0:
        raise ValueError("Возраст не может быть отрицательным!")
    print(f"Возраст принят: {age}")

try:
    process_age(-5)
except ValueError as e:
    print("Ошибка:", e)
```

#### ✅ Вывод:

```makefile
Ошибка: Возраст не может быть отрицательным!
```

> Здесь мы вручную выбрасываем ошибку, если возраст меньше нуля.

#### 🔸 Пример: деление с защитой от нуля

```python
def divide(a, b):
    if b == 0:
        raise ZeroDivisionError("На ноль делить нельзя!")
    return a / b

try:
    result = divide(10, 0)
except ZeroDivisionError as e:
    print("Ошибка:", e)
```

#### ✅ Вывод:

```makefile
Ошибка: На ноль делить нельзя!
```

> Мы сами выбрасываем ту же ошибку, которую Python выбросил бы автоматически, но теперь мы можем это сделать в нужный момент, например — до выполнения самой операции.

#### 🔸 Повторный выброс ошибки: `raise` без аргументов

Иногда полезно обработать исключение, но затем передать его дальше. Это делается так:

```python
try:
    x = int("abc")
except ValueError as e:
    print("Ошибка преобразования:", e)
    raise  # повторно выбрасываем ту же ошибку
```

#### ✅ Вывод:

```sql
Ошибка преобразования: invalid literal for int() with base 10: 'abc'
Traceback (most recent call last):
...
ValueError: invalid literal for int() with base 10: 'abc'
```

> Такой подход применяется в случаях, когда вы хотите залогировать или обработать ошибку частично, а затем передать её выше по стеку.

#### 🔸 Кастомные сообщения об ошибках

Вы можете передавать любые строки в `raise`, чтобы точно объяснить пользователю или другому разработчику, что произошло:

```python
def set_temperature(temp):
    if temp > 100:
        raise Exception("Температура слишком высокая!")
    elif temp < -273.15:
        raise Exception("Температура ниже абсолютного нуля!")
    print(f"Температура установлена: {temp}°C")

try:
    set_temperature(-300)
except Exception as e:
    print("Ошибка:", e)
```

#### ✅ Вывод:

```makefile
Ошибка: Температура ниже абсолютного нуля!
```

#### 📌 Вывод

- raise — мощный инструмент для контроля логики.
- Он позволяет явно указать, что программа вошла в недопустимое состояние.
- Можно использовать как с встроенными исключениями (ValueError, TypeError, ZeroDivisionError и др.), так и с пользовательскими классами исключений (в ООП, но не рассматриваем сейчас).

### 8. **Примеры обработки ошибок в функциях**

#### 🔹 Зачем нужна обработка ошибок в функциях?

- Когда вы пишете функции, вы предполагаете, что:

  - аргументы передаются правильно,
  - действия проходят без сбоев,
  - всё работает, как задумано.

- Но в реальности:

  - пользователь может ввести текст вместо числа,
  - файл может не существовать,
  - деление может быть на 0,
  - данные могут отсутствовать вовсе.

- Обработка ошибок внутри функции или при её вызове позволяет:

  - предотвратить крах всей программы,
  - дать пользователю внятное сообщение об ошибке,
  - безопасно завершить выполнение,
  - сделать поведение функции предсказуемым.

#### 🔸 1. Обертывание вызова функции в `try/except`

Самый простой и распространённый подход — не трогать тело функции, а перехватывать исключения при её вызове.

- ✅ Пример:

```python
def divide(a, b):
    return a / b

try:
    result = divide(10, 0)
    print("Результат:", result)
except ZeroDivisionError:
    print("Ошибка: Деление на ноль недопустимо.")
```

> 💡 Такой подход хорош, когда вы не хотите изменять функцию, либо вы используете функцию из сторонней библиотеки.

#### 🔸 2. Обработка ошибок внутри функции

Если функция используется многократно и вы хотите, чтобы вся логика была внутри неё, разумно обрабатывать исключения прямо в теле функции.

- ✅ Пример:

```python
def safe_divide(a, b):
    try:
        return a / b
    except ZeroDivisionError:
        print("Ошибка внутри функции: деление на ноль.")
        return None

result = safe_divide(10, 0)
print("Результат:", result)
```

-📌 Здесь мы:

- избегаем сбоя программы,
- возвращаем None в случае ошибки,
- выводим информативное сообщение.

#### 🔸 3. Комбинирование обработки: внутри и снаружи

Иногда можно частично обработать ошибку внутри функции (например, залогировать), но сообщить об ошибке вызывающему коду — через raise.

- ✅ Пример:

```python
def parse_int(value):
    try:
        return int(value)
    except ValueError:
        print(f"Ошибка: '{value}' не может быть преобразовано в число.")
        raise  # пробрасываем ошибку дальше

try:
    number = parse_int("abc")
except ValueError:
    print("Преобразование не удалось.")
```

- 🧠 Здесь мы:

  - логируем ошибку внутри функции,
  - выбрасываем исключение дальше (raise) для внешней обработки.

#### 🔸 4. Пример: функция ввода с защитой от ошибок

Один из самых практичных вариантов — это функции, которые защищают от ошибок ввода пользователя:

```python
def get_int_input(prompt):
    while True:
        try:
            return int(input(prompt))
        except ValueError:
            print("Пожалуйста, введите целое число.")

age = get_int_input("Введите ваш возраст: ")
print("Ваш возраст:", age)

```

- 📌 Эта функция:

  - не завершается, пока пользователь не введёт корректное значение,
  - делает интерфейс "дружественным" и "устойчивым".

#### 🔸 5. Ошибка при работе с файлами — внутри функции

```python
def read_file(filename):
    try:
        with open(filename, "r", encoding="utf-8") as f:
            return f.read()
    except FileNotFoundError:
        print(f"Файл '{filename}' не найден.")
        return None

data = read_file("somefile.txt")
```

> ✅ Даже если файл не найден — программа продолжает работу, и можно обработать None.

#### 💬 Вывод:

- Используйте `try/except` при вызове, если не хотите менять тело функции.
- Обрабатывайте ошибки внутри функции, если хотите сделать её безопасной и предсказуемой.
- Комбинируйте — для более гибкой и масштабируемой архитектуры.
- Делайте функции «умными» — они должны предугадывать возможные ошибки и работать стабильно.

### 8. **Небольшой проект для консоли: Устойчивый калькулятор**

#### 🎯 Цель

Создать простое, но реалистичное консольное приложение, в котором:

- пользователь вводит команды и числа;
- возможны ошибки (ввод строки вместо числа, деление на 0, неправильная команда);
- все ошибки грамотно обрабатываются, программа не «падает» и даёт понятные подсказки;
- программа работает в цикле, пока пользователь не введёт команду выхода.

#### 🔹 Что будем реализовывать?

Простейший калькулятор, который:

- предлагает пользователю выбрать операцию `(+, -, *, /)`;
- запрашивает два числа;
- выводит результат;
- при ошибках — объясняет, что не так, и предлагает повторить ввод;
- работает в цикле до команды `exit`.

#### 🧱 Структура калькулятора

- Главный цикл `while`, который работает до ввода `exit`;
- Получение операции от пользователя `(+, -, *, /)`;
- Запрос двух чисел с проверкой через `try/except`;
- Выполнение операции;
- Вывод результата или сообщения об ошибке.

#### ✅ Пример кода калькулятора

```python
def get_number(prompt):
    """Функция безопасного ввода числа."""
    while True:
        try:
            return float(input(prompt))
        except ValueError:
            print("Ошибка: введите корректное число.")

def calculate(a, b, op):
    """Функция вычисления результата."""
    try:
        if op == '+':
            return a + b
        elif op == '-':
            return a - b
        elif op == '*':
            return a * b
        elif op == '/':
            return a / b
        else:
            raise ValueError("Неизвестная операция.")
    except ZeroDivisionError:
        print("Ошибка: деление на ноль.")
        return None
    except ValueError as ve:
        print("Ошибка:", ve)
        return None

def calculator():
    print("Добро пожаловать в калькулятор!")
    print("Введите одну из операций: +, -, *, /")
    print("Для выхода введите 'exit'\n")

    while True:
        op = input("Операция (+, -, *, / или exit): ").strip()

        if op == 'exit':
            print("Выход из программы.")
            break

        if op not in ('+', '-', '*', '/'):
            print("Ошибка: неизвестная операция.")
            continue

        a = get_number("Введите первое число: ")
        b = get_number("Введите второе число: ")

        result = calculate(a, b, op)
        if result is not None:
            print("Результат:", result)
        print("-" * 40)

# Запуск приложения
calculator()
```

#### 🔍 Комментарии к коду

- `get_number()` — защищает от ввода текста вместо числа;
- `calculate()` — обрабатывает деление на 0 и неправильные операции;
- Главный цикл:
  - принимает команды;
  - проверяет на `exit`;
  - вызывает остальные функции;
- Программа не падает ни при каком вводе, и даёт внятные комментарии пользователю.

### Задачи

1. Деление с обработкой ошибки. Напишите программу, которая запрашивает у пользователя два числа и выводит результат их деления.
   Обработайте ошибку деления на ноль (ZeroDivisionError) и ошибку ввода (ввели не число).

2. Индекс в списке. Создайте список из 5 элементов. Запросите у пользователя индекс и выведите элемент списка.
   Обработайте:

- ввод строки вместо числа,
- выход за пределы списка (IndexError).

3. Преобразование строки в число. Запросите у пользователя строку. Попробуйте преобразовать её в число (int()). Обработайте ситуацию, если строка не может быть преобразована (ValueError), и выведите сообщение: "Введите целое число!".

4. Проверка ключа в словаре. Создайте словарь с 3 парами ключ-значение. Запросите у пользователя ключ и попробуйте вывести его значение.
   Обработайте исключение KeyError.

5. Использование блока else. Модифицируйте задание 1: если деление прошло успешно, результат должен быть выведен в блоке else. Если возникла ошибка — в except.

6. Блок finally при работе с файлом. Создайте текстовый файл с несколькими строками. Напишите программу, которая:

- читает файл;
- выводит содержимое;
- обязательно закрывает файл через finally.
  > (Не использовать with!)

7. Функция с обработкой ошибок. Напишите функцию read_int(), которая:

- запрашивает у пользователя число;
- обрабатывает ошибку ValueError;
- возвращает число, если оно корректное.

8. Множественная обработка исключений. Запросите у пользователя число и попытайтесь:

- преобразовать в int,
- извлечь элемент списка по этому индексу,
- поделить 100 на это число.

> Обработайте:

- ValueError — неправильный ввод,
- IndexError — индекс вне списка,
- ZeroDivisionError.

9. Интерфейс ввода данных с проверками. Напишите программу, которая:

- запрашивает у пользователя имя, возраст и e-mail;
- проверяет:
- имя — не пустая строка;
- возраст — целое число;
- e-mail содержит символ @.
  > Выводит ошибки, если данные некорректны.

10. (Не обязательно) Калькулятор с логированием ошибок. Усовершенствуйте консольный калькулятор:

- все ошибки (деление на 0, ValueError и пр.) должны записываться в файл errors.log;
- лог должен содержать время, тип ошибки и сообщение.
- Пример строки лога:

```yaml
[2025-05-15 14:22:05] ValueError: Введено не число
```

> Используйте `try/except`, `finally` и модуль `datetime`.
