## Урок 30: Обработка произвольного количества аргументов (\*args и \*\*kwargs)

### 30.1 Что такое \*args и \*\*kwargs

`*args `и `**kwargs` — это специальные конструкции в Python, которые позволяют **передавать функции произвольное количество позиционных** (`*args`) или **именованных** (`**kwargs`) аргументов.

- `*args` собирает переданные позиционные аргументы в кортеж.
- `**kwargs` собирает переданные именованные аргументы в словарь.

**Иногда** при создании функций **невозможно заранее предугадать**, сколько аргументов понадобится. Используя `*args` и `**kwargs`, мы можем сделать функцию более гибкой, не ограничивая пользователя в количестве передаваемых аргументов.

### 30.2 Объяснение механизма работы \*args

Когда **функция** принимает `*args`, она преобразует все позиционные аргументы в кортеж. Это значит, что **внутри функции можно перебирать эти аргументы с помощью цикла или обращаться к ним по индексу**.

**Пример**:

```python
def process_numbers(*args):
    print("Переданные числа:", args)

process_numbers(1, 2, 3, 4, 5) # Переданные числа: (1, 2, 3, 4, 5)
```

**Пример функции с обработкой `*args`**: Создадим функцию, которая суммирует все переданные числа.

```python
def sum_numbers(*args):
    total = 0  # Инициализируем переменную для суммы
    for number in args:  # Перебираем все переданные аргументы
        total += number  # Добавляем каждый аргумент к общей сумме
    return total

print(sum_numbers(1, 2, 3, 4))  # 10
print(sum_numbers(10, 20, 30))  # 60
```

#### Ограничения \*args:

- `*args` не может обрабатывать именованные аргументы. Передача таких аргументов вызовет ошибку:

  ```python
  def process_numbers(*args):
      print(args)

  process_numbers(a=5)  # Ошибка: именованные аргументы нельзя передать через *args
  ```

- Позиционные аргументы перед `*args` обязательны и должны быть указаны первыми:

  ```python
  def example(arg1, *args):
      print(arg1, args)

  example(10, 20, 30)  # arg1 = 10, args = (20, 30)
  ```

### 30.3 Объяснение механизма работы \*\*kwargs

Когда функция принимает `**kwargs`, она преобразует все именованные аргументы в словарь, где ключи — это имена аргументов, а значения — их значения.

**Пример**:

```python
def display_info(**kwargs):
    print("Переданные данные:", kwargs)

display_info(name="Alice", age=25, country="USA")
```

**Пример функции с обработкой** `**kwargs`: Создадим функцию, которая выводит переданные параметры в формате **"ключ: значение"**.

```python
def print_info(**kwargs):
    for key in kwargs:  # Перебираем ключи словаря
        print(f"{key}: {kwargs[key]}")  # Выводим ключ и соответствующее значение

print_info(name="Alice", age=25, country="USA")
```

### 30.4 Комбинирование \*args и \*\*kwargs

**Можно объединять оба механизма в одной функции**. При этом порядок аргументов должен быть следующим:

- **Позиционные аргументы**.
- `*args` (**дополнительные позиционные аргументы**).
- **Именованные аргументы с значениями по умолчанию**.
- `**kwargs` (**дополнительные именованные аргументы**).

**Пример**:

```python
def full_function(arg1, *args, arg2=10, **kwargs):
    print(f"Обязательный аргумент: {arg1}")
    print(f"Дополнительные позиционные аргументы: {args}")
    print(f"Именованный аргумент с дефолтным значением: {arg2}")
    print(f"Именованные аргументы: {kwargs}")

full_function(1, 2, 3, arg2=20, name="Alice", age=25)
```

### 30.5 Передача аргументов с помощью \* и \*\*

`*` и `**` можно использовать для **распаковки списков и словарей в аргументы функций**.

**Пример Распаковки списка в** `*args`:

```python
def process_numbers(*args):
    for num in args:
        print(num)

numbers = [10, 20, 30]
process_numbers(*numbers)
```

**Пример Распаковки словаря в** `**kwargs`:

```python
def display_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

info = {'name': 'Alice', 'age': 25, 'country': 'USA'}
display_info(**info)
```

**Пример Комбинации распаковок**:

```python
def full_function(*args, **kwargs):
    print("Позиционные аргументы:", args)
    print("Именованные аргументы:", kwargs)

numbers = [1, 2, 3]
info = {'name': 'Alice', 'age': 25}
full_function(*numbers, **info)
```

### 30.6 Keyword-only аргументы

В Python 3 добавили возможность пометить именованные аргументы функции так, чтобы вызвать функцию можно было, только передав эти аргументы по именам. Такие аргументы называются `keyword-only` и их нельзя передать в функцию в виде позиционных.

```python
def make_circle(x, y, radius, *, line_width=1, fill=True):
    pass
```

`*` выступает разделителем: отделяет обычные аргументы от строго именованных.

- **Вызовы функции**:

```python
make_circle(10, 20, 5) # x=10, y=20, radius=5,  line_width=1, fill=True
make_circle(x=10, y=20, radius=7) # x=10, y=20, radius=7,  line_width=1, fill=True
make_circle(10, 20, radius=10, line_width=2, fill=False) # x=10, y=20, radius=10, line_width=2, fill=False
make_circle(x=10, y=20, radius=17, line_width=3) # x=10, y=20, radius=17, line_width=3, fill=True
```

- **Такой вызов приводит к ошибкам**:

```python
make_circle(10, 20, 15, 20)
make_circle(x=10, y=20, 15, True)
make_circle(10, 20, 10, 2, False)
```

- **Можем объявить функцию, у которой будут только строго именованные аргументы**:

```python
def make_circle(*, x, y, radius, line_width=1, fill=True):
  pass
```

- **Вызов функции, у которой будут только строго именованные аргументы**:

```python
make_circle(x=10, y=20, radius=15) # line_width=1, fill=True
make_circle(x=10, y=20, radius=15, line_width=4, fill=False)
```

### 30.7 Практические примеры использования:

1. **Функция для расчета средней оценки**. Создадим функцию, которая **принимает произвольное количество оценок (позиционные аргументы) и возвращает `среднюю оценку`**:

   ```python
   def calculate_average(*args):
       total = 0
       count = 0
       for grade in args:
           total += grade
           count += 1
       return total / count if count > 0 else 0

   print(calculate_average(85, 90, 78, 92))  # 86.25
   print(calculate_average(100, 95))        # 97.5
   ```

2. **Конструктор данных для двумерного списка**. Функция **принимает количество строк и столбцов как первые два аргумента**, а **дополнительные аргументы (\*args) — это значения, которые нужно распределить по ячейкам**.

   ```python
   def create_matrix(rows, cols, *args):
       matrix = []
       values = list(args)
       index = 0
       for i in range(rows):
           row = []
           for j in range(cols):
               if index < len(values):
                   row.append(values[index])
                   index += 1
               else:
                   row.append(0)  # Если значений меньше, чем ячеек, заполняем нулями
           matrix.append(row)
       return matrix

   matrix = create_matrix(3, 3, 1, 2, 3, 4, 5)
   for row in matrix:
       print(row)
   ```

3. **Функция проверки условий**. Функция **принимает переменную, список условий через \*args (например, строки `"проверить больше 5"`, `"проверить четность"`), а затем выводит результаты каждой проверки**.

   ```python
   def check_conditions(value, *args):
       results = []
       for condition in args:
           if condition == "проверить больше 5":
               results.append(value > 5)
           elif condition == "проверить четность":
               results.append(value % 2 == 0)
           elif condition == "проверить отрицательное":
               results.append(value < 0)
           else:
               results.append(False)  # Если условие неизвестно
       return results

   print(check_conditions(7, "проверить больше 5", "проверить четность"))  # [True, False]
   print(check_conditions(-3, "проверить отрицательное"))                 # [True]
   ```

4. **Построение дерева параметров из \*\*kwargs**. Функция **принимает именованные аргументы** (`**kwargs`) и **строит иерархическую структуру, где ключи становятся узлами дерева**.

   ```python
   def build_tree(**kwargs):
       tree = {}
       for key, value in kwargs.items():
           if isinstance(value, dict):  # Если значение — это словарь, рекурсивно создаем поддерево
               tree[key] = build_tree(**value)
           else:
               tree[key] = value
       return tree

   nested_tree = build_tree(
       root1={"child1": {"leaf1": "data1", "leaf2": "data2"}},
       root2={"child2": {"leaf3": "data3"}}
   )

   print(nested_tree)
   ```

5. **Комбинация** `*args` и `**kwargs` **для динамической фильтрации данных**. Функция **принимает список чисел** (`*args`) **и параметры фильтрации через** `**kwargs`**(например,`min_value`, `max_value`)**, а затем **возвращает отфильтрованный список**.

   ```python
   def filter_numbers(*args, **kwargs):
       min_value = kwargs.get('min_value', float('-inf'))
       max_value = kwargs.get('max_value', float('inf'))
       only_even = kwargs.get('only_even', False)

       filtered = []
       for number in args:
           if min_value <= number <= max_value:
               if only_even and number % 2 != 0:
                   continue  # Пропускаем нечетные числа, если фильтр установлен
               filtered.append(number)
       return filtered

   print(filter_numbers(1, 2, 3, 4, 5, 6, min_value=3, max_value=5, only_even=True))  # [4]
   print(filter_numbers(10, 15, 20, only_even=True))                                # [10, 20]
   ```

6. **Генератор отчетов о данных**. Функция **принимает названия секций** (`*args`) **и информацию по каждой секции через** `**kwargs`. **Каждая секция отображается с соответствующими данными**.

   ```python
   def generate_report(*args, **kwargs):
       report = ""
       for section in args:
           report += f"Секция: {section}\n"
           if section in kwargs:
               data = kwargs[section]
               for key, value in data.items():
                   report += f"  {key}: {value}\n"
           else:
               report += "  Нет данных\n"
           report += "\n"
       return report

   report = generate_report(
       "Продажи", "Финансы", "Персонал",
       Продажи={"Январь": 5000, "Февраль": 7000},
       Финансы={"Бюджет": 10000, "Расходы": 8000}
   )
   print(report)
   ```

### Вопросы:

1. Что такое `*args` в Python?
2. Что такое `**kwargs` в Python?
3. В какой тип данных собираются аргументы, переданные через `*args`?
4. В какой тип данных собираются аргументы, переданные через `**kwargs`?
5. Могут ли `*args` и `**kwargs` использоваться в одной функции?
6. Какие ограничения есть у `*args`?
7. Какой тип аргументов следует указывать перед `*args`?
8. Можно ли указать аргументы по умолчанию в функции с `*args` и `**kwargs`?
9. Какой порядок следования аргументов должен быть в функции с `*args` и `**kwargs`?
10. Почему важно учитывать порядок аргументов при использовании `*args` и `**kwargs`?

### Задачи:

1. Создать функцию, которая принимает `*args` и возвращает сумму всех переданных чисел.

   - **Пример входных данных**:
     ```python
     1, 2, 3, 4, 5
     ```
   - **Ожидаемый результат**:
     ```python
     15
     ```

2. Создать функцию, которая принимает `**kwargs` и возвращает строку, содержащую все ключи и значения в формате ключ=значение.

   - Пример входных данных:

     ```python
     name="John", age=30, city="New York"
     ```

   - Ожидаемый результат:

     ```python
     "name=John, age=30, city=New York"
     ```

3. Создать функцию, которая принимает `*args` и возвращает кортеж, содержащий только строки.

   - **Пример входных данных**:
     ```python
     "hello", 123, "world", 456
     ```
   - Ожидаемый результат:
     ```python
     ("hello", "world")
     ```

4. Создать функцию, которая принимает `**kwargs` и возвращает список ключей, у которых значения — строки.

   - **Пример входных данных**:

     ```python
     a=10, b="hello", c=3.14, d="world"
     ```

   - **Ожидаемый результат**:

     ```python
     ["b", "d"]
     ```

5. Создать функцию, которая принимает строку, преобразует её в список слов и возвращает количество слов, длина которых больше 4. Используйте `*args`.

   - **Пример входных данных**:

     ```python
     "The quick brown fox jumps over the lazy dog"
     ```

   - **Ожидаемый результат**:

     ```python
     3
     ```

6. Создать функцию, которая принимает `*args`, преобразует каждое строковое значение в заглавные буквы и возвращает их в списке.

   - **Пример входных данных**:

     ```python
     "python", "is", "fun", 123
     ```

   - **Ожидаемый результат**:

     ```python
     ["PYTHON", "IS", "FUN"]
     ```

7. Создать функцию, которая принимает `**kwargs` и возвращает новый словарь, где все значения преобразованы в строки.

   - **Пример входных данных**:

     ```python
     a=10, b=True, c=None
     ```

   - **Ожидаемый результат**:

     ```python
     {"a": "10", "b": "True", "c": "None"}
     ```

8. Создать функцию, которая принимает `*args` и `**kwargs`, а затем проверяет, есть ли в `*args` элементы, совпадающие с любыми значениями в `**kwargs`.

   - **Пример входных данных**:

     ```python
     *args: 10, 20, 30, "hello"
     **kwargs: a=30, b="world", c="hello"
     ```

   - **Ожидаемый результат**:

     ```python
     ["hello", 30]
     ```

9. Создать функцию, которая принимает строку, преобразует её в словарь (`ключ:значение` через запятую) и возвращает новый словарь, где к каждому значению добавляется префикс из `**kwargs`.

   - **Пример входных данных**:

     ```python
     "a:1, b:2, c:3", prefix="value_"
     ```

   - **Ожидаемый результат**:

     ```python
     {"a": "value_1", "b": "value_2", "c": "value_3"}
     ```

10. Создать функцию, которая принимает список чисел через `*args` и возвращает словарь, где ключами будут индексы, а значениями — числа, умноженные на коэффициент из `**kwargs`.

    - **Пример входных данных**:

      ```python
      1, 2, 3, multiplier=2
      ```

    - **Ожидаемый результат**:

      ```python
      {0: 2, 1: 4, 2: 6}
      ```

11. Создать функцию, которая принимает `\*args`, где каждое значение — строка, и возвращает словарь с подсчетом количества каждого уникального слова.

    - **Пример входных данных**:

      ```python
      "apple", "banana", "apple", "orange", "banana", "banana"
      ```

    - Ожидаемый результат:

      ```python
      {"apple": 2, "banana": 3, "orange": 1}
      ```

12. Создать функцию, которая принимает `*args` и `**kwargs` и проверяет, присутствует ли в `*args` строка, начинающаяся с ключей из `**kwargs`.

    - **Пример входных данных**:

      ```python
      *args: "apple", "banana", "cherry", "apricot"
      **kwargs: prefix1="ap", prefix2="ba"
      ```

    - **Ожидаемый результат**:

      ```python
      ["apple", "banana", "apricot"]
      ```

13. Создать функцию, которая принимает `*args` и `**kwargs`, затем группирует все переданные аргументы в словарь. В kwargs записываются те, что начинаются с буквенных префиксов, а в `*args` — все остальные.

    - **Пример входных данных**:

      ```python
      *args: "123", "apple", 456, "banana"
      **kwargs: prefix1="ap", prefix2="ba"
      ```

    - **Ожидаемый результат**:

      ```python
      {"prefix1": ["apple"], "prefix2": ["banana"], "args": ["123", 456]}
      ```
