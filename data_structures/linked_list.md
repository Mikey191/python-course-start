# Создание класса для реализации односвязного списка

**Односвязный список — это `структура данных`, где элементы связаны между собой с помощью `ссылок`. Каждый элемент (называемый узлом) содержит `свои данные` и `ссылку на следующий узел`**.

## Шаг 1: Реализация узла (Node)

- **Создайте класс** `Node`.
- Внутри класса добавьте:
  - Поле для хранения **данных** (`data`).
  - Поле для хранения **ссылки на следующий узел** (`next`).
- Создайте экземпляр узла и проверьте его содержимое.
- **Схема узла**:
  ```
  Node: [ data: 10 | next: None ]
  ```

**Пример**:

```python
class Node:
    def __init__(self, data):
        self.data = data  # Данные, хранящиеся в узле
        self.next = None  # Ссылка на следующий узел, изначально None
```

## Шаг 2: Создание класса односвязного списка

- **Создайте класс** `LinkedList`.
- Добавьте поле `head`, которое будет указывать на **первый элемент списка**.
- **Схема пустого списка**:
  ```
  LinkedList:
      head -> None
  ```

**Пример**:

```python
class LinkedList:
    def __init__(self):
        self.head = None  # Ссылка на первый узел (голову списка)
```

## Шаг 3: Добавление элемента в начало списка

- Добавьте метод `add_to_front(self, data)` в класс `LinkedList`, который принимает данные.
- Внутри метода:
  - Создайте `новый узел с данными`.
  - Установите `next` нового узла равным текущей `head`.
  - Переместите `head` на `новый узел`.
- **Схема списка после добавления элементов**:
  ```
  LinkedList:
      head -> [ data: 30 | next: -> [ data: 20 | next: -> [ data: 10 | next: None ] ] ]
  ```

**Пример**:

```python
def add_to_front(self, data):
    """
    Метод для добавления элемента в начало списка
    """
    node = Node(data)  # Создаем новый узел
    node.next = self.head  # Новый узел ссылается на текущую голову
    self.head = node  # Новый узел становится головой списка
```

## Шаг 4: Вывод всех элементов списка

- Добавьте метод `print_list(self)`, который перебирает узлы.
- Внутри метода:
  - Создать переменную `current` для хранения `head` списка.
  - Создать цикл, который будет работать пока переменная `current` не станет равна `None`.
  - Внутри цикла на каждой итерации выводим данные `data`.
  - И далее внутри цикла переходим к следующему узлу присвоив в `current` значение `current.next`.
  - После цикла выводим `None`, чтобы обозначить конец списка.
- **Схема вывода**:
  ```
  30 -> 20 -> 10 -> None
  ```

**Пример**:

```python
def print_list(self):
    """
    Метод для вывода в консоль всех элементов списка
    """
    current = self.head  # Начинаем с головы списка
    while current:  # Пока текущий узел не равен None
        print(f"{current.data} -> ", end=" ")  # Выводим данные текущего узла
        current = current.next  # Переходим к следующему узлу
    print(None)  # Выводим "None", чтобы обозначить конец списка
```

## Шаг 5: Добавление элемента в конец списка

- Добавьте метод `add_to_end(self, data)`, который принимает `data`.
- Внутри метода:
  - Создает переменную `current` для нового узела с переданными данными.
  - Проверяем, пуст ли список.
  - Если список пуст, новый узел становится головой.
  - Завершаем выполнение метода с помощью оператора `return`
  - Если проверка на пустой список не отработала, переменной `current` присваиваем значение головы списка.
  - Создать цикл, который будет работать пока переменная `current` не станет равна `None`.
  - Внутри цикла переходим к следующему узлу присвоив в `current` значение `current.next` что бы в конце списка в переменной `current` был последняя нода.
  - Присоединяем новый узел к последнему узлу списка.
- **Схема после добавления элемента в конец**:

```
LinkedList:
    head -> [ data: 10 | next: -> [ data: 40 | next: -> [ data: 50 | next: None ] ] ]
```

**Пример**:

```python
def add_to_end(self, data):
    """
    Метод для добавления элемента в конец списка
    """
    new_node = Node(data)  # Создаем новый узел с переданными данными
    if not self.head:  # Проверяем, пуст ли список
        self.head = new_node  # Если список пуст, новый узел становится головой
        return  # Завершаем выполнение метода
    current = self.head  # Начинаем с головы списка
    while current.next:  # Пока есть следующий узел
        current = current.next  # Переходим к следующему узлу
    current.next = new_node  # Присоединяем новый узел к последнему узлу списка
```

## Шаг 6: Удаление элемента

- Добавьте метод `delete_node(self, data)`, который принимает значение `data`.
- Внутри метода:
  - Проверка на пустой список. Если `self.head` равен `None`, это означает, что список пуст. Выведите `сообщение о том, что список пуст`
  - Завершите выполнение метода с помощью `return`, так как удаление невозможно.
  - Проверьте, совпадают ли данные головы списка с данными, которые нужно удалить.
  - Если совпадают, это означает, что нужно удалить голову списка. Установите `self.head` на следующий узел, тем самым удаляя текущую голову.
  - Завершите выполнение метода с помощью `return`.
  - Создайте переменную `current` и установите её на голову списка.
  - Запустите цикл `while`, который будет продолжаться, пока `current.next` не равен `None` и данные следующего узла не совпадают с искомыми данными `data`.
  - Внутри цикла переместите `current` на следующий узел, чтобы продолжить поиск.
  - После выхода из цикла проверьте, существует ли следующий узел.
  - Если следующий узел существует, это означает, что узел с искомыми данными найден. Сохраните ссылку на узел, который нужно удалить, в переменной `node_to_delete`.
  - Установите `current.next` на следующий узел после удаляемого (current.next = current.next.next), тем самым пропуская удаляемый узел.
  - Используйте оператор `del` для удаления узла из памяти.
  - Если `current.next` равен `None`, это означает, что узел с искомыми данными не найден. Выведите сообщение о том, что `элемент с указанными данными не найден`.
- **Схема до и после удаления**:

    ```
    До удаления:
    LinkedList:
        head -> [ data: 30 | next: -> [ data: 20 | next: -> [ data: 10 | next: None ] ] ]

    После удаления 20:
    LinkedList:
        head -> [ data: 30 | next: -> [ data: 10 | next: None ] ]
    ```

**Пример**:

```python
def delete_node(self, data):
    """
    Метод для удаления элемента по его значению
    """
    if not self.head:  # Проверяем, пуст ли список
        print("linked list is empty")  # Сообщаем, что список пуст
        return  # Завершаем выполнение метода
    if self.head.data == data:  # Проверяем, совпадают ли данные головы с искомыми
        node_to_delete = self.head  # Сохраняем узел для удаления
        self.head = self.head.next # Удаляем голову, перемещая указатель на следующий узел
        del node_to_delete  # Удаляем узел из памяти
        return  # Завершаем выполнение метода
    current = self.head  # Начинаем с головы списка
    while current.next and current.next.data != data:  # Ищем узел с искомыми данными
        current = current.next  # Переходим к следующему узлу
    if current.next:  # Если нашли узел с искомыми данными
        node_to_delete = current  # Сохраняем узел для удаления
        current.next = current.next.next  # Пропускаем удаляемый узел
        del node_to_delete  # Удаляем узел из памяти
        return  # Завершаем выполнение метода
    print("data is not found")  # Если узел не найден сообщаем, что элемент не найден
```
