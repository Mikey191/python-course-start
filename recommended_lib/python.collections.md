# Библиотека `collections`
- [Counter](#1-from-collections-import-counter)
- [defaultdict](#2-from-collections-import-defaultdict)
- [OrderedDict](#3-from-collections-import-ordereddict)
- [deque](#4-from-collections-import-deque)
- [namedtuple](#5-from-collections-import-namedtuple)
- [ChainMap](#6-from-collections-import-chainmap)

**Библиотека collections в Python предоставляет расширенные структуры данных, которые делают работу с данными более удобной и эффективной.**

## 1. `from collections import Counter`

**Класс `Counter` в Python представляет собой специализированный словарь, предназначенный для подсчета хешируемых объектов**. Он позволяет **легко** и **быстро** **подсчитывать количество вхождений элементов в последовательностях**, таких как **списки**, **строки** и **кортежи**.

### Создание объекта `Counter`
- **При создании Counter из последовательности, он автоматически подсчитывает количество вхождений каждого элемента**. Если передать **пустую последовательность**, будет создан **пустой `Counter`**.
- Если передать в `Counter` словарь, **ключи должны быть хешируемыми**. Если передать **не хешируемый объект, будет вызвано исключение TypeError**.
- **Пример**:
```py
from collections import Counter

# Из строки
counter = Counter("abracadabra")
print(counter)  # Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})

# Из списка
counter = Counter([1, 2, 2, 3, 3, 3])
print(counter)  # Counter({3: 3, 2: 2, 1: 1})

# Из словаря
counter = Counter({'a': 3, 'b': 1})
print(counter)  # Counter({'a': 3, 'b': 1})

# С указанием аргументов
counter = Counter(a=2, b=3, c=1)
print(counter)  # Counter({'b': 3, 'a': 2, 'c': 1})
```

### Методы `Counter`
#### 1. **Метод `elements()`**:
- **Возвращает итератор, который генерирует элементы в соответствии с их количеством**. Если **элемент имеет нулевое или отрицательное количество, он не будет включен в результат**.
- **Поскольку возвращается итератор, его можно использовать только один раз**. Если вы хотите сохранить результат, лучше **преобразовать его в список**.
- **Пример**:
```py
elements = counter.elements()
print(elements)  # <itertools.chain object at 0x000001A9F4079870>
print(list(elements))  # ['apple', 'apple', 'banana']
```

#### 2. **Метод `most_common(n)`**:
- **Возвращает список из `n` наиболее распространенных элементов и их счетчиков**. **Если `n` больше, чем количество уникальных элементов, вернет все элементы**.
- Если **передать отрицательное значение для n, будет возвращен пустой список**. **Также можно использовать most_common() без аргументов, чтобы получить все элементы в порядке убывания частоты**.
- **Пример**:
```py
print(counter.most_common())  # [('apple', 2), ('banana', 1)]
print(counter.most_common(1))  # [('apple', 2)]
print(counter.most_common(5))  # [('apple', 2), ('banana', 1)]
```

#### 3. **Метод `subtract()`**:
- **Метод `subtract()` в классе `Counter` используется для уменьшения счетчиков, основываясь на значениях из другого Counter или итерируемого объекта**. Этот метод позволяет **вычитать количество вхождений элементов, что может быть полезно в различных сценариях**.
- **Пример вычитания**: У вас есть `Counter`, который **подсчитывает количество фруктов**, и вы хотите **уменьшить количество определенных фруктов**.
```py
from collections import Counter

#  Создаем Counter с фруктами
fruits_counter = Counter([
        "apple",
        "banana",
        "apple",
        "banana",
        "apple",
        "orange",
        "apple",
        "banana",
        "apple",
        "orange",
    ]
)

print(fruits_counter)  # Counter({'apple': 5, 'banana': 3, 'orange': 2})

# Вычитаем количество фруктов

fruits_counter.subtract({'apple': 3, 'banana': 2}) 
print(fruits_counter)  # Counter({'apple': 2, 'orange': 2, 'banana': 1})
```
- **Пример вычитание с отрицательными значениями**: Если вы вычитаете больше, чем есть в Counter, это может привести к отрицательным значениям.
```py
from collections import Counter

#  Создаем Counter с фруктами
fruits_counter = Counter({"apple": 5, "banana": 3, "orange": 2})

print(fruits_counter)  # Counter({'apple': 5, 'banana': 3, 'orange': 2})

# Вычитаем количество фруктов
fruits_counter.subtract({'apple': 6, 'banana': 4}) 
print(fruits_counter)  # Counter({'orange': 2, 'apple': -1, 'banana': -1})
```
- **Пример вычитание с использованием итерируемого объекта**: Вычтем значения из списка.
```py
from collections import Counter

#  Создаем Counter с фруктами
fruits_counter = Counter({"apple": 5, "banana": 3, "orange": 2})

print(fruits_counter)  # Counter({'apple': 5, 'banana': 3, 'orange': 2})

# Вычитаем количество фруктов
fruits_counter.subtract(["apple", "apple", "apple", "banana", "banana", "orange"])
print(fruits_counter)  # Counter({'apple': 2, 'banana': 1, 'orange': 1})
```
#### 4. **Метод `update()`**:
- **Обновляет счетчики, добавляя значения из другого Counter или итерируемого объекта**. Можно использовать для **добавления элементов из списка или другого Counter**. Если **элемент отсутствует, он будет добавлен с количеством 1**. Если передать итерируемый объект, который содержит **не хешируемые элементы, будет вызвано исключение TypeError**.
- **Пример**:
```py
from collections import Counter

#  Создаем Counter с фруктами
fruits_counter = Counter({"apple": 5, "banana": 3, "orange": 2})

print(fruits_counter)  # Counter({'apple': 5, 'banana': 3, 'orange': 2})

# Вычитаем количество фруктов
fruits_counter.update(["apple", "apple", "apple", "banana", "banana", "orange"])
print(fruits_counter)  # Counter({'apple': 8, 'banana': 5, 'orange': 3})
```
#### 5. **Арифметические операции** 
- Поддерживаются операции сложения, вычитания, пересечения `(&)`, объединения `(|)`:
- **Пример**:
```py
from collections import Counter

counter1 = Counter(a=3, b=1)
counter2 = Counter(a=1, b=4, c=2)

print(counter1 + counter2)  # Counter({'b': 5, 'a': 4, 'c': 2})
print(counter1 - counter2)  # Counter({'a': 2})
print(counter1 & counter2)  # Counter({'a': 1, 'b': 1})  # Минимум
print(counter1 | counter2)  # Counter({'b': 4, 'a': 3, 'c': 2})  # Максимум
```
#### 5. Итоговый пример: Анализ текста
```py
from collections import Counter
import re

# Текст для анализа
text = """
In software development, counter tools are widely used for analytics. 
For example, counting the most frequently used words in a text is a common task.
"""

# Предобработка текста: приведение к нижнему регистру и разбиение на слова
words = re.findall(r'\w+', text.lower())

# Создание счетчика
word_counter = Counter(words)

# Топ-5 самых частых слов
top_words = word_counter.most_common(5)

print("Топ-5 самых частых слов:")
for word, count in top_words:
    print(f"{word}: {count}")

# Результат:
# Топ-5 самых частых слов:
# in: 2
# software: 1
# development: 1
# counter: 1
# tools: 1
```
### Задачи:
1. **Задача 1**: Создайте Counter из списка, содержащего названия фруктов: ['apple', 'banana', 'orange', 'apple', 'banana', 'banana']. Выведите результат на экран. Ожидаемый результат: Counter({'banana': 3, 'apple': 2, 'orange': 1})

2. **Задача 2**: Используйте метод elements() для получения всех элементов из Counter, созданного из списка ['cat', 'dog', 'cat', 'mouse']. Преобразуйте результат в список и выведите его. Ожидаемый результат: ['cat', 'cat', 'dog', 'mouse']

3. **Задача 3**: Создайте Counter из списка ['red', 'blue', 'red', 'green', 'blue', 'blue'] и получите два наиболее распространенных цвета с помощью метода most_common(2). Выведите результат. Ожидаемый результат: [('blue', 3), ('red', 2)]

4. **Задача 4**: Создайте Counter из списка ['a', 'b', 'a', 'c', 'b'], затем вычтите {'a': 1, 'b': 1} и выведите результат. Ожидаемый результат: Counter({'a': 1, 'c': 1, 'b': 0})

5. **Задача 5**: Создайте Counter из списка ['x', 'y', 'x'], затем обновите его, добавив элементы из списка ['x', 'z', 'z']. Выведите результат. Ожидаемый результат: Counter({'x': 4, 'z': 2, 'y': 1})

6. **Задача 6**: Создайте Counter из списка ['one', 'two', 'three'], затем очистите его с помощью метода clear() и выведите результат. Ожидаемый результат: Counter()

7. **Задача 7**: Напишите программу, которая анализирует текст и подсчитывает частоту слов. Используйте Counter для выполнения следующих шагов:
     - Приведите текст к нижнему регистру.
     - Разделите текст на слова, используя регулярные выражения.
     - Подсчитайте частоту каждого слова.
     - Выведите три наиболее распространенных слова.
     - Пример текста: "Python is great. Python is easy to learn. Python is popular." 
     - Ожидаемый результат: Топ 3 слова: [('python', 3), ('is', 3), ('great', 1)]

## 2. `from collections import defaultdict`

`defaultdict` — **это подкласс встроенного dict, который автоматически создает значения для отсутствующих ключей с использованием функции, переданной в момент его создания**. Это избавляет от необходимости вручную проверять наличие ключа в словаре перед его использованием.

### Создание объекта `defaultdict`
- **При создании defaultdict передается функция, которая будет возвращать значение по умолчанию для отсутствующего ключа**.
- **Пример**:
```py
from collections import defaultdict

# Список в качестве значения по умолчанию
dd = defaultdict(list)
print(dd['missing'])  # []
print(dd) # defaultdict(<class 'list'>, {'missing': []})

# Число по умолчанию
dd = defaultdict(int)
print(dd['missing'])  # 0
print(dd) # defaultdict(<class 'int'>, {'missing': 0})

# Пользовательская функция по умолчанию
dd = defaultdict(lambda: "default_value")
print(dd['missing'])  # "default_value"
print(dd) # defaultdict(<function <lambda> at 0x00000129E72C04A0>, {'missing': 'default_value'})
```

### Методы `defaultdict`
#### 1. default_factory
- Хранит функцию, которая задает значение по умолчанию. Может быть изменена или удалена.
- **Пример**:
```py
dd = defaultdict(int)
dd['missing']
print(dd.default_factory) # <class 'int'>

dd.default_factory = list
dd['key']
print(dd) # defaultdict(<class 'list'>, {'missing': 0, 'key': []})
```

#### 2. Обычные методы словаря defaultdict наследует все методы стандартного словаря:
Они работают так же, как в обычном словаре, с дополнительным поведением для отсутствующих ключей благодаря default_factory.
- `get()`
- `keys()`
- `values()`
- `items()`
- `update()`
- `pop()`
- `clear()`

### Отличия от обычного словаря
- **Создание значения по умолчанию**: В стандартном словаре при обращении к отсутствующему ключу возникает ошибка KeyError:
```py
dd = defaultdict(int)
dd['missing'] # create key

d = {}
# d['missing']  # KeyError
```

- **Упрощение кода при создании начальных или пустых значений словоря**:
```py
# обычный словарь
d = {}
key = 'example'
if key not in d:
    d[key] = []
d[key].append(1)

# defaultdict
from collections import defaultdict

d = defaultdict(list)
d['example'].append(1)
```
### Примеры использования `defaultdict`
1. Группировка данных:
```py
data = [("cat", 2), ("dog", 3), ("cat", 5), ("dog", 1)]

dd = defaultdict(list)
for animal, count in data:
    dd[animal].append(count)

print(dd)  # defaultdict(<class 'list'>, {'cat': [2, 5], 'dog': [3, 1]})
```

2. Подсчет частоты с использованием int:
```py
words = "apple banana apple orange banana apple"
dd = defaultdict(int)

for word in words.split():
    dd[word] += 1

print(dd)  # defaultdict(<class 'int'>, {'apple': 3, 'banana': 2, 'orange': 1})
```

3. Создание вложенных словарей:
```py
dd = defaultdict(lambda: defaultdict(int))
dd['group1']['item1'] += 1
dd['group1']['item2'] += 2
dd['group2']['item1'] += 3

print(dd)  # defaultdict(<function ...>, {'group1': defaultdict(<class 'int'>, {'item1': 1, 'item2': 2}), 'group2': defaultdict(<class 'int'>, {'item1': 3})})
```

4. Работа с пользователем по умолчанию:
```py
dd = defaultdict(lambda: "Unknown")
print(dd['missing'])  # "Unknown"
```
### Итоговый пример: Анализ логов
Рассмотрим задачу анализа логов сервера. Нужно сгруппировать IP-адреса по дням и подсчитать количество обращений для каждого IP.
```py
from collections import defaultdict

# Пример данных логов
logs = [
    ("2024-12-01", "192.168.1.1"),
    ("2024-12-01", "192.168.1.2"),
    ("2024-12-01", "192.168.1.1"),
    ("2024-12-02", "192.168.1.3"),
    ("2024-12-02", "192.168.1.2"),
    ("2024-12-02", "192.168.1.3"),
]

# Структура для хранения результатов
log_data = defaultdict(lambda: defaultdict(int))

# Обработка логов
for date, ip in logs:
    log_data[date][ip] += 1

# Вывод результатов
for date, ips in log_data.items():
    print(f"Дата: {date}")
    for ip, count in ips.items():
        print(f"\tIP {ip}: {count} обращений")

# Результат:
# Дата: 2024-12-01
#   IP 192.168.1.1: 2 обращений
#   IP 192.168.1.2: 1 обращений
# Дата: 2024-12-02
#   IP 192.168.1.3: 2 обращений
#   IP 192.168.1.2: 1 обращений
```

### Задачи для закрепления темы defaultdict
1. **Задача 1**: `Подсчет слов`
Напишите функцию word_count(text: str) -> dict, которая принимает строку текста и возвращает словарь, где ключ — это слово, а значение — количество его вхождений в тексте. Используйте defaultdict для решения.

Пример:

```python
text = "apple banana apple orange banana apple"
print(word_count(text))
# {'apple': 3, 'banana': 2, 'orange': 1}
```

2. **Задача 2**: `Группировка чисел`
Напишите функцию group_by_parity(numbers: list) -> dict, которая принимает список чисел и возвращает словарь с двумя ключами: "even" (четные числа) и "odd" (нечетные числа). Каждое значение — это список чисел соответствующего типа. Используйте defaultdict.

Пример:

```python
numbers = [1, 2, 3, 4, 5, 6]
print(group_by_parity(numbers))
# {'even': [2, 4, 6], 'odd': [1, 3, 5]}
```

3. **Задача 3**: `Список сотрудников по отделам`
В компании есть список сотрудников с указанием их отдела. Напишите функцию group_employees(data: list) -> dict, которая принимает список кортежей в формате (отдел, имя) и возвращает словарь, где ключи — это названия отделов, а значения — списки сотрудников в этих отделах.

Пример:

```python
data = [("HR", "Alice"), ("IT", "Bob"), ("HR", "Carol"), ("IT", "Dave")]
print(group_employees(data))
# {'HR': ['Alice', 'Carol'], 'IT': ['Bob', 'Dave']}
```

4. **Задача 4**: `Сумма по категориям`
Дан список покупок в формате (категория, стоимость). Напишите функцию sum_by_category(data: list) -> dict, которая группирует суммы покупок по категориям.

Пример:

```python
data = [("food", 10), ("tech", 200), ("food", 20), ("clothes", 50)]
print(sum_by_category(data))
# {'food': 30, 'tech': 200, 'clothes': 50}
```

5. **Задача 5**: `Вложенные словари`
Создайте функцию nested_dict_example(data: list) -> dict, которая принимает список кортежей в формате (группа, подгруппа, значение) и возвращает вложенный словарь, где группы содержат подгруппы с их значениями.

Пример:

```python
data = [("group1", "sub1", 10), ("group1", "sub2", 20), ("group2", "sub1", 30)]
print(nested_dict_example(data))
# {
#     'group1': {'sub1': 10, 'sub2': 20},
#     'group2': {'sub1': 30}
# }
```

6. **Обобщающая задача**: `Анализ данных из логов`
Описание задачи: Вам дан список логов работы сервера в формате (дата, IP-адрес). Нужно написать функцию analyze_logs(logs: list) -> dict, которая группирует данные по датам и считает количество обращений с каждого IP-адреса.

Пример данных:
```python
logs = [
    ("2024-12-01", "192.168.1.1"),
    ("2024-12-01", "192.168.1.2"),
    ("2024-12-01", "192.168.1.1"),
    ("2024-12-02", "192.168.1.3"),
    ("2024-12-02", "192.168.1.2"),
    ("2024-12-02", "192.168.1.3"),
]
```
Пример результата:
```python
{
    "2024-12-01": {
        "192.168.1.1": 2,
        "192.168.1.2": 1
    },
    "2024-12-02": {
        "192.168.1.3": 2,
        "192.168.1.2": 1
    }
}
```
Условия:
- Используйте вложенные defaultdict для решения.
- Должны быть обработаны как даты, так и IP-адреса.
Подсказка:
- Можно использовать defaultdict с лямбда-функцией, возвращающей новый словарь defaultdict(int) для вложенной структуры.

## 3. `from collections import OrderedDict`
**`OrderedDict` — это подкласс стандартного словаря Python (dict), который сохраняет порядок добавления элементов**. С момента выхода Python 3.7 **стандартные словари также сохраняют порядок, но OrderedDict остаётся актуальным благодаря дополнительным методам и оптимизациям для задач, где порядок элементов особенно важен**.

### Особенности и отличия от обычного словаря
- **Сохранение порядка добавления**: Хотя с Python 3.7 обычные словари также сохраняют порядок, OrderedDict был первой реализацией этой концепции и предоставляет дополнительные методы для работы с порядком.
- **Методы для управления порядком**: `OrderedDict` имеет методы, такие как `move_to_end`, которые **позволяют изменять порядок элементов**.
- **Оптимизация для операций вставки/удаления**: `OrderedDict` оптимизирован для частого перемещения элементов внутри словаря, что полезно в специфичных сценариях.
- **Понятная структура в задачах, требующих строгого порядка**: Например, при сериализации данных или создании упорядоченных конфигураций.

### Создание и базовое использование
```py
from collections import OrderedDict

# Создание OrderedDict
od = OrderedDict()
od["a"] = 1
od["b"] = 2
od["c"] = 3

print(od)
# OrderedDict([('a', 1), ('b', 2), ('c', 3)])
```

### Методы `OrderedDict`
#### 1. `move_to_end(key, last=True)`
- **Перемещает элемент с указанным ключом либо в конец, либо в начало словаря**.
- **Параметры**:
    - `key`: ключ элемента, который нужно переместить.
    - `last`: если True (по умолчанию), элемент перемещается в конец, иначе — в начало.
- **Пример**:

```python
od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
od.move_to_end('b')
print(od)
# OrderedDict([('a', 1), ('c', 3), ('b', 2)])

od.move_to_end('b', last=False)
print(od)
# OrderedDict([('b', 2), ('a', 1), ('c', 3)])
```

#### 2. `popitem(last=True)`
- **Удаляет и возвращает элемент из конца или начала словаря**.
- **Параметры**:
    - `last`: если True (по умолчанию), удаляет последний элемент, иначе — первый.
- **Пример**:

```python
od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
print(od.popitem())  # ('c', 3)
print(od)
# OrderedDict([('a', 1), ('b', 2)])

print(od.popitem(last=False))  # ('a', 1)
print(od)
# OrderedDict([('b', 2)])
```

#### 3. `__reversed__()`
- **Возвращает итератор, который перебирает ключи в обратном порядке**.
- Пример:
```python
od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
for key in reversed(od):
    print(key)
# c
# b
# a
```

#### 4. Сравнение `OrderedDict`
- `OrderedDict` учитывает порядок элементов при сравнении, в отличие от стандартных словарей.

Пример:
```python
d1 = {"1": 1, "2": 2}
d2 = {"2": 2, "1": 1}
print(d1 == d2) # True, не смотря на порядок

od1 = OrderedDict([('a', 1), ('b', 2)])
od2 = OrderedDict([('b', 2), ('a', 1)])

print(od1 == od2)  # False (разный порядок)
```

### Преимущества и случаи актуального использования
1. **Сериализация данных (JSON с упорядоченными ключами)**: Когда порядок ключей важен для читаемости или совместимости с другими системами.
```py
from collections import OrderedDict
import json

# Создаём OrderedDict с ключами в нужном порядке
ordered_data = OrderedDict([
    ("id", 123),
    ("name", "Alice"),
    ("age", 30),
    ("email", "alice@example.com"),
    ("preferences", OrderedDict([
        ("newsletter", True),
        ("notifications", False),
    ]))
])

# Сериализация в JSON
json_data = json.dumps(ordered_data, indent=4)
print(json_data)

# Вывод:
# {
#     "id": 123,
#     "name": "Alice",
#     "age": 30,
#     "email": "alice@example.com",
#     "preferences": {
#         "newsletter": true,
#         "notifications": false
#     }
# }
```

2. **Упорядоченные конфигурации**: В некоторых случаях порядок параметров конфигурации влияет на интерпретацию программы.
```py
from collections import OrderedDict

# Упорядоченная конфигурация
config = OrderedDict([
    ("database", OrderedDict([
        ("host", "localhost"),
        ("port", 5432),
        ("user", "admin"),
        ("password", "password123"),
    ])),
    ("logging", OrderedDict([
        ("level", "DEBUG"),
        ("file", "app.log"),
    ])),
    ("features", OrderedDict([
        ("enable_feature_x", True),
        ("enable_feature_y", False),
    ])),
])

# Вывод конфигурации в читаемом виде
for section, settings in config.items():
    print(f"[{section}]")
    for key, value in settings.items():
        print(f"{key} = {value}")
    print()

# Вывод:
# [database]
# host = localhost
# port = 5432
# user = admin
# password = password123
#
# [logging]
# level = DEBUG
# file = app.log
#
# [features]
# enable_feature_x = True
# enable_feature_y = False
```

3. **Кэширование (LRU-кэш)**: Кэш на основе стратегии "наименее недавно использованный" (Least Recently Used).
```py
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key: int) -> int:
        if key in self.cache:
            # Переместить элемент в конец, так как он недавно использовался
            self.cache.move_to_end(key)
            return self.cache[key]
        return -1

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            # Обновить значение и переместить в конец
            self.cache.move_to_end(key)
        else:
            if len(self.cache) >= self.capacity:
                # Удалить наименее недавно использованный элемент
                self.cache.popitem(last=False)
            self.cache[key] = value

# Пример использования
lru = LRUCache(2)
lru.put(1, 1)
lru.put(2, 2)
print(lru.get(1))  # 1
lru.put(3, 3)  # Удаляет ключ 2
print(lru.get(2))  # -1 (не найден)
lru.put(4, 4)  # Удаляет ключ 1
print(lru.get(1))  # -1 (не найден)
print(lru.get(3))  # 3
print(lru.get(4))  # 4
```

### Задачи для закрепления темы OrderedDict
1. **Сортировка ключей**
Создайте OrderedDict из обычного словаря. Отсортируйте ключи по алфавиту и выведите результат.
Пример входных данных:

```python
data = {"banana": 3, "apple": 5, "cherry": 2}
```
Ожидаемый результат:

```plaintext
apple: 5
banana: 3
cherry: 2
```

2. **Добавление элемента в начало**
Создайте OrderedDict и добавьте новый элемент в начало словаря.
Пример:

```python
# Исходный словарь
data = OrderedDict([("a", 1), ("b", 2), ("c", 3)])
# Новый элемент: ("z", 0)
```
Ожидаемый результат:

```plaintext
z: 0
a: 1
b: 2
c: 3
```

3. **Использование move_to_end**
Дан OrderedDict с несколькими элементами. Напишите функцию, которая перемещает указанный ключ в конец словаря.
Пример:

```python
data = OrderedDict([("x", 10), ("y", 20), ("z", 30)])
move_key_to_end(data, "y")
```
Ожидаемый результат:

```plaintext
x: 10
z: 30
y: 20
```

4. **Создание конфигурационного файла**
Создайте OrderedDict, который содержит следующие секции:
- general: название и версия программы.
- database: хост, порт и имя пользователя.
- logging: уровень логов и файл для записи.
- Сериализуйте данные в формат JSON и выведите их.

5. **Поиск и удаление элемента**
Напишите функцию, которая ищет в OrderedDict элемент с указанным значением и удаляет его. Если элемент не найден, выводится сообщение об ошибке.
Пример:

```python
data = OrderedDict([("a", 1), ("b", 2), ("c", 3)])
remove_by_value(data, 2)
```
Ожидаемый результат:

```plaintext
a: 1
c: 3
```

6. **Проверка равенства обычного словаря и OrderedDict**
Создайте два словаря: обычный и OrderedDict. Проверьте, одинаковы ли они по содержимому, если порядок ключей различается.
Пример:

```python
dict1 = {"a": 1, "b": 2}
dict2 = OrderedDict([("b", 2), ("a", 1)])
```
Ожидаемый результат:

```plaintext
Обычные словари равны.
OrderedDict и обычный словарь отличаются.
```

7. **Обобщающая задача: Реализация LRU-кэша**
Создайте класс LRUCache, который:
- Использует OrderedDict для хранения данных.
Реализует методы:
- set(key, value): добавляет ключ-значение в кэш.
- get(key): возвращает значение по ключу, перемещая его в конец кэша. Удаляет самый старый элемент при превышении заданного размера.
Пример:

```python
cache = LRUCache(3)
cache.set("a", 1)
cache.set("b", 2)
cache.set("c", 3)
cache.get("a")  # Доступ к "a", чтобы обновить его позицию
cache.set("d", 4)  # Добавление "d", удаление "b" (самый старый)
```
Ожидаемый результат:

```plaintext
a: 1
c: 3
d: 4
```

## 4. `from collections import deque`

**`deque` (`double-ended queue`, двусторонняя очередь) — это структура данных, оптимизированная для эффективного добавления и удаления элементов с обоих концов**.
- Основан на двусвязном списке, что делает операции append и pop с обоих концов очереди выполненными за 𝑂(1).
- В отличие от списка (list), операции вставки/удаления в середине очереди менее эффективны.

### Основные особенности
- **Эффективное добавление и удаление элементов с обоих концов**.
- **Возможность работы как с очередью, так и со стеком**.
- **Опциональная установка максимального размера (`maxlen`), после превышения которого элементы автоматически удаляются с противоположного конца**.

### Методы `deque`
#### 1. Создание deque
```python
from collections import deque

# Пустая очередь
dq = deque()
print(dq) # deque([])

# Очередь с начальными значениями
dq = deque([1, 2, 3, 4, 5])
print(dq)  # deque([1, 2, 3, 4, 5])
dq = deque((1, 2, 3, 4, 5))
print(dq)  # deque([1, 2, 3, 4, 5])
dq = deque({1, 2, 3, 4, 5})
print(dq)  # deque([1, 2, 3, 4, 5])
dq = deque('apple')
print(dq)  # deque(['a', 'p', 'p', 'l', 'e'])

# Очередь с ограничением размера
dq = deque([1, 2, 3, 4, 5, 6], maxlen=3)
print(dq)  # deque([4, 5, 6], maxlen=3)
```

#### 2. Добавление элементов
- `append(x)`: **Добавляет элемент x в конец очереди**.
- `appendleft(x)`: **Добавляет элемент x в начало очереди**.
```python
dq = deque([1, 2, 3])
dq.append(4)       # [1, 2, 3, 4]
dq.appendleft(0)   # [0, 1, 2, 3, 4]
```

#### 3. Удаление элементов
- `pop()`: **Удаляет и возвращает последний элемент**.
- `popleft()`: **Удаляет и возвращает первый элемент**.
```python
dq = deque([1, 2, 3])
dq.pop()           # Удаляет 3, результат: [1, 2]
dq.popleft()       # Удаляет 1, результат: [2]
```

#### 4. Просмотр и изменение элементов
- `clear()`: **Очищает очередь**.
- `index(x, start, stop)`: **Возвращает индекс первого появления элемента x**.
- `insert(index, x)`: **Вставляет элемент x на позицию index**.
- `count(x)`: **Считает количество вхождений элемента x**.
```python
dq = deque([1, 2, 3, 2])
dq.index(2)         # 1
dq.insert(1, 99)    # [1, 99, 2, 3, 2]
dq.count(2)         # 2
dq.clear()          # []
```

#### 5. Работа с ограниченным размером
- `maxlen`: **Если задан, при добавлении нового элемента при полном заполнении очереди удаляется элемент с противоположного конца**.
```python
dq = deque([1, 2, 3], maxlen=3)
dq.append(4)       # [2, 3, 4] (1 удалён)
dq.appendleft(0)   # [0, 2, 3] (4 удалён)
```

#### 6. Перестановка элементов
- `extend(iterable)`: **Расширяет очередь элементами из итерируемого объекта, добавляя их в конец**.
- `extendleft(iterable)`: **Расширяет очередь элементами из итерируемого объекта, добавляя их в начало (в обратном порядке)**.
- `rotate(n)`: **Смещает элементы вправо на n позиций (при отрицательном n — влево)**.
```python
dq = deque([1, 2, 3])
dq.extend([4, 5])         # [1, 2, 3, 4, 5]
dq.extendleft([0, -1])    # [-1, 0, 1, 2, 3, 4, 5]
dq.rotate(2)              # [4, 5, -1, 0, 1, 2, 3]
dq.rotate(-3)             # [0, 1, 2, 3, 4, 5, -1]
```

### Отличия от обычного списка
- **Добавление и удаление с обоих концов**: В списке операции append и pop работают эффективно только с конца. У deque это возможно и с начала.
- **Ограничение длины (`maxlen`)**: В списке такой функциональности нет.
- **Оптимизирован для очередей**: При добавлении/удалении элементов производительность deque выше, чем у списка.

### Актуальность использования
- **Эффективность операций**: **Высокая производительность для задач, связанных с очередями или стеками**.
- **Ограничение размера**: **Полезно для задач, где нужно ограничить количество элементов (например, журнал событий или кэш)**.
- **Гибкость**: **Можно использовать как очередь, стек или двустороннюю очередь, что делает deque универсальным инструментом**.

### Пример использования deque
Реализация системы обработки задач (очередь задач)
```py
from collections import deque
import time

# Создание очереди задач
task_queue = deque(maxlen=10)

# Добавление задач
task_queue.append("Task 1")
task_queue.append("Task 2")
task_queue.append("Task 3")

# Функция обработки задач
def process_tasks(queue):
    while queue:
        current_task = queue.popleft()
        print(f"Processing: {current_task}")
        time.sleep(1)  # Имитируем обработку задачи

# Добавляем новые задачи в процессе работы
task_queue.append("Task 4")
process_tasks(task_queue)
```

### Задачи для закрепления темы deque
1. **Задача 1**: `Очередь запросов`
Напишите программу, которая будет моделировать очередь запросов в системе:
- Создайте пустую очередь с помощью deque.
- Добавьте в очередь 5 строк (названий запросов).
- Удалите два первых запроса из очереди и выведите их.
- Выведите оставшиеся запросы.

2. **Задача 2**: `Обрезка последовательности`
- Создайте очередь с максимальным размером 4.
- Добавьте в нее числа от 1 до 6.
- После каждого добавления выведите текущую очередь.
- Объясните, почему некоторые элементы удаляются.

3. **Задача 3**: `Ротация очереди`
- Создайте очередь, содержащую числа от 1 до 5.
- Проведите 3 ротации вправо.
- Проведите 2 ротации влево.
- Выведите итоговую очередь.

4. **Задача 4**: `Обратный порядок`
- Создайте очередь с элементами "A", "B", "C", "D", "E".
- Разверните очередь, используя только методы popleft и append.
- Выведите очередь в развернутом порядке.

5. **Задача 5**: `Очередь задач с ограничением`
Напишите программу для управления задачами:
- Создайте очередь с максимальным размером 3.
- Добавьте 4 задачи.
- Убедитесь, что при добавлении последней задачи первая была удалена.
- Выведите текущие задачи.

6. **Задача 6**: `Подсчет элементов в очереди`
- Создайте очередь из символов "a", "b", "c", "a", "b", "a".
- Найдите количество вхождений каждого символа с помощью метода count.
- Выведите результат в формате:
```makefile
a: 3
b: 2
c: 1
```

7. **Задача 7**: `Конвейер задач`
- Создайте очередь задач из 5 элементов.
- Каждая задача должна быть обработана (удалена из очереди) и в зависимости от ее результата:
    - Если результат успешный, добавьте задачу в конец очереди.
    - Если результат неуспешный, добавьте задачу в начало.
- Остановите обработку, когда все задачи будут успешно выполнены.
(Подсказка: используйте методы popleft, append и appendleft).

8. **Обобщающая задача**: `Журнал событий`
Напишите программу для управления журналом событий.
- Создайте журнал событий с помощью deque и установите максимальный размер 5.
Реализуйте следующую функциональность:
- Добавление события: Каждое событие добавляется в конец журнала.
- Просмотр событий: Выведите все события в журнале в порядке добавления.
- Удаление старых событий: Если журнал заполнен, при добавлении нового события удаляется самое старое.
- Смоделируйте работу системы:
    - Добавьте 7 событий в журнал.
    - После добавления каждого события выведите содержимое журнала.
Пример вывода:

```less
Добавлено событие: Event 1
Текущий журнал: ['Event 1']

Добавлено событие: Event 2
Текущий журнал: ['Event 1', 'Event 2']

...
Добавлено событие: Event 7
Текущий журнал: ['Event 3', 'Event 4', 'Event 5', 'Event 6', 'Event 7']
```

## 5. `from collections import namedtuple`

**`namedtuple` — это специальный класс из модуля `collections`, который позволяет создавать неизменяемые объекты, похожие на кортежи, но с доступом к элементам через имена полей, а не только через индексы. Он помогает делать код более читаемым и структурированным, особенно когда данные связаны логически**.

### Особенности и отличия от обычного кортежа:
- **Имена полей**: **У элементов есть имена, и к ним можно обращаться через атрибуты, а не только через индексы.**
- **Иммутабельность**: **`namedtuple` неизменяем, как и обычный кортеж**.
- **Читаемость**: **Код с `namedtuple` легче понять, так как имена атрибутов объясняют их смысл**.
- **Универсальность**: **Можно использовать методы, специфичные для `namedtuple`, такие как `_asdict`, `_replace` и другие**.

### Создание и использование `namedtuple`
```py
from collections import namedtuple

# Создание namedtuple
Point = namedtuple('Point', ['x', 'y'])

# Создание экземпляра
p = Point(10, 20)
print(p)  # Point(x=10, y=20)
```

### Доступ к элементам
- По имени поля
```python
print(p.x)  # 10
print(p.y)  # 20
```

- По индексу
```python
print(p[0])  # 10
print(p[1])  # 20
```

### Методы и свойства namedtuple
#### 1. `_make(iterable)`
- **Создает объект `namedtuple` из итерации**.

- **Пример**:

```python
data = [30, 40]
p = Point._make(data)
print(p)  # Point(x=30, y=40)

data = range(2)
p = Point._make(data)
print(p)  # Point(x=0, y=1)

data = ("30", "40")
p = Point._make(data)
print(p)  # Point(x='30', y='40')
```

#### 2. `_asdict()`
- **Возвращает объект в виде словаря**.

- **Пример**:

```python
data = [30, 40]
p = Point._make(data)
print(p._asdict())  # {'x': 30, 'y': 40}

data = range(2)
p = Point._make(data)
print(p._asdict())  # {'x': 0, 'y': 1}

data = ("30", "40")
p = Point._make(data)
print(p._asdict())  # {'x': '30', 'y': '40'}
```

#### 3. `_replace(**kwargs)`
- **Возвращает новый объект с замененными значениями**.

- **Пример**:

```python
p_new = p._replace(y=50)
print(p_new)  # Point(x=10, y=50)
```

#### 4. `_fields`
- **Возвращает имена полей**.

- **Пример**:

```python
print(Point._fields)  # ('x', 'y')
```

#### 5. `_field_defaults`
- **Возвращает значения по умолчанию для полей (начиная с Python 3.7)**.

- **Пример**:

```python
Person = namedtuple('Person', ['name', 'age'], defaults=['Unknown', 30])
p3 = Person()
print(p3)  # Person(name='Unknown', age=30)
```

### Когда использовать namedtuple:
- **Для структурированных данных, где важна неизменяемость**.
- **Когда нужно объединить свойства кортежа (эффективность) и понятность словаря (читаемость)**.
- **Для замены структур данных, похожих на объекты, без необходимости использования полноценного класса**.

### Итоговое использование namedtuple
Рассмотрим пример, приближенный к реальному проекту: **управление координатами и цветами точек на графике.**

```py
from collections import namedtuple

# Описание структуры точки
Point = namedtuple('Point', ['x', 'y', 'color'])

# Список точек
points = [
    Point(10, 20, 'red'),
    Point(30, 40, 'blue'),
    Point(50, 60, 'green')
]

# Пример обработки
for point in points:
    print(f"Точка ({point.x}, {point.y}) имеет цвет {point.color}")

# Добавление новой точки из списка
new_point_data = [70, 80, 'yellow']
new_point = Point._make(new_point_data)
print(new_point)  # Point(x=70, y=80, color='yellow')

# Замена цвета у первой точки
updated_point = points[0]._replace(color='black')
print(updated_point)  # Point(x=10, y=20, color='black')

# Преобразование точек в словари
points_dicts = [point._asdict() for point in points]
print(points_dicts)
# [{'x': 10, 'y': 20, 'color': 'red'}, {'x': 30, 'y': 40, 'color': 'blue'}, {'x': 50, 'y': 60, 'color': 'green'}]
```

### Задачи для закрепления темы namedtuple
1. **Задача 1**: **Характеристики автомобиля**
- Создайте namedtuple для описания автомобиля с полями: brand, model, year, color.
- Создайте список из 3 автомобилей.
- Выведите на экран только brand и model каждого автомобиля.
- Преобразуйте первый автомобиль в словарь и измените его color на "black".

2. **Задача 2**: **Студенты и оценки**
- Создайте namedtuple для представления данных о студенте: name, age, grade.
- Создайте список студентов (минимум 5).
- Найдите студентов с оценкой выше 80.
- Преобразуйте всех студентов в словари и выведите их в читаемом формате.

3. **Задача 3**: **Описание книг**
- Создайте namedtuple для описания книги с полями: title, author, year, price.
- Создайте список из 4 книг.
- Добавьте новую книгу с использованием метода _make.
- Увеличьте цену каждой книги на 10% с использованием метода _replace.
- Выведите список книг в виде словарей.

4. **Задача 4**: **Фильмы и рейтинги**
- Создайте namedtuple для фильмов с полями: title, director, rating.
- Создайте список из 5 фильмов.
- Найдите фильм с наивысшим рейтингом.
- Замените режиссера первого фильма на "Unknown" и выведите измененную информацию.

5. **Задача 5**: **Координаты точек**
- Создайте namedtuple для представления координат с полями: x, y, z.
- Создайте список из 4 точек.
- Вычислите расстояние от каждой точки до начала координат (0, 0, 0).
- Найдите точку, наиболее удаленную от начала координат.

6. **Обобщающая задача**. **Управление продуктами в магазине**.
- Создайте программу для управления продуктами в магазине.
    - Создайте namedtuple Product с полями: name, category, price, quantity.
    - Создайте список из 6 продуктов (разные категории).
- Реализуйте следующие функции:
    - Вывести все продукты, сгруппированные по категориям.
    - Увеличить количество продуктов определенной категории на 10.
    - Увеличить цену всех продуктов на 5%.
    - Преобразовать все продукты в словари и вывести их.
- Пример:

```python
from collections import namedtuple

# Создаем namedtuple
Product = namedtuple('Product', ['name', 'category', 'price', 'quantity'])

# Список продуктов
products = [
    Product('Apple', 'Fruits', 1.2, 50),
    Product('Orange', 'Fruits', 1.5, 30),
    Product('Carrot', 'Vegetables', 0.8, 100),
    Product('Potato', 'Vegetables', 0.5, 200),
    Product('Milk', 'Dairy', 2.0, 20),
    Product('Cheese', 'Dairy', 5.0, 10)
]

# Группировка по категориям
categories = {}
for product in products:
    categories.setdefault(product.category, []).append(product)

print("Продукты по категориям:")
for category, items in categories.items():
    print(f"{category}: {[item.name for item in items]}")

# Увеличение количества продуктов
updated_products = [p._replace(quantity=p.quantity + 10) if p.category == 'Fruits' else p for p in products]

# Увеличение цены всех продуктов
updated_products = [p._replace(price=round(p.price * 1.05, 2)) for p in updated_products]

# Преобразование в словари
products_dicts = [p._asdict() for p in updated_products]
print("\nОбновленный список продуктов:")
for p in products_dicts:
    print(p)
```

## 6. `from collections import ChainMap`

**Модуль `ChainMap` из библиотеки `collections` предоставляет специальный контейнер для объединения нескольких словарей или отображений в одну логическую структуру**. Он позволяет **работать с объединенными данными как с одним объектом, сохраняя при этом доступ к каждому из оригинальных словарей**.

### Ключевые особенности `ChainMap`:
- **Объединение словарей**: **Позволяет объединить несколько словарей без копирования данных. Изменения в оригинальных словарях отражаются в `ChainMap`**.
- **Порядок поиска**: **При обращении к ключу поиск происходит в порядке добавления словарей. Первый словарь имеет приоритет**.
- **Изменения**: **Все изменения (добавление, обновление, удаление) применяются только к первому словарю**.

### Создание объекта ChainMap
```python
from collections import ChainMap

dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 3, 'c': 4}
chain = ChainMap(dict1, dict2)

print(chain)  # ChainMap({'a': 1, 'b': 2}, {'b': 3, 'c': 4})
print(chain['b'])  # 2 (значение из dict1, т.к. оно имеет приоритет)
```

### Методы и свойства `ChainMap`
#### 1. `maps`: 
- **Возвращает список отображений (словари), составляющих объект ChainMap**.

```python
print(chain.maps)  # [{'a': 1, 'b': 2}, {'b': 3, 'c': 4}]
```
#### 2. `new_child()`: 
- **Создает новый уровень (добавляет словарь в начало цепочки). Это полезно для локальных изменений, например, в контексте параметров или настроек**.

```python
new_chain = chain.new_child({'d': 5})
print(new_chain)  # ChainMap({'d': 5}, {'a': 1, 'b': 2}, {'b': 3, 'c': 4})
```

#### 3. `parents`: 
- **Возвращает новую цепочку без первого словаря (удаляет верхний уровень)**.

```python
parent_chain = chain.parents
print(parent_chain)  # ChainMap({'b': 3, 'c': 4})
```

#### 4. `keys()` и `values()`: 
- **Возвращают итераторы по ключам и значениям**.

```python
print(list(chain.keys()))  # ['a', 'b', 'c']
print(list(chain.values()))  # [1, 2, 4]
```
#### 5. `update()`: 
- **Обновляет только первый словарь в цепочке**.

```python
chain.update({'a': 10, 'e': 7})
print(chain)  # ChainMap({'a': 10, 'b': 2, 'e': 7}, {'b': 3, 'c': 4})
```

#### 6. `copy()`: 
- **Возвращает копию объединения в виде одного словаря**.

```python
merged = chain.copy()
print(merged)  # {'a': 1, 'b': 2, 'c': 4}
```

### Отличия от обычных словарей
- **Объединение без копирования**:** В отличие от метода `dict.update()`, `ChainMap` не создает нового словаря, а объединяет ссылки на существующие**.
- **Изменяемость**: **Изменения применяются только к первому словарю**.
- **Порядок поиска**: **Обеспечивает приоритет значений из первых словарей**.

### Примеры использования ChainMap
#### 1. **Управление конфигурациями**
```python
default_config = {'theme': 'light', 'language': 'en'}
user_config = {'theme': 'dark'}

config = ChainMap(user_config, default_config)
print(config['theme'])  # dark (приоритет user_config)
print(config['language'])  # en (берется из default_config)
```

#### 2. Реализация локальных изменений
```python
global_vars = {'x': 1, 'y': 2}
local_vars = {'y': 10}

scope = ChainMap(local_vars, global_vars)
print(scope['y'])  # 10 (локальная переменная имеет приоритет)
```

#### 3. Объединение данных
```python
data1 = {'name': 'Alice', 'age': 25}
data2 = {'age': 30, 'city': 'New York'}
data3 = {'country': 'USA'}

combined = ChainMap(data1, data2, data3)
print(combined['age'])  # 25 (значение из data1)
print(combined['city'])  # New York (значение из data2)
```

### Реальный пример использования
#### Контекст: Система управления настройками
Предположим, что вы разрабатываете приложение, которое использует несколько уровней настроек:
- глобальные настройки 
- настройки пользователя 
- временные настройки, определенные в сессии.

```python
from collections import ChainMap

# Глобальные настройки
global_settings = {
    'theme': 'light',
    'language': 'en',
    'notifications': True
}

# Настройки пользователя
user_settings = {
    'theme': 'dark',
    'language': 'fr'
}

# Настройки текущей сессии
session_settings = {
    'notifications': False
}

# Объединение настроек
settings = ChainMap(session_settings, user_settings, global_settings)

# Использование настроек
print("Тема:", settings['theme'])  # dark (из user_settings)
print("Язык:", settings['language'])  # fr (из user_settings)
print("Уведомления:", settings['notifications'])  # False (из session_settings)

# Изменение настроек только для текущей сессии
settings['theme'] = 'blue'
print(settings.maps[0])  # {'notifications': False, 'theme': 'blue'}

# Добавление временного уровня
temporary = settings.new_child({'temporary_setting': 'value'})
print(temporary['temporary_setting'])  # value
```

### Задачи для закрепления темы ChainMap
1. **Задача 1**: `Работа с несколькими уровнями данных`
Объедините три словаря:
- default_config = {'theme': 'light', 'language': 'en'}
- user_config = {'theme': 'dark'}
- session_config = {'language': 'fr', 'font_size': '12px'}

Создайте объект ChainMap, который объединяет эти словари. Ответьте на вопросы:
- Какое значение будет у ключа 'theme'?
- Какое значение будет у ключа 'language'?
- Как добавить новое значение {'font_family': 'Arial'} только в session_config?

2. **Задача 2**: `Использование new_child`
Создайте базовый словарь:

```python
base_dict = {'x': 10, 'y': 20}
```
Добавьте новый уровень с ключами 'z': 30 и 'y': 50 с помощью метода new_child. Выведите объединенный объект и найдите значение ключа 'y'.

3. **Задача 3**: `Поиск и изменение значений`
Даны словари:

```python
data1 = {'a': 1, 'b': 2}
data2 = {'b': 3, 'c': 4}
data3 = {'c': 5, 'd': 6}
```
- Создайте объект ChainMap, объединяющий эти словари.
- Проверьте, какие значения будут у ключей 'b' и 'c'.
- Обновите ключ 'a' до значения 10 и добавьте новый ключ 'e': 7 только в первый словарь.

4. **Задача 4**: `Удаление уровня`
Дан объект `ChainMap`, состоящий из словарей:

```python
dict1 = {'key1': 1, 'key2': 2}
dict2 = {'key2': 3, 'key3': 4}
dict3 = {'key3': 5, 'key4': 6}
chain = ChainMap(dict1, dict2, dict3)
```
- Удалите первый уровень с помощью свойства parents.
- Найдите значение ключа 'key2' после удаления.

5. **Задача 5**: `Слияние и копирование`
Создайте два словаря:

```python
dict1 = {'a': 100, 'b': 200}
dict2 = {'b': 300, 'c': 400}
```
- Объедините их в ChainMap.
- Преобразуйте объединенные данные в один обычный словарь с помощью метода copy.
- Проверьте, какой результат получится, если использовать метод update для добавления нового значения {'d': 500} в первый словарь.

6. **Обобщающая задача**: `Управление настройками`
**Вы разрабатываете приложение для настройки конфигурации. В системе используются три уровня настроек**:

Глобальные настройки:
```python
global_settings = {
    'theme': 'light',
    'language': 'en',
    'notifications': True
}
```
Пользовательские настройки:
```python
user_settings = {
    'theme': 'dark',
    'language': 'fr'
}
```
Сессионные настройки:
```python
session_settings = {
    'language': 'es',
    'notifications': False
}
```
Задания:
- Объедините все уровни настроек в объект `ChainMap`.
- Проверьте значения для ключей `'theme'`, `'language'`, и `'notifications'`.
- Создайте новый временный уровень с ключом `'debug_mode': True` с помощью метода `new_child`. Проверьте, доступен ли этот ключ в объединенном объекте.
- Удалите сессионный уровень и проверьте, как изменились значения ключей `'language'` и `'notifications'`.
- Сохраните объединенные данные в один обычный словарь для последующей сериализации.