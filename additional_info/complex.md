# Числовые типы данных

**В Python есть три дополнительных числовых типа данных**:

- `Decimal` – **десятичное число, для выполнения точных расчетов**;
- `Fraction` – **число, представляющее собой обыкновенную дробь, с заданным числителем и знаменателем**;
- `Complex` – **комплексное число**.

## Decimal

### **Сравнение чисел `float`**

Сравним два кода:

```python
# Первый
if 0.3 == 0.3:
    print('YES')
else:
    print('NO')

# Вывод: YES


# Второй
num = 0.1 + 0.1 + 0.1

if num == 0.3:
    print('YES')
else:
    print('NO')

# Вывод: NO
```

Результатом выполнения второго кода будет `NO`, так как на самом деле в переменной `num` хранится что-то типа `0.30000000000000004`.

Из-за ограничений в **сохранении точного значения** чисел даже простейшие математические операции могут **выдавать ошибочный результат**. Поэтому, **чтобы сравнивать два `float` числа, мы должны использовать такой код**:

```python
num = 0.1 + 0.1 + 0.1
eps = 0.000000001           # точность сравнения

if abs(num - 0.3) < eps:    # число num отличается от числа 0.3 менее чем 0.000000001
    print('YES')
else:
    print('NO')
```

### **Тип данных `Decimal`**

**Тип данных `Decimal` – это класс из стандартного модуля `decimal`**. Он представляет собой **число с плавающей точкой**, как и `float`. **Однако `Decimal` имеет ряд существенных отличий от `float`**. Тип Decimal создан, чтобы операции над вещественными числами в компьютере выполнялись как в математике, и равенство `0.1 + 0.1 + 0.1 == 0.3` было верным.

Точность результатов арифметических действий очень важна для **научных вычислений**, **в сфере финансов** и **бизнеса**. **Для таких задач тип данных `float` не подходит**.

Тип данных `float` реализован по стандарту `IEEE-754` как число с плавающей точкой двойной точности (`64 бита`) с основанием экспоненты равным `2`. Так как `float` поддерживается аппаратно, **быстродействие при использовании этого типа данных сравнительно велико**.

**Тип данных `Decimal` – число с плавающей точкой с основанием экспоненты `10`**. Он реализован по стандарту `IBM: General Decimal Arithmetic Specification`, в свою очередь основанному на стандартах `IEEE`.

Тип данных `Decimal` реализован программно, поэтому он **в разы медленнее типа данных `float`**, реализованного аппаратно.

**Тип данных `Decimal` оперирует числами с произвольной – задаваемой программистом, но конечной точностью**. По умолчанию точность составляет 28 десятичных знаков.

**Тип данных `Decimal` – неизменяемый**. Операции над ним приводят к созданию новых объектов, при этом старые не меняются.

Так как `Decimal` **реализован программно** – его можно **на ходу настраивать как угодно программисту**. Для этого есть **контекст** – **объект, содержащий настройки для выполнения операций**. **Операции, выполняемые в контексте, следуют заданным в нем правилам**. Для **`float` все правила фиксированы на аппаратном уровне**.

Для типа данных `Decimal` можно **настроить**:

- **точность выполнения операций в количестве десятичных знаков**;
- **режимы округления**;
- **режимы обработки исключительных ситуаций** (деление на ноль, переполнение и так далее).

### **Создание `Decimal` чисел**

**Создать `Decimal` число можно из обычного целого числа (`int`), из числа с плавающей точкой (`float`) или из строки (`str`)**.

```python
from decimal import *

d1 = Decimal(1)
d2 = Decimal(567)
d3 = Decimal(-93)
d4 = Decimal('12345')
d5 = Decimal('52.198')

print(d1, d2, d3, d4, d5, sep='\n')

# Вывод:
# 1
# 567
# -93
# 12345
# 52.198
```

**При создании `Decimal` чисел из чисел с плавающей точкой (`float`) возникают проблемы.**

```python
from decimal import *

num = Decimal(0.1)

print(num)
# Вывод: 0.1000000000000000055511151231257827021181583404541015625
```

Не рекомендуется создавать `Decimal` числа из `float` чисел. В `Decimal` попадет уже неправильно округленное число. Создавать `Decimal` числа нужно из `целых чисел`, либо из `строк`!

### **Арифметические операции над `Decimal` числами**

С `Decimal` числами **работают все привычные операции**: `сложение`, `вычитание`, `умножение`, `деление`, `возведение в степень`.

```python
from decimal import *

num1 = Decimal('5.2')
num2 = Decimal('2.3')

print(num1 + num2)
print(num1 - num2)
print(num1 * num2)
print(num1 / num2)
print(num1 // num2)
print(num1 ** num2)

# Вывод
# 7.5
# 2.9
# 11.96
# 2.260869565217391304347826087
# 2
# 44.34122533787992500412791298
```

Можно совершать **арифметические операции над `Decimal` и целыми числами**, но **не рекомендуется смешивать их с `float`**.

```python
from decimal import *

num = Decimal('5.2')

print(num + 1)
print(num - 10)
print(num * 2)
print(num ** 4)

# Вывод:
# 6.2
# -4.8
# 10.4
# 731.1616
```

### **Математические функции**

Тип данных `Decimal` содержит некоторые **встроенные математические методы**, возвращающие значения `Decimal`.

- `sqrt()` вычисляет **квадратный корень** из `Decimal` числа.
- `exp()` возвращает **`e` в степени `x`** для `Decimal` числа.
- `ln()` вычисляет **натуральный логарифм** (по основанию e) `Decimal` числа.
- `log10()` вычисляет **десятичный логарифм** (по основанию 10) `Decimal` числа.

```python
from decimal import *

num = Decimal('10.0')

print(num.sqrt())
print(num.exp())
print(num.ln())
print(num.log10())

# Вывод:
# 3.162277660168379331998893544
# 22026.46579480671651695790065
# 2.302585092994045684017991455
# 1
```

Тип данных `Decimal` также содержит полезный метод `as_tuple()` который возвращает **кортеж из 3 элементов**:

- `sign` – **знак числа** (0 для положительного числа и 1 для отрицательного числа);
- `digits` – **цифры числа**;
- `exponent` – **значение экспоненты** (количество цифр после точки, умноженное на −1),

```python
from decimal import *

num1 = Decimal('-1.4568769017')
num2 = Decimal('0.523')

print(num1.as_tuple())
print(num2.as_tuple())

# Вывод:
# DecimalTuple(sign=1, digits=(1, 4, 5, 6, 8, 7, 6, 9, 0, 1, 7), exponent=-10)
# DecimalTuple(sign=0, digits=(5, 2, 3), exponent=-3)
```

```python
from decimal import *

num = Decimal('-1.4568769017')
num_tuple = num.as_tuple()

print(num_tuple.sign)
print(num_tuple.digits)
print(num_tuple.exponent)
# Вывод:
# 1
# (1, 4, 5, 6, 8, 7, 6, 9, 0, 1, 7)
# -10
```

### **Работа с контекстом `Decimal` чисел**

**Базовые параметры `Decimal` можно посмотреть в его контексте, выполнив функцию `getcontext()`**.

```python
from decimal import *

print(getcontext())
# Вывод:
# Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])
```

### **Точность чисел**

**Контекстом в `Decimal` можно управлять, устанавливая свои значения**. Например, чтобы управлять точностью `Decimal`, необходимо **изменить параметр контекста `prec`** (от англ. precision – точность). При этом **точность вступает в силу только во время арифметических операций, а не при создании самих чисел**.

```python
from decimal import *

getcontext().prec = 3      # устанавливаем точность в 3 знака

num = Decimal('3.1415')

print(num)
print(num * 1)
print(num * 2)
print(num / 2)
# Вывод:
# 3.1415
# 3.14
# 6.28
# 1.57
```

### **Округление чисел**

**Округляют числа `Decimal` с помощью метода `quantize()`**. Этот метод **в качестве первого аргумента принимает объект `Decimal`, указывающий на формат округления**.

```python
from decimal import *

getcontext().prec = 4                    # устанавливаем точность числа

num = Decimal('3.1415926535')

print(num.quantize(Decimal('1.000')))    #  округление до 3 цифр в дробной части  
print(num.quantize(Decimal('1.00')))     #  округление до 2 цифр в дробной части
print(num.quantize(Decimal('1.0')))      #  округление до 1 цифр в дробной части

# Вывод:
# 3.142
# 3.14
# 3.1
```

Если **точность округления установлена в 2**, а **формат округления Decimal('1.00')**, то **возникнет ошибка**. Чтобы избежать ее, необходимо **поменять точность округления на 3 и больше**.

```python
from decimal import *

getcontext().prec = 2                    # устанавливаем точность округления

num = Decimal('3.1415926535')

print(num.quantize(Decimal('1.00')))     #  округление до 2 цифр в дробной части

# Ошибка: decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>]
```

Помимо первого параметра, **метод `quantize()` принимает в качестве второго параметра стратегию округления**:
- `ROUND_CEILING` – **округление в направлении бесконечности** (Infinity);
- `ROUND_FLOOR` – **округляет в направлении минус бесконечности** (- Infinity);
- `ROUND_DOWN` – **округление в направлении нуля**;
- `ROUND_HALF_EVEN` – **округление до ближайшего четного числа, число `6.5` округлится не до `7`, а до `6`**;
- `ROUND_HALF_DOWN` – **округление до ближайшего нуля**;
- `ROUND_UP` – **округление от нуля**;
- `ROUND_05UP` – **округление от нуля** (если последняя цифра после округления до нуля была бы `0` или `5`, в противном случае – `к нулю`).

```python
from decimal import *

num = Decimal('3.456')

print(num.quantize(Decimal('1.00'), ROUND_CEILING))
print(num.quantize(Decimal('1.00'), ROUND_FLOOR))

# Вывод:
# 3.46
# 3.45
```

