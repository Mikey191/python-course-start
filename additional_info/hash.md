# ХЭШ (`hash()`)

## Что такое `hash()`?

**Функция `hash()` в Python возвращает числовой хэш объекта**.

**`Хэш` — это уникальное целое число, которое вычисляется на основе содержимого объекта и используется для быстрой проверки равенства и работы с хэш-таблицами, например, в словарях или множествах**.

```python
# Пример использования hash()
print(hash("hello"))  # Хэш строки
print(hash(42))       # Хэш числа
print(hash((1, 2, 3))) # Хэш кортежа
```

## Хэшируемые и нехэшируемые объекты

1. **Хэшируемые объекты**:

   - **Неизменяемые типы данных, такие как `числа`, `строки`, `кортежи`** (с неизменяемыми элементами).
   - **Класс, экземпляры которого имеют `неизменяемые атрибуты`, могут быть хэшируемыми**.

2. **Нехэшируемые объекты**:

   - Изменяемые типы данных, такие как списки, множества и словари, поскольку их содержимое может изменяться, нарушая консистентность хэша.

## Создание хэшируемого класса

Чтобы экземпляры пользовательского класса были хэшируемыми:

- Определите метод `__hash__` для вычисления хэша.
- Убедитесь, что класс неизменяем:
  - Установите атрибуты только при инициализации (в методе `__init__`).
  - Используйте неизменяемые структуры данных, такие как строки, числа, кортежи.
- Переопределите метод `__eq__` для корректного сравнения объектов, поскольку хэш и равенство связаны.

Пример: Хэшируемый класс

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return False

    def __hash__(self):
        # Хэш от кортежа атрибутов
        return hash((self.x, self.y))

# Создание объектов
p1 = Point(1, 2)
p2 = Point(1, 2)
p3 = Point(3, 4)

# Сравнение объектов
print(p1 == p2)  # True
print(p1 == p3)  # False

# Использование объектов в множестве
points = {p1, p2, p3}
print(points)  # {<Point object>, <Point object>} (p1 и p2 считаются одинаковыми)
```

## Связь `__hash__` и `__eq__`

- **Если два объекта равны (по **eq**), их хэши должны быть одинаковыми**.
- **Если объекты не равны, их хэши могут быть одинаковыми, но это приводит к "коллизиям", которые обрабатываются хэш-таблицами**.

## Практическое применение `hash()`

- Словари и множества: Использование объектов пользовательского класса в качестве ключей словаря или элементов множества.

  ```python
  class Point:
      def __init__(self, x, y):
          self.x = x
          self.y = y

      def __eq__(self, other):
          if isinstance(other, Point):
              return self.x == other.x and self.y == other.y
          return False

      def __hash__(self):
          # Хэш от кортежа атрибутов
          return hash((self.x, self.y))


  # Создание объектов
  p1 = Point(1, 2)
  p2 = Point(1, 2)
  p3 = Point(3, 4)

  # Использование экземпляров класса Point в качестве ключей словаря
  distances = {p1: 5.0, p3: 10.5}
  print(distances[p1])  # 5.0
  ```

- Оптимизация поиска: Сравнение хэшей используется для ускорения проверки равенства.
- Кэширование и мемоизация: Использование хэша объекта для кэширования результатов функций.

## Важные замечания

- **Хэш неизменяемого объекта неизменяем**: **После создания объекта его хэш не должен меняться**. Если **класс позволяет изменять атрибуты, его экземпляры становятся непредсказуемыми в хэш-таблицах**.

- **Кортежи и хэшируемость**: Кортежи хэшируются, если все их элементы хэшируемы.
  ```python
  print(hash((1, "hello", 3.14)))  # Работает
  try:
      print(hash((1, [2, 3], 4)))  # Ошибка, список не хэшируем
  except TypeError as e:
      print(e)
  ```
- **Переопределение `__hash__` и `__eq__`**: Рекомендуется использовать **неизменяемые структуры данных** внутри метода `__hash__` для надёжности.

# Связь между методами `__eq__` и `__hash__`

## Основные правила

### Если два объекта равны (по `__eq__`), их хэши должны быть одинаковыми. Это важно для корректной работы хэш-таблиц:

- При добавлении ключа в словарь Python вычисляет хэш объекта.
- Если ключи имеют одинаковый хэш, Python дополнительно проверяет равенство объектов с помощью `__eq__`.

```python
class MyClass:
    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        return isinstance(other, MyClass) and self.value == other.value

    def __hash__(self):
        return hash(self.value)

obj1 = MyClass(10)
obj2 = MyClass(10)

print(obj1 == obj2)  # True (по __eq__)
print(hash(obj1) == hash(obj2))  # True (по __hash__)
```

### Если два объекта не равны, их хэши могут совпадать (но это не желательно). Такое совпадение называется коллизией, и Python может обработать её, проверяя объекты через `__eq__`.

## Что произойдёт, если правила нарушены?

### Не совпадают `__eq__` и `__hash__`: Если два объекта равны (по `__eq__`), но их хэши разные, поведение словаря или множества станет непредсказуемым.

**Пример ошибки**:

```python
class BrokenClass:
    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        return isinstance(other, BrokenClass) and self.value == other.value

    def __hash__(self):
        return self.value + 1  # Неправильная реализация
```

**Проблема**:

```python
obj1 = BrokenClass(10)
obj2 = BrokenClass(10)

print(obj1 == obj2)  # True
print(hash(obj1) == hash(obj2))  # False, нарушает правило

# Использование в словаре
my_dict = {obj1: "Value1"}
print(my_dict[obj2])  # KeyError, так как hash(obj1) != hash(obj2)
```

### Определён `__hash__`, но не `__eq__`: Если у класса есть `__hash__`, но `__eq__` не определён, то объекты будут сравниваться по умолчанию (по их идентификаторам в памяти), что может привести к неверному поведению.

## Типичный подход к реализации

Если вы создаёте пользовательский класс и хотите, чтобы его экземпляры использовались в хэш-таблицах, выполните следующие шаги:

- **Определите метод `__eq__`**. **Убедитесь, что метод корректно определяет равенство объектов**.
- **Определите метод `__hash__`**. **Постройте хэш на основе неизменяемых данных объекта, которые используются в `__eq__`**.

## Пример: Корректная реализация `__eq__` и `__hash__`

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        if isinstance(other, Person):
            return self.name == other.name and self.age == other.age
        return False

    def __hash__(self):
        # Хэш строится на основе тех же атрибутов, что используются в __eq__
        return hash((self.name, self.age))

# Создание объектов
person1 = Person("Alice", 30)
person2 = Person("Alice", 30)
person3 = Person("Bob", 25)

# Сравнение
print(person1 == person2)  # True
print(person1 == person3)  # False

# Использование в хэш-таблицах
people = {person1, person2, person3}
print(people)  # {<Person object>, <Person object>} (person1 и person2 считаются одинаковыми)
```

## Автоматическая генерация `__eq__` и `__hash__`

Python позволяет автоматически генерировать эти методы, используя dataclasses. Это упрощает реализацию неизменяемых классов.

```python
from dataclasses import dataclass

@dataclass(frozen=True)  # frozen=True делает объект неизменяемым
class Point:
    x: int
    y: int

# Автоматически создаются __eq__ и __hash__
p1 = Point(1, 2)
p2 = Point(1, 2)
p3 = Point(3, 4)

print(p1 == p2)  # True
print(hash(p1) == hash(p2))  # True
print({p1, p2, p3})  # {Point(x=1, y=2), Point(x=3, y=4)}
```

## Ключевые моменты

- Метод `__eq__` определяет равенство объектов.
- Метод `__hash__` обеспечивает согласованность с `__eq__`.
- Если `__eq__` переопределён, рекомендуется переопределить и `__hash__` (или использовать `dataclasses`).
- Нарушение связи между `__eq__` и `__hash__` приводит к ошибкам в работе словарей и множеств.

# Мемоизация

## Что такое Мемоизация?

**Мемоизация** (от англ. memoization, происходящего от слова "memorandum", что значит "памятка") — **это метод оптимизации, при котором результаты выполнения функций сохраняются в памяти, чтобы их не вычислять повторно при последующих вызовах с теми же входными данными**.

**Мемоизация применяется для повышения производительности программ, особенно в случаях, когда функция вызывается многократно с одинаковыми аргументами и имеет высокую вычислительную стоимость**.

## Как работает мемоизация?

- **Хранилище результатов**: **При первом вызове функции с определёнными аргументами результат вычисления сохраняется в специальной структуре данных, например, в словаре**. **Ключом в словаре являются аргументы функции, а значением — результат**.
- **Повторный вызов**: **Еслrdefётся из хранилища, вместо того чтобы вычислять его снова**.

## Преимущества мемоизации

- **Ускорение выполнения**: Повторное вычисление заменяется быстрым доступом к сохранённому результату.
- **Снижение вычислительной нагрузки**: Особенно полезно для рекурсивных функций, где одни и те же вычисления могут происходить многократно.
- **Уменьшение времени работы алгоритмов**: Например, алгоритмы динамического программирования, такие как вычисление чисел Фибоначчи, выигрывают от мемоизации.

## Пример: Без мемоизации vs с мемоизацией

### Пример без мемоизации: Вычисление чисел Фибоначчи

Функция чисел Фибоначчи без мемоизации будет вызывать саму себя многократно с одинаковыми аргументами, что приводит к экспоненциальному росту числа операций.

```python
def fib(n):
    if n <= 1:
        return n
    return fib(n - 1) + fib(n - 2)

# Вычисление 35-го числа Фибоначчи
print(fib(35))  # Долго выполняется
```

### Пример с мемоизацией: Оптимизация чисел Фибоначчи

Используем словарь для сохранения промежуточных результатов.

```python
def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]  # Возвращаем сохранённое значение
    if n <= 1:
        return n
    memo[n] = fib_memo(n - 1, memo) + fib_memo(n - 2, memo)
    return memo[n]

# Вычисление 35-го числа Фибоначчи
print(fib_memo(35))  # Выполняется быстро
```

## Встроенные инструменты для мемоизации в Python

Python предоставляет готовые средства для мемоизации, например, декоратор `functools.lru_cache`.

```python
from functools import lru_cache

@lru_cache(maxsize=None)  # Неограниченный кэш
def fib_cached(n):
    if n <= 1:
        return n
    return fib_cached(n - 1) + fib_cached(n - 2)

# Вычисление 35-го числа Фибоначчи
print(fib_cached(35))  # Выполняется быстро
```

- **maxsize**: Максимальное количество сохранённых результатов. Если установлен None, кэш будет неограниченным.
- **Автоматическое управление памятью**: При превышении maxsize старые записи удаляются.

## Применение мемоизации
- **Рекурсивные задачи**: Алгоритмы, такие как вычисление чисел Фибоначчи, факториала или нахождение кратчайшего пути.
- **Динамическое программирование**: Мемоизация позволяет преобразовать рекурсивные решения в более быстрые решения с использованием кэша.
- **Обработка данных**: Применяется для оптимизации функций, которые повторно анализируют одни и те же данные, например, парсеры или анализаторы текста.
- **Веб-приложения**: Кэширование результатов запросов к базам данных или API для ускорения ответов.

## Ограничения мемоизации
- **Использование памяти**: Для больших входных данных кэш может занимать значительное количество памяти.
- **Только для детерминированных функций**: Мемоизация работает только для функций, которые всегда возвращают один и тот же результат для одних и тех же входных данных.
- **Управление кэшем**: В некоторых случаях может потребоваться явное удаление кэша, если данные изменились.