# python-course

## Содержание:

- [Настройка Pycharm для Python](#настройка-pycharm-для-python)
- [Настройка VSCode для Python](#настройка-vscode-для-python)
- [Урок 1. Переменные, оператор присваивания. Типы данных](#урок-1-переменные-оператор-присваивания-типы-данных)
- [Урок 2. Числа. Операции над числами](#урок-2-числа-операции-над-числами)
- [Урок 3. Математические функции. Модуль math. Функции print() и input()](<#урок-3-математические-функции-модуль-math-функции-print()-и-input()>)
- [Урок 4. Логический тип Bool. Операторы сравнения](#урок-4-логический-тип-bool-операторы-сравнения)
- [Урок 5. Введение в строки. Операции над строками](#урок-5-введение-в-строки-операции-над-строками)
- [Урок 6. Индексы и срезы строк](#урок-6-индексы-и-срезы-строк)
- [Урок 7. Основные методы строк](#урок-7-основные-методы-строк)
- [Урок 8. Экранирование символов. Спецсимволы](#урок-8-экранирование-символов-спецсимволы)
- [Урок 9. Форматирование строк. F-строки. Сырые строки](#урок-9-форматирование-строк-f-строки-сырые-строки)
- [Урок 10. Списки. Операторы и функции работы со списками](#урок-10-списки-операторы-и-функции-работы-со-списками)
- [Урок 11. Срезы списков. Сравнение списков](#урок-11-срезы-списков-сравнение-списков)
- [Урок 12. Методы списков](#урок-12-методы-списков)
- [Урок 13. Вложенные списки. Многомерные списки](#урок-13-вложенные-списки-многомерные-списки)
- [Урок 14. Условный оператор if. Конструкция if-else](#урок-14-условный-оператор-if-конструкция-if-else)
- [Урок 15. Вложенные условия и множественный выбор. Конструкция if-elif-else](#урок-15-вложенные-условия-и-множественный-выбор-конструкция-if-elif-else)
- [Урок 16. Тернарный условный оператор](#урок-16-тернарный-условный-оператор)
- [Урок 17. Циклы в Python. Цикл While](#урок-17-циклы-в-python-цикл-while)
- [Урок 18. Цикл for](#урок-18-цикл-for)
- [Урок 19. Примеры задач решаемых с помощью цикла for](#урок-19-примеры-задач-решаемых-с-помощью-цикла-for)
- [Урок 20. Операторы циклов break, continue. Блок else для циклов for и while.](#урок-20-операторы-циклов-break-continue-блок-else-для-циклов-for-и-while)
- [Урок 21 Итератор и итерируемые объекты. Функции iter() и next()](#урок-21-итератор-и-итерируемые-объекты-функции-iter-и-next)
- [Урок 22 Вложенные циклы](#урок-22-вложенные-циклы)
- [Урок 23 Генераторы списков. Условия в генераторах списков. Вложенные генераторы списков](#урок-23-генераторы-списков-условия-в-генераторах-списков-вложенные-генераторы-списков)
- [Урок 24. Словари (dict). Методы словарей. Словари и циклы](#урок-24-словари-dict-методы-словарей-словари-и-циклы)
- [Урок 25. Кортежи (tuple). Методы кортежей](#урок-25-кортежи-tuple-методы-кортежей)
- [Урок 26. Множества (set). Методы множества](#урок-26-множества-set-методы-множества)
- [Урок 27. Генераторы множеств. Генераторы словарей](#урок-27-генераторы-множеств-генераторы-словарей)
- [Урок 28: Функции. Оператор return](#урок-28-функции-оператор-return)
- [Урок 29: Аргументы функции (позиционные и именованные аргументы, аргументы по умолчанию)](#урок-29-аргументы-функции-позиционные-и-именованные-аргументы-аргументы-по-умолчанию)
- [Урок 30: Обработка произвольного количества аргументов (\*args и \*\*kwargs)](#урок-30-обработка-произвольного-количества-аргументов-args-и-kwargs)
- [Урок 31: Лямбда-функции. Функции map(), filter(), sorted()](#урок-31-лямбда-функции-функции-map-filter-sorted)
- [Урок 32: Глобальные и локальные переменные. Импорт и работа с модулями в Python](#урок-32-глобальные-и-локальные-переменные-импорт-и-работа-с-модулями-в-python)

## Настройка Pycharm для Python.

### 1. Установка Python

- **Скачайте Python**: Перейдите на официальный сайт **Python** и скачайте последнюю версию для **Windows**.
- **Установите Python**: Запустите установочный файл. Обязательно отметьте галочку `"Add Python to PATH"` перед нажатием на кнопку `"Install Now"`. Это упростит доступ к **Python** из командной строки.
- **Проверьте установку**: Откройте командную строку `cmd` и введите команду:
  ```
  python --version
  ```

### 2. Установки PyCharm на Windows:

- Перейдите на **официальный сайт** PyCharm от JetBrains. Официальный сайт PyCharm от JetBrains: https://www.jetbrains.com/ru-ru/pycharm/download/?section=windows
- Скачайте последнюю версию **PyCharm Community Edition для Windows**.
- Запустите загруженный установщик **PyCharm**.
- Следуйте инструкциям на экране, чтобы завершить установку. Убедитесь, что вы выбрали **правильную версию PyCharm** (`Community Edition` или Professional) в соответствии с вашими потребностями.
- После завершения установки, запустите **PyCharm**.

### 3. Создания первого проекта в PyCharm:

- В меню выберите **"File"** (Файл) и затем **"New Project"** (Новый проект).
- В появившемся окне выберите **местоположение для вашего проекта** и **введите его название**.
- Нажмите кнопку **"Create"** (Создать) для создания проекта.

### 4. Запуск файла main.py

- **Первый способ**: Запуск через контекстное меню:
  - Откройте проект в **PyCharm** и найдите файл `main.py` в панели проекта.
  - Щелкните правой кнопкой мыши на файле и выберите пункт `Run 'main'`. Это запустит файл в терминале **PyCharm**.
- **Второй сопособ**: Использование кнопки запуска:
  - Откройте файл `main.py` в **PyCarm**.
  - В правом верхнем углу окна **PyCharm** вы увидите **зеленую кнопку запуска (треугольник)**. Нажмите на нее, чтобы запустить файл.
- **Третий способ**: Сочетания клавиш:
  - Вы можете использовать сочетание клавиш `Shift + F10`, чтобы запустить последний запущенный файл. Если main.py был последним, он запустится.

## Настройка VSCode для Python.

### 1. Установка Python

- **Скачайте Python**: Перейдите на официальный сайт **Python** и скачайте последнюю версию для **Windows**.
- **Установите Python**: Запустите установочный файл. Обязательно отметьте галочку `"Add Python to PATH"` перед нажатием на кнопку `"Install Now"`. Это упростит доступ к **Python** из командной строки.
- **Проверьте установку**: Откройте командную строку `cmd` и введите команду:
  ```
  python --version
  ```

### 2. Установка Visual Studio Code

- **Скачайте VSCode**: Перейдите на официальный сайт **VSCode** и скачайте установочный файл для **Windows**.
- **Установите VSCode**: Запустите установочный файл и следуйте инструкциям на экране.

### 3. Установка расширения Python для VSCode

- **Запустите VSCode**.
- **Откройте Marketplace**: Нажмите на иконку расширений (или используйте сочетание клавиш `Ctrl+Shift+X`).
- **Найдите расширение Python**: Введите `"Python"` в строке поиска и установите **расширение от Microsoft**.

### 4. Установка интерпритатора

- **Откройте командную палитру**: Нажмите сочетание клавиш `Ctrl + Shift + P`. Это откроет командную палитру.
- **Выберите интерпретатор**: Введите в командной палитре `Python: Select Interpreter` и выберите эту команду из списка. После этого появится **список доступных интерпретаторов Python**, установленных на вашем компьютере. **Выберите нужный интерпретатор**, который вы хотите использовать для вашего проекта.

### 5. Запуск файла main.py

- **Первый способ**. Использование сочетания клавиш:
  - Нажмите `F5`, чтобы запустить файл с отладкой. Это откроет отладчик и выполнит ваш код.
  - Нажмите `Ctrl + F5`, чтобы запустить файл без отладки. Это выполнит ваш код в терминале.
- **Второй способ**. Запуск через терминал:
  - Откройте встроенный терминал в **VSCode**, нажав Ctrl + \` (обратная кавычка).
  - Введите команду `python main.py` и нажмите `Enter`. Убедитесь, что у вас установлен **Python** и он добавлен в переменную окружения **PATH**.
- **Третий способ**. Использование команды в меню:
  - Вы можете также запустить файл, выбрав в верхнем меню `Run (Запуск)` → `Run Without Debugging (Запустить без отладки)` или `Start Debugging (Начать отладку)`.

### 6. Создание виртуального окружения

- **Создайте виртуальное окружение**: Откройте терминал в **VSCode**. Введите следующую команду: `python -m venv venv`. Это создаст папку `venv` в вашем проекте, где будет находиться виртуальное окружение.
- **Активируйте виртуальное окружение**: В терминале введите следующую команду: `venv\Scripts\activate` . Вы должны увидеть, что имя окружения (например, venv) появилось перед командной строкой.

### 7. Python Console

- **Откройте терминал**: Вы можете **открыть встроенный терминал в VSCode**, нажав Ctrl + \` (обратная кавычка) или выбрав `"Terminal"` в верхнем меню и затем `"New Terminal"`.
- **Запустите Python Console**: В терминале введите `python` или `python3` (в зависимости от вашей установки) и нажмите `Enter`. Это запустит интерактивную консоль Python.

## \*Что такое виртуальное окружение?

**Виртуальное окружение в Python** — это **изолированная среда**, которая позволяет **устанавливать и управлять зависимостями для конкретного проекта**, не влияя на глобальные настройки системы. Это особенно полезно, когда у вас есть несколько проектов, требующих разных версий библиотек или самого Python.

### Основные характеристики виртуального окружения:

- **Изоляция зависимостей**: Каждое виртуальное окружение имеет свои **собственные библиотеки и зависимости**, что предотвращает конфликты между проектами. Например, если один проект требует библиотеку **версии 1.0**, а другой — **версии 2.0**, вы можете создать два отдельных окружения для каждого проекта.
- **Управление версиями Python**: Виртуальные окружения позволяют **использовать разные версии Python** для разных проектов. Это особенно важно, если ваш код зависит от специфических функций или изменений в разных версиях Python.
- **Удобство разработки**: Создание виртуального окружения **упрощает процесс установки и удаления зависимостей**, так как все изменения происходят в рамках этого окружения.

## Урок 1. Переменные, оператор присваивания. Типы данных

### 1.1 Переменные.

**Переменная** - это имя, которое используется для хранения значения. Она представляет собой **ссылку на объект в памяти компьютера**. Переменные в Python могут содержать различные типы данных.

**Имена переменных** могут состоять из **букв (как строчных, так и заглавных)**, **цифр** и **символа подчеркивания**.  
**Имя переменной не может начинаться с цифры**.

Python является **регистрозависимым языком**, поэтому переменные **myVar**, **myvar** и **MYVAR** будут **считаться разными переменными**.

**Пример создания переменной**:

```python
a = 7
```

- `a` - это **имя переменной**.
- `=` - это **оператор присваивания**. Он позволяет присвоить переменной определенное значение или ссылку на объект.
- `7` - это объект на который ссылается **а**.

### 1.2 Оператор присваивания

**Оператор присваивания** в Python — это символ `=`, который используется для **присвоения значения переменной**. Он позволяет **сохранить данные в переменной**, чтобы затем можно было использовать это значение в программе.

Когда вы используете оператор присваивания, вы **указываете переменную слева** от знака `=` и **значение или выражение справа**.

**Оператор присваивания необходим для**:

1. `Сохранения данных`: Вы можете сохранять значения, которые будете использовать позже в коде.
   ```python
   x = 5
   ```
2. `Изменения значений`: Вы можете изменять значения переменных в процессе выполнения программы.
   ```python
   x = 5
   x = x + 2  # Теперь x будет равно 7
   ```
3. `Работы с выражениями`: Вы можете присваивать результат вычислений переменным.
   ```python
   a = 3
   b = 4
   c = a + b  # c теперь равно 7
   ```

### 1.3 Переменные в Python являются ссылками на объекты.

В языке **Python** переменные **не хранят сами объекты**, а лишь **ссылаются** на них с определенными значениями. Это означает, что **одной переменной можно присваивать объекты разных типов данных**. Например, вы можете создать переменную `x` и присвоить ей значение числа, а затем изменить ее значение, присвоив ей строку или другой объект.

В Python переменные являются **ссылками на объекты**, и их значения могут изменяться в процессе выполнения программы.

**Например**:

```python
x = 10
print(x)  # Вывод: 10

x = "Hello, world!"
print(x)  # Вывод: Hello, world!

x = [1, 2, 3]
print(x)  # Вывод: [1, 2, 3]
```

### 1.4 Функция id()

Каждый объект в Python имеет свой **уникальный идентификатор**, который можно получить с помощью функции **id()**. Идентификатор представляет собой **целое число, которое гарантированно уникально для каждого объекта во время его существования**.

**Например**:

```python
a = 2
b = a
c = b

print(id(a)) # Вывод: 140719720362824
print(id(b)) # Вывод: 140719720362824
print(id(c)) # Вывод: 140719720362824
```

**Идентификаторы** у всех трех переменных будут **одинаковы**. Это говорит о том, что эти **три переменные** ссылаються на **один объект**.

### 1.5 Функция type()

Функция **type()** в языке Python используется для получения **типа объекта**. Она возвращает информацию о **типе данных**, к которому принадлежит **объект**.

**Например**:

```python
x = 5
print(type(x))  # Вывод: <class 'int'>

y = "Hello"
print(type(y))  # Вывод: <class 'str'>

z = True
print(type(z))  # Вывод: <class 'bool'>
```

### 1.6 Типы данных в Python

**Типы данных** в языках программирования — это категории, которые определяют, какие **значения могут храниться в переменных** и **какие операции могут быть выполнены с этими значениями**. В Python существует несколько основных типов данных, с которыми вы будете работать на начальном этапе изучения языка:

1. `Целые числа (int)`: Этот тип данных используется для хранения **целых чисел**, как положительных, так и отрицательных. `Например, 5, -3, 42`.
2. `Числа с плавающей запятой (float)`: Этот тип данных предназначен для хранения **чисел с дробной частью**. `Например, 3.14, -0.001, 2.0`.
3. `Строки (str)`: Строки представляют собой последовательности символов и используются для хранения текстовой информации. Строки заключаются в одинарные или двойные кавычки. `Например, "Привет", 'Python'`.
4. `Логический тип (bool)`: Этот тип данных может принимать только два значения: `True (истина)` и `False (ложь)`. Он часто используется для выполнения условий и логических операций.

**Примеры использования типов данных**:

```python
# Пример целого числа
age = 25  # int

# Пример числа с плавающей запятой
height = 1.75  # float

# Пример строки
name = "Алексей"  # str

# Пример логического типа
is_student = True  # bool
```

### 1.7 Типизация

**Типизация** - это концепция, связанная с определением **типов данных в программировании**. Она определяет, **какие типы данных могут быть использованы в языке программирования** и **как эти типы взаимодействуют друг с другом**.

В языках программирования **типизация** может быть **динамической** или **статической**.

- **Динамическая типизация** означает, что **тип** переменной определяется **автоматически** на основе значения, которое ей присваивается.
- **Статическая типизация**, напротив, требует **явного объявления типов переменных** и **проверки их соответствия во время компиляции**.

В Python используется **динамическая типизация**, что означает, что **тип переменной определяется автоматически** на основе значения, которое ей присваивается. В отличие от языков с явной типизацией, в Python вам не нужно объявлять тип переменной явно.

### Вопросы:

1. Что такое переменная в Python?
2. Какие правила существуют для именования переменных в Python?
3. Что делает оператор присваивания?
4. Что делает функция id()?
5. Что делает функция type()?
6. Можно ли функции id присвоить число 7 (id = 7)?
7. Какие основные типы данных существуют в Python?
8. Что такое типизация в Python и как она влияет на работу с переменными и данными?

## Урок 2. Числа. Операции над числами

### 2.1 Числовые типы данных

В **Python** существуют **различные типы чисел**.  
Вот некоторые из них:

- **Целые числа (int)**: представляют целочисленные значения, например, 0, -1, 100 и т.д.
- **Вещественные числа (float)**: представляют числа с плавающей точкой, такие как 0.5, -3.14, 2.71828 и т.д.
- **Комплексные числа (complex)**: представляются в виде **x + yj**, где **x** и **y** - это **вещественные числа**, а **j** - мнимая единица. Например, **3 + 2j**, **-1.5 + 0.5j** и т.д.

**Например**:

```python
x = 10  # Целое число
y = 3.14  # Вещественное число
z = 2 + 3j  # Комплексное число

print(type(x))  # <class 'int'>
print(type(y))  # <class 'float'>
print(type(z))  # <class 'complex'>
```

### 2.2 Операции над типами данных

1. **Сложение (`+`)**: оператор сложения используется для сложения двух чисел. **Например**:

   ```python
   x = 5 + 3
   print(x)  # Выводит: 8

   y = 2
   z = 5
   res = y + z
   print(res) # Выводит: 7
   ```

2. **Вычитание (`-`)**: оператор вычитания используется для вычитания одного числа из другого. **Например**:

   ```python
   y = 10 - 4
   print(y)  # Выводит: 6

   y = 2
   z = 5
   res = y - z
   print(res) # Выводит -3
   ```

3. **Умножение (`*`)**: оператор умножения используется для умножения двух чисел. **Например**:

   ```python
   z = 2 * 6
   print(z)  # Выводит: 12

   y = 2
   z = 5
   res = y * z
   print(res) # Выводит 10
   ```

4. **Деление (`/`)**: оператор деления используется для деления одного числа на другое. В результате получается число с плавающей точкой (`float`). **Например**:

   ```python
   a = 10 / 3
   print(a)  # Выводит: 3.3333333333333335

   y = 2
   z = 5
   res = y / z
   print(res) # Выводит 0.4
   ```

5. **Целочисленное деление (`//`)**: оператор целочисленного деления возвращает целую часть от деления одного числа на другое. **Например**:

   ```python
   x = 10 // 3
   print(x)  # Выводит: 3

   y = 2
   z = 5
   res = y // z
   print(res) # Выводит 0
   ```

6. **Остаток от деления (`%`)**: оператор остатка от деления возвращает остаток от деления одного числа на другое. **Например**:

   ```python
   y = 10 % 3
   print(y)  # Выводит: 1

   y = 2
   z = 5
   res = y % z
   print(res) # Выводит 2
   ```

7. **Возведение в степень (`**`)**: оператор возведения в степень используется для возведения числа в определенную степень. **Например\*\*:

   ```python
   z = 2 ** 3
   print(z)  # Выводит: 8

   y = 2
   z = 5
   res = y ** z
   print(res) # Выводит 32
   ```

### 2.3 Сокращенная запись операторов

**Сокращенная запись оператора** - это специальный синтаксис, который позволяет выполнять операцию и присваивание значения переменной в одной строке кода.

```python
x = 5
x += 3
print(x)  # Выводит: 8
```

Сокращенную запись оператора можно использовать с любым из семи перечисленных выше операторов.

### Вопросы:

1. К какому типу данных относится int?
2. К какому типу данных относится float?
3. Как называется оператор `+`?
4. Как называется оператор `-`?
5. Как называется оператор `*`?
6. Как называется оператор `/`?
7. Как называется оператор `//`?
8. Как называется оператор `%`?
9. Как называется оператор `**`?
10. Что выведит строка `print(7.0 + 2)`?
11. Что выведит строка `print(2 ** 4)`?
12. Что выведит строка `print(32 / 2 ** 4)`?
13. Что выведит строка `print(11 % 3)`?
14. Что выведит строка `print(21 // 4)`?
15. Какой тип данных мы увидим, выполнив строчку `print(type(8/2))`?
16. Чему будет равно `k`?
    ```python
    k = 8
    k *= 2
    print(k)
    ```
17. Чему будет равно `i`?
    ```python
    i = 2
    i += 3
    print(i)
    ```

## Урок 3. Математические функции. Модуль math. Функции print() и input()

### 3.1 Встроенные математические функции

В языке Python есть множество **встроенных математических функций**, которые могут быть использованы для выполнения различных вычислений:

1. **`abs(x)`**: возвращает абсолютное значение числа **x**.
   ```python
   x = abs(-5)
   print(x)  # Выводит: 5
   ```
2. **`round(x)`**: округляет число x до **ближайшего целого значения**. Функция может принимать **вторым параметром** количество знаков после запятой, до которого нужно округлить число. Если **вторым параметром** равен отрицательному числу, функция округляет число до ближайшего десятка, сотни и т.д.

   ```python
   # Округление до ближайшего целого:
   x = round(3.7)
   print(x)  # Выводит: 4

   # Округление до заданного количества знаков после запятой:
   x = round(2.675, 2)
   print(x) # 2.67

   # Округляет число до ближайшего десятка:
   x = round(1234, -2)
   print(x) # 1200
   ```

3. **`max(x1, x2, ...)`**: возвращает **наибольшее значение** из переданных аргументов.
   ```python
   x = max(5, 3, 8)
   print(x)  # Выводит: 8
   ```
4. **`min(x1, x2, ...)`**: возвращает **наименьшее значение** из переданных аргументов.
   ```python
   x = min(5, 3, 8)
   print(x)  # Выводит: 3
   ```
5. **`pow(x, y)`**: возвращает значение **x в степени y**.
   ```python
   x = pow(2, 3)
   print(x)  # Выводит: 8
   ```
6. **`sum(iterable)`**: возвращает **сумму всех элементов** в итерируемом объекте.
   ```python
   x = sum([1, 2, 3, 4, 5])
   print(x)  # Выводит: 15
   ```

### 3.2 Молуль math

**Модуль math** в Python предоставляет **функции для выполнения математических операций**.

Чтобы импортировать модуль `math`, вы можете использовать следующую конструкцию:

```python
import math
```

После импорта модуля `math` вы можете **использовать его функции** для выполнения различных математических операций.

**Математические операции модуля `math`**:

1. **`math.sqrt(x)`**: возвращает **квадратный корень** числа x.

   ```python
   import math

   x = math.sqrt(16)
   print(x)  # Выводит: 4.0
   ```

2. **`math.pow(x, y)`**: возвращает **значение x в степени y**.

   ```python
   import math

   x = math.pow(2, 3)
   print(x)  # Выводит: 8.0
   ```

3. **`math.ceil(x)`**: **округляет число** x вверх **до ближайшего целого значения**.

   ```python
   import math

   x = math.ceil(3.2)
   print(x)  # Выводит: 4
   ```

4. **`math.floor(x)`**: **округляет число** x **вниз до ближайшего целого значения**.

   ```python
   import math

   x = math.floor(3.8)
   print(x)  # Выводит: 3
   ```

5. **`math.radians(x)`**: **преобразует угол из градусов в радианы**.

   ```python
   import math

   x = math.radians(90)
   print(x)  # Выводит: 1.5707963267948966
   ```

6. **`math.sin(x)`**, **`math.cos(x)`**, **`math.tan(x)`**: возвращают синус, косинус и тангенс угла x (в радианах).

   ```python
   import math

   x = math.sin(math.radians(90))
   print(x)  # Выводит: 1.0
   ```

7. `math.log(x, base)`: возвращает **логарифм числа x по указанному основанию base**.

   ```python
   import math

   x = math.log(10, 2)
   print(x)  # Выводит: 3.3219280948873626
   ```

8. `math.log10(x)`: **возвращает десятичный логарифм числа x**.

   ```python
   import math

   x = math.log10(100)
   print(x)  # Выводит: 2.0
   ```

9. `math.factorial(x)`: возвращает факториал числа x.

   ```python
   import math

   x = math.factorial(5)
   print(x)  # Выводит: 120
   ```

### 3.3 Функция `print()`

- **Функция `print()`** используется для **вывода текста или значений переменных на экран**.
- Она может **принимать один или несколько аргументов**, разделенных запятыми.
- Аргументы могут быть **строками, числами или другими объектами**, которые могут быть преобразованы в строку.
- Функция `print()` **автоматически добавляет символ новой строки (`\n`)** в конце вывода, но это поведение можно изменить с помощью аргументов **end** и **sep**.

**Примеры использования**:

```python
x = 17
print("Привет, мир!")  # Выводит строку "Привет, мир!"
print(42)  # Выводит число 42
print("Значение переменной x:", x)  # Выводит значение переменной x
```

### 3.4 Функция `input()`

- **Функция `input()`** используется для **получения ввода от пользователя**.
- Она может принимать **необязательный аргумент** - **строку**, которая будет отображаться перед ожиданием ввода.
- Функция `input()` возвращает введенное пользователем значение в виде строки.

**Пример использования**:

```python
# Пользователь вводит свое имя:
name = input("Введите ваше имя: ")
# Выводит приветствие с именем пользователя
print("Привет, " + name + "!")

# Пользователь вводит свой возраст:
age = int(input("Введите ваш возраст"))
# Выводим возраст пользователя на экран
print("Ваш возраст:", age)
```

### Вопросы:

1. Что делает функция `abs()` в Python?
2. Какова разница между функциями `ceil()` и `floor()` из модуля math?
3. Что возвращает функция `sqrt()` из модуля math?
4. Каковы основные параметры функции `print()`? Как можно изменить разделитель между элементами при выводе?
5. Что делает функция `input()` и как её можно использовать для получения данных от пользователя? Приведите пример.
6. Как можно использовать функцию `sum()` для суммирования элементов?

### Задание:

1. Допишите текст программы. Выведите в консоль все переменные в одну строчку с помощью одной функции `print()`.

   ```python
   x = 2
   y = 5
   z = 12
   # продолжите программу
   ```

2. Допишите текст программы. Выведите в консоль все переменные в три строчки с помощью одной функции `print()`.

   ```python
   x = 2
   y = 5
   z = 12
   # продолжите программу
   ```

3. Допишите текст программы. Выведите в консоль все переменные через пробел используя две функции `print()`.

   ```python
   x = "Привет,"
   y = "Мир"
   # продолжите программу
   ```

4. Создать три переменные в которые по очереди будут присваиваться разные слова используя функцию `input()`. Вывести эти слова через запятую используя один `print()`.

5. Допишите текст программы. Выведите в консоль модуль значения переменной `d` в консоль.

   ```python
   d = int(input())
   # продолжите программу
   ```

6. Допишите текст программы. Выведите в консоль минимальное значение из созданных переменых.

   ```python
   a = 1
   b = 3
   c = 45
   d = 12
   e = 0
   # продолжите программу
   ```

7. Допишите текст программы. Выведите в консоль максимальное значение из созданных переменых.

   ```python
   a = 1
   b = 3
   c = 45
   d = 12
   e = 0
   # продолжите программу
   ```

8. Выведите в консоль значение гипотенузы треугольника, если катеты `a = 3`, `b = 4`.  
   Формула гипотенузы: `a**2 + b**2 = c**2`.

9. Напишите программу, которая запрашивает у пользователя **два числа** и выводит результат возведения первого числа в степень второго.

10. В лагерь нужно отвезти `40 детей` и `5 вожатых` с помощью автобусов. Максимальная вместимость автобуса `20 человек`. Напишите программу для вычисления минимального числа автобусов. Результат (целое число) выведите в консоль.

11. Геливая ручка стоит `20 рублей`. Магазин предоставляет скидку в `10%` на каждую купленную ручку. Какое количесвто ручек можно будет купить на `500 рублей`. Результат (целое число) выведите в консоль.

12. Напишите программу, которая запрашивает у пользователя координаты точек в двумерном пространстве: `x1`, `y1`, `x2`, `y2` и вычисляет расстояние между ними, используя формулу расстояния.

## Урок 4. Логический тип Bool. Операторы сравнения

### 4.1 Логический тип

**Логический тип bool** в языке программирования Python используется для представления **логических значений** и имеет два возможных значения: `True (истина)` и `False (ложь)`.

### 4.2 Операторы сравнения

**Операторы сравнения** позволяют **сравнивать значения** и **возвращать логический результат**:

- `==` - равно.
- `!=` - не равно.
- `>` - больше.
- `<` - меньше.
- `>=` - больше или равно.
- `<=` - меньше или равно.

**Результатом** оператора сравнения является логическое значение `True` или `False`.

```python
a = int(input())
b = int(input())
print(a == b)
print(a > b)
print(a <= b)
```

### 4.3 Преобразование в логический тип

- В Python можно преобразовать **другие типы данных** в **логический тип с помощью функции `bool()`**.
- Значения, которые преобразуются в `False`, включают **`пустые строки`, `числа равные нулю`, `пустые контейнеры` (списки, кортежи, словари) и значение `None`**.

  ```python
  a = None
  b = ""
  d = 0

  print(bool(a)) # False
  print(bool(b)) # False
  print(bool(d)) # False
  ```

- Все остальные значения преобразуются в `True`.

  ```python
  a = "Строка"
  c = 1

  print(bool(a)) # True
  print(bool(c)) # True
  ```

### 4.4 Преобразования типов данных

- **Преобразование в целый тип данных**: Для преобразования в целый тип данных используется функция `int()`.

  ```python
  # преобразование строки в целый тип данных:
  num_str = "42"  # строка, содержащая число
  num_int = int(num_str)  # преобразование в целое число
  print(num_int)  # вывод: 42

  # преобразование дробного числа в целый тип данных:
  float_num = 3.99  # дробное число
  int_num = int(float_num)  # преобразование в целое число
  print(int_num)  # вывод: 3

  # преобразование булевого значения в целый тип данных:
  bool_value = True  # булевое значение
  int_value = int(bool_value)  # преобразование в целое число
  print(int_value)  # вывод: 1

  # преобразование входящей строки:
  user_input = input("Введите целое число: ")  # пользователь вводит число
  user_number = int(user_input)  # преобразование в целое число
  print(f"Вы ввели число: {user_number}")  # преобразованное целое число

  # преобразование не возможно:
  num_str = "abc"  # строка, не содержащая числа
  num_int = int(num_str)  # попытка преобразования в целое число
  print(num_int)  # Это вызовет ошибку ValueError
  ```

- **Преобразование в дробный тип данных**: Для преобразования в дробный тип данных используется функция `float()`.

  ```python
  # преобразование строки в дробный тип данных:
  float_str = "3.14"  # строка, содержащая дробное число
  float_num = float(float_str)  # преобразование в дробное число
  print(float_num)  # вывод: 3.14

  # преобразование целого числа в дробный тип данных:
  int_num = 5  # целое число
  float_num = float(int_num)  # преобразование в дробное число
  print(float_num)  # вывод: 5.0

  # преобразование булевого значения в дробный тип данных:
  bool_value = False  # булевое значение
  float_value = float(bool_value)  # преобразование в дробное число
  print(float_value)  # вывод: 0.0

  # преобразование входящей строки
  user_input = input("Введите дробное число: ")  # пользователь вводит дробное число
  user_float = float(user_input)  # преобразование в дробное число
  print(f"Вы ввели дробное число: {user_float}")  # преобразованное дробное число

  # преобразование не возможно
  float_str = "3.14abc"  # строка, не являющаяся корректным дробным числом
  float_num = float(float_str)  # попытка преобразования в дробное число
  print(float_num)  # Это вызовет ошибку ValueError
  ```

- **Преобразование в строчный тип данных**: Для преобразования в строчный тип данных используется функция `str()`.

  ```python
  # преобразование целого числа в строчный тип данных:
  int_num = 42  # целое число
  str_num = str(int_num)  # преобразование в строку
  print(str_num)  # вывод: "42"

  # преобразования дробного числа в строчный тип данных:
  float_num = 2.718  # дробное число
  str_float = str(float_num)  # преобразование в строку
  print(str_float)  # вывод: "2.718"

  # преобразования булевого значения в строчный тип данных:
  bool_value = True  # булевое значение
  str_bool = str(bool_value)  # преобразование в строку
  print(str_bool)  # вывод: "True"
  ```

### 4.5 Операторы `and` `or` `not`

Операторы `and`, `or` и `not` используются для **выполнения логических операций** и **манипуляций с логическими значениями**.

- Оператор `and` выполняет **логическое "и"** между двумя операндами. Он возвращает **`True`, если оба операнда являются истинными**, и **`False` в противном случае**.
- Оператор `or` выполняет **логическое "или"** между двумя операндами. Он возвращает **`True`, если хотя бы один из операндов является истинным**, и **`False` в противном случае**.
- Оператор `not` выполняет **логическое отрицание операнда**. Он возвращает **`True`, если операнд является ложным**, и **`False`, если операнд является истинным**.

**Пример**:

```python
x = 5
y = 10

print(x > 0 and y > 20)  # Выводит False
print(x > 0 or y > 20)  # Выводит True
print(not x > 0)  # Выводит False
```

### 4.6 Приоритет операторов

**Приоритет операторов** определяет порядок выполнения операций в выражениях.

#### Таблица приоритетов операторов:

1. `**` - оператор возведения в степень имеет самый высокий приоритет.
2. `*`, `/`, `//`, `%` - операторы умножения, деления, целочисленного деления и остатка от деления имеют одинаковый приоритет и выполняются слева направо.
3. `+`, `-` - операторы сложения и вычитания также имеют одинаковый приоритет и выполняются слева направо.
4. `<`, `>`, `<=`, `>=` - операторы сравнения имеют одинаковый приоритет и выполняются слева направо.
5. `==`, `!=` - операторы равенства и неравенства имеют одинаковый приоритет и выполняются слева направо.
6. `not` - оператор логического отрицания выполняется перед операндом.
7. `and` - оператор логического И выполняется слева направо.
8. `or` - оператор логического ИЛИ выполняется слева направо.

### Вопросы:

1. Что такое логический тип и какие значения он может принимать?
2. Каковы основные операторы сравнения? Приведите примеры их использования.
3. Как происходит преобразование других типов данных в логический тип с помощью функции `bool()`?
4. Что делает оператор `and` и как он работает?
5. Как работает оператор `or`?
6. Что делает оператор `not` и как он изменяет логическое значение?
7. Каков приоритет операторов `and`, `or` и `not` в Python?
8. Как можно использовать логические операторы для проверки нескольких условий одновременно?

### Задание:

1. Напишите программу, которая запрашивает у пользователя два числа и выводит `True`, если первое число больше второго или `False` в противном случае.

2. Создайте программу, которая принимает на вход строку и проверяет, является ли она пустой. Выведите `True`, если строка пустая, и `False` в противном случае.

3. Напишите программу, которая запрашивает у пользователя логическое значение (`True` или `False`) и выводит его отрицание.

4. Напишите программу, которая принимает три целых числа от пользователя и выводит, является ли хотя бы одно из них положительным.

5. Создайте программу, которая запрашивает у пользователя число и определяет, является ли оно четным или нечетным. (Используйте оператор `%` в сочетании с логическим оператором `==`).

6. Допишите текст программы. `a` - это вещественное число (с плавающей точкой). Программа должна выводит `True`, если целая часть числа `a` **кратна трём**, и `False` если не кратна.

   ```python
   a = float(input("Введите число: "))
   # продолжите программу
   ```

7. Допишите текст программы. `x` - это стоимость книги. Определите является ли дробное значение (число после запятой) больше 50. В консоль вывести `True` если больше и `False` если нет.

   ```python
   x = float(input("Введите стоимость книги: "))
   # продолжите программу
   ```

8. Допишите текст программы. `a`, `b`, `c` - предполагаемые **длины сторон треугольника**. Определите, действительно ли треугольник с такими сторонами может существовать (**Сумма длин двух произвольных сторон всегда должна быть больше третьей стороны**)? В консоль вывести `True`, если треугольник формируется и `False` - в противном случае.
   ```python
   a = int(input("Введите первую сторону треугольника: "))
   b = int(input("Введите вторую сторону треугольника: "))
   c = int(input("Введите третью сторону треугольника: "))
   # продолжите программу
   ```

## Урок 5. Введение в строки. Операции над строками

### 5.1 Строка

**Строка** представляет собой **последовательность символов, заключенных в одинарные `'` или двойные `"` кавычки**.

**Строки** могут содержать **любые символы, включая буквы, цифры, специальные символы и пробелы**.

**Строки** используются для **хранения и манипуляции текстовой информацией в программе**.

```python
s1 = 'Привет, мир!'
s2 = "Hello, world!"
```

### 5.2 Многострочные строки

**Многострочные строки** задаются с помощью тройных одинарных `'''` или тройных двойных `"""` кавычек.

**Например**:

```python
s3 = '''
Это строка 1.
Это строка 2.
'''
print(s3)
```

Если мы попробуем **отобразить эту строку в консоли Python**, то увидим, что наши строки разделены специальным символом:

```
'\nЭто строка 1.\nЭто строка 2.\n'
```

### 5.3 Символ новой строки \n

Символ строки `\n` представляет собой **управляющую последовательность, которая обозначает перенос на новую строку**. При выводе строки, если встречается символ `\n`, текст переносится на новую строку.

**Например**:

```python
s4 = "Это строка 1.\nЭто строка 2."
print(s4)
```

**Строка** так же может вообще не содержать символов - это будет **пустая строка**.

```python
s = ""
print(s)
```

### 5.4 Базовые операции над строками

**Базовые операции** над строками включают `конкатенацию (объединение)` строк с помощью оператора `+` и `повторение строки` с помощью оператора `*`.

- **Оператор `+`** используется для конкатенации (соединения) строк. Он позволяет объединить две строки в одну.  
  **Например**:
  ```python
  s5 = "Привет, " + "мир!"
  print(s5)  # Выводит "Привет, мир!"
  ```
- **Оператор `*`** используется для дублирования строкового фрагмента. Он позволяет **повторить строку несколько раз**.  
  **Например**:
  ```python
  s6 = "spam" * 3
  print(s6)  # Выводит "spamspamspam"
  ```

### 5.5 Преобразование в строку

**Функция** `str()` используется для **преобразования аргумента в строковое представление**.

Она принимает аргумент **любого типа данных** и **возвращает его строковое представление**.  
**Например**:

```python
num = 42
s7 = "The answer is: " + str(num)
print(s7)  # Выводит "The answer is: 42"
```

### 5.6 Вычисление длины строки

**Функция** `len()` используется для **вычисления длины строки**.

Она принимает **строку в качестве аргумента** и **возвращает количество символов в строке**.  
**Например**:

```python
s8 = "Hello, world!"
length = len(s8)
print(length)  # Выводит 13
```

### 5.7 Оператор in для проверки вхождения подстроки в строку

**Оператор** `in` используется для **проверки вхождения подстроки в строку**.

**Оператор** `in` возвращает логическое значение `True`, если **подстрока присутствует в строке**, и `False` в **противном случае**.  
**Например**:

```python
s9 = "Hello, world!"
print("world" in s9)  # Выводит True
print("foo" in s9)  # Выводит False
```

### 5.8 Сравнение строк

Операторы сравнения `==`, `!=`, `>`, `<`, `>=`, `<=` используются для **сравнения строк**. Они сравнивают строки **лексикографически (по алфавиту)** и возвращают логическое значение `True` или `False`.

При **лексикографическом сравнении строк** происходит сравнение символов в строках **по их порядку в таблице символов**. Сравнение начинается с первого символа каждой строки и продолжается до тех пор, пока не будет найдено отличие или одна из строк не закончится.

**Алгоритм сравнения**:

- Сравниваются **первые символы обеих строк**. Если они различаются, то строка с меньшим символом считается **"меньшей"** в лексикографическом порядке. Например: строка `"apple"` будет меньше строки `"banana"`, потому что символ `"a"` имеет меньший код `ASCII`, чем символ `"b"`.
- Если **первые символы совпадают, то сравниваются следующие символы в обеих строках**. Процесс продолжается до тех пор, пока не будет найдено отличие или одна из строк не закончится.
- Если **одна строка заканчивается, а другая продолжает иметь символы, то строка, которая закончилась, считается `"меньшей"`** в лексикографическом порядке. Например: строка `"apple"` будет меньше строки `"applesauce"`.
- Если **обе строки заканчиваются одновременно и не было найдено отличий, то строки считаются равными**.

**Например**:

```python
str1 = "apple"
str2 = "banana"
print(str1 < str2)  # Выводит True

str3 = "apple"
str4 = "applesauce"
print(str3 < str4)  # Выводит True

str5 = "apple"
str6 = "apple"
print(str5 == str6)  # Выводит True
```

### 5.9 Таблица символов

**Таблица символов** в Python основана на стандарте `Unicode`, который определяет уникальный числовой код для каждого символа. Коды символов в таблице `Unicode` могут быть представлены в различных кодировках, таких как `ASCII`.

### 5.10 Функция ord()

В Python для определения кода `ASCII` символа используется функция `ord()`. Она принимает символ в качестве аргумента и возвращает его числовое значение в кодировке `ASCII`.

**Например**:

```python
char = 'A'
ascii_code = ord(char)
print(ascii_code)  # Выводит 65
```

### 5.11 Функция chr()

Функция `chr()` в Python используется для **получения символа, соответствующего заданному целочисленному значению в таблице символов `Unicode`**. Она принимает одно **целое число в качестве аргумента** и в**озвращает строку, содержащую символ, соответствующий этому числу.**

**Например**:

```python
# Получаем символ, соответствующий коду 97
symbol_a = chr(97)
print(symbol_a)  # Вывод: a

# Получаем символ, соответствующий коду 8364 (евро)
symbol_euro = chr(8364)
print(symbol_euro)  # Вывод: €
```

### Вопросы:

1. Что такое строка в Python и как она создается?
2. Как можно создать многострочную строку в Python?
3. Что делает символ новой строки `\n` в строках? Как его можно использовать?
4. Каковы базовые операции над строками?
5. Как преобразовать число в строку?
6. Как вычислить длину строки?
7. Как проверить вхождение подстроки в строку?
8. Как происходит сравнение строк в Python?
9. Как определить код `ASCII` символа?
10. Для чего можно использовать функцию `chr()`?
11. Что будет выведено в консоль при выполнении команды: `print( (1+2)*('7'+'8') )`?

### Задание:

1. Напишите программу, которая объединяет две строки, введенные пользователем, и выводит результат на экран.

2. Допишите текст программы. Есть две строки `s1` и `s2`. Необходимо сформировать новую строку, продублировав **первое слово дважды**, **а второе - трижды** и вывести результат на экран.

   ```python
   s1 = "hello"
   s2 = "python"
   # продолжите программу
   ```

3. Допишите текст программы. Есть две переменные `a` и `b`. Необходимо сформировать строку вида: `Переменная a = <значение>, переменная b = <значение>` и вывести на экран.

   ```python
   a = 12
   b = 7
   # продолжите программу
   ```

4. Напишите программу, которая принимает строку от пользователя и выводит ее длину с помощью функции `len()`.

5. Допишите текст программы. Есть переменная `s1`, которая является строкой. Необходимо сформировать новую строку вида: `Строка: <введенная строка>. Длина: <длина строки>` и вывести ее на экран.

   ```python
   s1 = "Hello, Python!"
   # продолжите программу
   ```

6. Создайте программу, которая запрашивает у пользователя строку и проверяет, содержится ли в ней подстрока `"Python"`.

7. Допишите текст программы. Есть две переменные `s1` и `s2`. Необходимо вычислить следующие булевы значения:

   - проверка вхождения первого слова во второе. Вывести результат на экран.
   - сравнение двух слов на равенство. Вывести результат на экран.
   - сравнение на **больше** первого слова со вторым. Вывести результат на экран.
   - сравнение на **меньше** первого слова со вторым. Вывести результат на экран.
     ```python
     s1 = "str"
     s2 = "secondstr"
     # продолжите программу
     ```

8. Допишите текст программы. Есть две переменные `char1` и `char2`. Необходимо сформировать строку вида: `Коды: <буква1> = <код буквы1>, <буква2> = <код буквы2>` и вывести ее на экран.
   ```python
   char1 = "a"
   char2 = "z"
   # продолжите программу
   ```

## Урок 6. Индексы и срезы строк

### 6.1 Индексы в строке

**Строка** - **последовательность символов**, заключенных в одинарные или двойные кавычки.

**Каждый символ** строки имеет свой **уникальный, порядковый номер**. Эти номера называются **индексами**.

**Индексы строки** используются для обращения к **отдельным символам в строке**.

**Индексы** начинаются с **0** для первого символа, 1 для второго символа и так далее.

**Отрицательные индексы** могут быть использованы для обращения к символам с конца строки, где -1 обозначает последний символ, -2 обозначает предпоследний символ и так далее.

```python
my_string = "Hello, World!"
first_char = my_string[0]  # Получаем первый символ "H"
last_char = my_string[-1]  # Получаем последний символ "!"
print(first_char)
print(last_char)
```

Если вы попытаетесь обратиться к **несуществующему индексу** строки в Python, возникнет **ошибка `IndexError`**. Это происходит, когда индекс находится **за пределами допустимого диапазона индексов строки**.

```python
my_string = "Hello, World!"
invalid_index = my_string[100]  # Попытка получить символ с несуществующим индексом
```

### 6.2 Подстроки. Срезы.

**Подстрока** - это часть строки, которая состоит из **последовательности символов**.

**Подстрока** может быть получена путем **выбора определенного диапазона символов из исходной строки**.

Для **выделения подстроки** в Python можно использовать **срезы строк**.

**Срезы строк** позволяют получать **подстроки из исходной строки**.

Синтаксис срезов состоит из использования **квадратных скобок** и **двоеточия**.

**Синтаксис срезов**:

```
string[start:stop:step]

start - индекс, с которого начинается срез (включительно).
stop - индекс, на котором заканчивается срез (не включается).
step - шаг, определяющий, какие символы будут включены в срез.
```

**Срезы строк** включают:

- **начальный индекс(start)**,
- **конечный индекс(stop)**,
- **шаг(step)**.

**Пример использования срезов**:

```python
main_string = "Python is fun!"
substring = main_string[0:6]  # Получаем подстроку "Python"
substring2 = main_string[7:]  # Получаем подстроку "is fun!"
substring3 = main_string[:6]  # Получаем подстроку "Python"
substring4 = main_string[::2]  # Получаем подстроку "Pto sfn"
```

### 6.3 Отрицательный шаг в срезах.

**Отрицательный шаг** в срезах используется для получения подстроки в **обратном порядке**. Отрицательный шаг указывает, **какие символы будут включены в подстроку**.

**Например**:

```python
main_string = "Привет, мир!"
reversed_string = main_string[::-1]  # Получаем строку в обратном порядке "!рим ,тевирП"
substring1 = main_string[4:1:-1]  # Получаем подстроку "еви"
substring2 = main_string[::-2] # Получаем каждый второй символ в обратном порядке
substring3 = main_string[1:4:-1] # Получаем пустую строку
print("reversed_string: ", reversed_string)
print("substring1: ", substring1)
print("substring2: ", substring2)
print("substring3: ", substring3)
```

### 6.4 Почему `main_string[4:1:-1]`?

**Отрицательный шаг** в срезах указывает направление обхода символов строки.

В данном случае, `main_string[4:1:-1]` означает, что мы начинаем с индекса **4 (символ "е")**, заканчиваем на индексе **1 (символ "и")** и двигаемся с **шагом -1 (в обратном направлении)**. Мы получаем подстроку "ети".

Если бы мы использовали `main_string[1:4:-1]`, то **начальный индекс (1)** был бы **меньше конечного индекса (4)**, что **противоречит направлению обхода**. В результате получилась **пустая строка**.

Таким образом, срезы всегда должны образовывать **диапозон значений**.

### 6.5 Изменение строк.

Cтроки являются **неизменяемым типом данных**, что означает, что непосредственное изменение строки невозможно.

Попытка **изменить символ** по индексу или **присвоить символ новому индексу** строки приведет к ошибке:

```python
main_string = "Hello World!" # Длина строки - 12 символов, т.е. последний символ имеет индекс "11"
main_string[11] = "?" # Ошибка
main_string[12] = "!" # Ошибка
```

Чтобы изменить строку, нужно **создать новую строку с другим содержимым**:

```python
main_string = "Hello World!"
second_string = main_string[:-1] + "?"
print(main_string)
print(second_string)
```

### Вопросы:

1. Что такое индекс в строке и как он используется в Python?
2. Как можно извлечь подстроку из строки с помощью срезов?
3. Что произойдет, если вы попытаетесь получить символ строки по индексу, который выходит за пределы длины строки?
4. Какой результат будет у выражения `main_string[2:5]`, если `main_string = "Привет, мир!"`?
5. Как использовать отрицательные индексы для доступа к символам строки?
6. Что такое шаг в срезах и как он влияет на результат?
7. Какой результат будет у выражения `main_string[::-1]`?
8. Объясните, почему выражение `main_string[4:1:-1]` возвращает определенную подстроку, а `main_string[1:4:-1]` вернет пустую строку. Как это работает?
9. Как можно использовать срезы для удаления части строки?
10. Как можно изменить строку, используя индексы и срезы?

### Задачи:

1. Напишите программу, которая принимает строку от пользователя. Прочитайте эту строку и отобразите на экране ее первый и последний символ подряд в одну строчку. **Пример входных данных**: `"Я люблю Python"`.

2. Напишите программу, которая принимает строку от пользователя. Прочитайте эту строку и отобразите первые четыре ее символа. Полагается, что строка гарантированно имеет длину не менее четырех символов. **Пример входных данных**: `"Я люблю программирование"`.

3. Напишите программу, которая принимает строку от пользователя. Прочитайте эту строку и отобразите последние три ее символа. Полагается, что строка гарантированно имеет длину не менее трех символов. **Пример входных данных**: `"Я люблю Академию Top"`.

4. Напишите программу, которая принимает строку от пользователя. Прочитайте ее и отобразите все ее символы с нечетными индексами. **Пример входных данных**: `"Программирование"`.

5. Напишите код, который проверяет, содержится ли подстрока `"Python"` в строке вводимой пользователем. Если подстрока есть в строке вводимой пользователем, вывести на экран `True`, в противном случае вывести на экран `False`. **Пример входных данных**: `"Изучаем Python и программируем"`.

6. Напишите программу, которая принимает строку и удаляет из нее первые три символа, используя срезы. Выведите результат на экран.

7. Напишите программу, которая принимает две строки от пользователя. Прочитайте их и из первой строки выделите все символы с четными индексами, а из второй - с нечетными. Объедините полученные строки через пробел и выведите результирующую строку на экран. **Пример входных данных**: `"Изучаем Python"`, `"программируем"`.

8. Напишите программу, которая принимает строку от пользователя. Необходимо ее прочитать и отобразить первые пять символов в обратном порядке. Полагается, что введенная строка имеет минимум пять символов.

9. Напишите программу, которая принимает строку от пользователя. Длина первого слова меньше второго. Необходимо обрезать второе слово до длины первого и вывести на экран.

## Урок 7. Основные методы строк

### 7.1 Методы строк.

**Методы** - это специальные **операции**, которые **применяются к объектам определенного типа данных или определенной структуры данных**.

**Методы строк** - это специальные **операции**, которые могут быть применены к **строковым объектам** для **выполнения различных действий**.

Чтобы **вызвать метод для конкретной строки**, необходимо **указать объект**, **поставить точку**, **записать имя метода и в круглых скобках список аргументов**, **если они необходимы**:

```
объект.метод(аргументы)
```

### 7.2 Методы для работы с регистром:

- `String.upper()` - Возвращает строку с заглавными буквами.
  ```python
  s = 'hello'
  uppercase = s.upper()
  print(uppercase)  # Вывод: 'HELLO'
  ```
- `String.lower()` - Возвращает строку с малыми буквами.
  ```python
  s = 'WORLD'
  lowercase = s.lower()
  print(lowercase)  # Вывод: 'world'
  ```
- `String.capitalize()` — Делает первую букву строки заглавной.
  ```python
  my_string = "доброго утра!"
  result = my_string.capitalize()
  print(result)  # Вывод: "Доброго утра!" (первая буква заглавная, остальные строчные)
  ```
- `String.title()` — делает первую букву каждого слова заглавной.
  ```python
  my_string = "привет, мир! как дела?"
  result = my_string.title()
  print(result)  # Вывод: "Привет, Мир! Как Дела?"
  ```
- `String.swapcase()` — меняет регистр каждого символа (верхний на нижний и наоборот).
  ```python
  my_string = "ПрИвЕт, МИР!"
  result = my_string.swapcase()
  print(result)  # Вывод: "пРиВеТ, мир!"
  ```

### 7.3 Методы для поиска и подсчета:

- `String.count(sub)` - Определяет число вхождений подстроки `sub` в строке `String`. Метод может принимать **два дополнительных аргумента**: `start` и `end`: `String.count(sub, start=..., end=...)`.

  ```python
  # Один аргумент (подстрока):
  my_string = "Привет, мир! Привет!"
  count = my_string.count("Привет")
  print(count)  # Вывод: 2

  # Два аргумента (подстрока и начальный индекс):
  my_string = "Привет, мир! Привет!"
  count = my_string.count("Привет", 5)  # Считаем начиная с символа под пятым индексом
  print(count)  # Вывод: 1

  # Три аргумента (подстрока, начальный индекс и конечный индекс):
  my_string = "Привет, мир! Привет!"
  count = my_string.count("и", 0, 10)  # Считаем 'и' только в первой части строки
  print(count)  # Вывод: 1
  ```

- `String.find(sub)` - Возвращает индекс первого найденного вхождения `sub` в строке `String`. Если подстрока не найдена, метод возвращает значение `-1`. Метод может принимать **два дополнительных аргумента**: `start` и `end`: `String.find(sub, start=..., end=...)`.

  ```python
  # Один аргумент (подстрока):
  my_string = "Привет, мир! Привет!"
  index = my_string.find("Привет")
  print(index)  # Вывод: 0 (индекс первого вхождения)

  # Два аргумента (подстрока и начальный индекс):
  my_string = "Привет, мир! Привет!"
  index = my_string.find("Привет", 5)  # Начинаем поиск с индекса 5
  print(index)  # Вывод: 13 (индекс второго вхождения)

  # Три аргумента (подстрока, начальный индекс и конечный индекс):
  my_string = "Привет, мир! Привет!"
  index = my_string.find("и", 0, 10)  # Считаем 'и' только в первой части строки
  print(index)  # Вывод: 6 (индекс первого вхождения 'и' в диапазоне)
  ```

- `String.index(sub)` - Возвращает индекс первого найденного вхождения. Если подстрока не найдена, метод вызывает исключение `ValueError`. Метод может принимать **два дополнительных аргумента**: `start` и `end`: `String.index(sub, start=..., end=...)`.

  ```python
  # Один аргумент (подстрока):
  my_string = "Привет, мир! Привет!"
  index = my_string.index("Привет")
  print(index)  # Вывод: 0 (индекс первого вхождения)

  # Два аргумента (подстрока и начальный индекс):
  my_string = "Привет, мир! Привет!"
  index = my_string.index("Привет", 5)  # Начинаем поиск с индекса 5
  print(index)  # Вывод: 13 (индекс второго вхождения)

  # Три аргумента (подстрока, начальный индекс и конечный индекс):
  my_string = "Привет, мир! Привет!"
  index = my_string.index("и", 0, 10)  # Считаем 'и' только в первой части строки
  print(index)  # Вывод: 6 (индекс первого вхождения 'и' в диапазоне)
  ```

- `String.rfind(sub)` - Возвращает индекс первого найденного вхождения при поиске **справа**. Остальной функционал как у метода `String.find(sub)`.
  ```python
  s = 'hello'
  index = s.rfind('l')
  print(index)  # Вывод: 3
  ```
- `String.rindex(sub)` — возвращает индекс последнего вхождения подстроки `sub`, или вызывает `ValueError`, если не найдено. Метод может принимать **два дополнительных аргумента**: `start` и `end`: `String.rindex(sub, start=..., end=...)`. Метод ищет подстроку `sub` **с конца строки**, начиная с индекса `start` и заканчивая индексом `end`. Если `start` **не указан**, поиск начинается с **конца строки**. Если `end` не указан, поиск продолжается **до конца строки**.

  ```python
  # Один аргумент (подстрока):
  my_string = "Привет, мир! Привет!"
  result = my_string.rindex("Привет")
  print(result)  # Вывод: 15 (индекс последнего вхождения)

  # Два аргумента (подстрока и начальный индекс):
  my_string = "Привет, мир! Привет! Как дела?"
  result = my_string.rindex("Привет", 0)  # Поиск с начала строки
  print(result)  # Вывод: 15 (индекс последнего вхождения)

  # Три аргумента (подстрока, начальный индекс и конечный индекс):
  my_string = "Привет, мир! Привет! Как дела?"
  result = my_string.rindex("Привет", 0, 15)  # Поиск в диапазоне от 0 до 15
  print(result)  # Вывод: 0 (индекс первого вхождения в указанном диапазоне)
  ```

### 7.4 Методы для работы со строками и итерируемыми объектами:

- `String.split()` - Разбивает **строку на подстроки и возвращает `список`**. Метод может принимать **два необязательных аргумента**. **Первый аргумент** — `sep`, который **указывает разделитель, по которому строка будет разбита**. **Второй аргумент** — `maxsplit`, который определяет **максимальное количество разбиений**. Если `maxsplit` не указан, метод будет разбивать строку на все возможные части. **Полный синтаксис**: `String.split(sep=None, maxsplit=-1)`.

  ```python
  # Стандартный вариант (без аргументов):
  my_string = "Привет мир! Как дела?"
  result = my_string.split()
  print(result)  # Вывод: ['Привет', 'мир!', 'Как', 'дела?'] (разделение по пробелам)

  # С указанием разделителя (sep):
  my_string = "яблоко,банан,груша"
  result = my_string.split(',')
  print(result)  # Вывод: ['яблоко', 'банан', 'груша'] (разделение по запятой)

  # С указанием максимального количества разбиений (maxsplit):
  my_string = "яблоко,банан,груша,апельсин"
  result = my_string.split(',', 2)  # Разбиваем только на 2 части
  print(result)  # Вывод: ['яблоко', 'банан', 'груша,апельсин'] (последняя часть содержит оставшиеся элементы)
  ```

- `String.join(iterable)` - Метод **объединяет элементы итерируемого объекта в одну строку**, используя строку, на которой он был вызван, в качестве разделителя.Принимает **один аргумент** — `iterable`, который представляет собой **итерируемый объект (например, список, кортеж или строку)**. **Все элементы** в итерируемом объекте **должны быть строками**; если в итерируемом объекте есть элементы другого типа, будет вызвано исключение `TypeError`.

  ```python
  # Объединение списка строк:
  words = ["Привет", "мир", "как", "дела?"]
  result = " ".join(words)
  print(result)  # Вывод: "Привет мир как дела?" (элементы объединены с пробелом)

  # Объединение с другим разделителем:
  fruits = ["яблоко", "банан", "груша"]
  result = ", ".join(fruits)
  print(result)  # Вывод: "яблоко, банан, груша" (элементы объединены с запятой и пробелом)

  # Объединение символов:
  letters = ['a', 'b', 'c', 'd']
  result = ''.join(letters)
  print(result)  # Вывод: "abcd" (элементы объединены без разделителей)
  ```

- `String.partition(sep)` — Метод возвращает кортеж, состоящий из трех элементов: части строки до разделителя, сам разделитель `sep` и части строки после разделителя.

  ```python
  # Когда разделитель найден:
  my_string = "Python is fun"
  result = my_string.partition("is")
  print(result)  # Вывод: ('Python ', 'is', ' fun')

  # Когда разделитель не найден:
  my_string = "Python is fun"
  result = my_string.partition("not")
  print(result)  # Вывод: ('Python is fun', '', '')
  ```

### 7.5 Методы для удаления или изменения символов

- `String.replace(old, new)` - Заменяет подстроку `old` на `new`. Метод может принимать **третий аргумент** — `count`, который указывает, сколько замен нужно произвести: `String.replace(old, new, count)`.

  ```python
  # Стандартный вариант (два аргумента):
  my_string = "Привет, мир! Привет!"
  result = my_string.replace("Привет", "Здравствуйте")
  print(result)  # Вывод: "Здравствуйте, мир! Здравствуйте!"

  # С третьим аргументом (count):
  my_string = "Привет, мир! Привет! Привет!"
  result = my_string.replace("Привет", "Здравствуйте", 1)  # Заменяем только первое вхождение
  print(result)  # Вывод: "Здравствуйте, мир! Привет! Привет!"
  ```

- `String.strip()` - Метод используется для **удаления пробелов** (или других символов) с начала и конца строки. Он может принимать один необязательный аргумент `chars`, который определяет, какие символы следует удалить: `String.strip(chars)`.

  ```python
  # Стандартный вариант (без аргументов):
  my_string = "   Привет, мир!   "
  result = my_string.strip()
  print(result)  # Вывод: "Привет, мир!" (пробелы удалены с начала и конца)

  # С указанием символов (chars):
  my_string = "---Привет, мир!---"
  result = my_string.strip('-')
  print(result)  # Вывод: "Привет, мир!" (символы '-' удалены с начала и конца)

  # Удаление произвольных символов:
  my_string = "abcПривет, мир!xyz"
  result = my_string.strip('abcxyz')
  print(result)  # Вывод: "Привет, мир!" (символы 'a', 'b', 'c', 'x', 'y', 'z' удалены с начала и конца)
  ```

- `String.rstrip()` - Удаляет пробелы (или других символов) **справа**. Остальной функционал как у метода `String.strip()`.
  ```python
  s = '   hello   '
  stripped = s.rstrip()
  print(stripped)  # Вывод: '   hello'
  ```
- `String.lstrip()` - Удаляет пробелы (или других символов) **слева**. Остальной функционал как у метода `String.strip()`.
  ```python
  s = '   hello   '
  stripped = s.lstrip()
  print(stripped)  # Вывод: 'hello   '
  ```

### 7.6 Методы для выравнивания строк:

- `String.rjust(width)` - Расширяет строку, добавляя символы **слева**. У этого метода также есть необязательный аргумент — `fillchar`, который задает символ, используемый для заполнения пробелов слева от строки: `String.rjust(width, fillchar)`.

  ```python
  # Стандартный вариант (только width):
  my_string = "Привет"
  result = my_string.rjust(10)
  print(result)  # Вывод: "    Привет" (строка выровнена вправо с пробелами слева)

  # С необязательным аргументом (fillchar):
  my_string = "Привет"
  result = my_string.rjust(10, '*')
  print(result)  # Вывод: "****Привет" (строка выровнена вправо с символом '*' слева)
  ```

- `String.ljust(width)` - Расширяет строку, добавляя символы **справа**. У этого метода также есть необязательный аргумент — `fillchar`, который задает символ, используемый для заполнения пробелов справа от строки: `String.ljust(width, fillchar)`

  ```python
  # Стандартный вариант (только width):
  my_string = "Привет"
  result = my_string.ljust(10)
  print(result)  # Вывод: "Привет    " (строка выровнена влево с пробелами справа)

  # С необязательным аргументом (fillchar):
  my_string = "Привет"
  result = my_string.ljust(10, '*')
  print(result)  # Вывод: "Привет****" (строка выровнена влево с символом '*' справа)
  ```

### 7.7 Методы для проверки содержимого строки:

- `String.isalpha()` - Определяет, состоит ли строка целиком из **буквенных символов**. Если строка **состоит только из букв**, метод возвращает `True`, в противном случае — `False`.

  ```python
  # Строка состоит только из букв
  my_string = "Привет"
  result = my_string.isalpha()
  print(result)  # Вывод: True

  # Строка содержит цифры
  my_string = "Привет123"
  result = my_string.isalpha()
  print(result)  # Вывод: False

  # Строка содержит пробелы
  my_string = "Привет мир"
  result = my_string.isalpha()
  print(result)  # Вывод: False

  # Пустая строка
  my_string = ""
  result = my_string.isalpha()
  print(result)  # Вывод: False
  ```

- `String.isdigit()` - Определяет, состоит ли строка целиком из **цифр**. Если строка состоит **только из цифр**, метод возвращает `True`, в противном случае — `False`.

  ```python
  # Строка состоит только из цифр
  my_string = "12345"
  result = my_string.isdigit()
  print(result)  # Вывод: True

  # Строка содержит буквы
  my_string = "123abc"
  result = my_string.isdigit()
  print(result)  # Вывод: False

  # Строка содержит пробелы
  my_string = "123 456"
  result = my_string.isdigit()
  print(result)  # Вывод: False

  # Пустая строка
  my_string = ""
  result = my_string.isdigit()
  print(result)  # Вывод: False
  ```

- `String.isalnum()` — Метод возвращает `True`, если все символы в строке являются алфавитно-цифровыми, и `False` в противном случае.

  ```python
  # Пример с цифрами:
  text = "123456"
  print(text.isalnum())  # Вывод: True

  # Пример с буквами:
  text = "abcdef"
  print(text.isalnum())  # Вывод: True

  # Пример с буквами и цифрами:
  text = "AlphaNumeric001"
  print(text.isalnum())  # Вывод: True
  ```

- `String.startswith(sub)` - возвращает `True`, если строка начинается с указанной подстроки, и `False` в противном случае. Метод может принимать **два дополнительных аргумента**: `start` и `end`: `String.startswith(sub, start=..., end=...)`.

  ```python
  # Один аргумент (подстрока):
  my_string = "Hello, welcome to my world."
  print(my_string.startswith("Hello"))  # Вывод: True
  print(my_string.startswith("welcome"))  # Вывод: False

  # Два аргумента (подстрока и начальный индекс):
  my_string = "Hello, welcome to my world."
  print(my_string.startswith("welcome", 7))  # Вывод: True
  print(my_string.startswith("welcome", 8)) # Вывод: False

  # Три аргумента (подстрока, начальный индекс и конечный индекс):
  my_string = "Hello, welcome to my world."
  print(my_string.startswith("welcome", 7, 20))  # Вывод: True
  print(my_string.startswith("welcome", 8, 20)) # Вывод: False
  ```

- `String.endswith(sub)` - возвращает `True`, если строка заканчивается указанной подстрокой, и `False` в противном случае. Метод может принимать **два дополнительных аргумента**: `start` и `end`: `String.endswith(sub, start=..., end=...)`.

  ```python
  # Один аргумент (подстрока):
  my_string = "Hello, welcome to my world."
  print(my_string.endswith("world."))  # Возвращает True
  print(my_string.endswith("python"))  # Возвращает False

  # Два аргумента (подстрока и начальный индекс):
  my_string = "Hello, welcome to my world."
  print(my_string.endswith("world.", 7))  # Возвращает True
  print(my_string.endswith("python", 7))  # Возвращает False

  # Три аргумента (подстрока, начальный индекс и конечный индекс):
  my_string = "Hello, welcome to my world."
  print(my_string.endswith("world.", 7, 20))  # Возвращает True
  print(my_string.endswith("python", 7, 20))  # Возвращает False
  ```

### 7.8 Основные методы для работы:

1. **Преобразование регистра**:

   - `upper()` - Возвращает строку с **заглавными буквами**.
   - `lower()` - Возвращает строку с **малыми буквами**.
   - `capitalize()` - Делает **первую букву строки заглавной**.
   - `title()` - Делает **первую букву каждого слова заглавной**.

2. **Поиск и замена подстрок**:

   - `find(sub)` - Возвращает **индекс первого найденного вхождения** `sub` в строке. Если подстрока не найдена, метод возвращает значение `-1`.
   - `index(sub)` - Возвращает индекс **первого найденного вхождения** `sub` в строке. Если подстрока не найдена, метод возвращает исключение `ValueError`.
   - `replace(old, new)` - **Заменяет** подстроку `old` на `new`.

3. **Проверка содержимого строки**:

   - `isalpha()` - Определяет, состоит ли строка целиком из **буквенных символов**.
   - `isdigit()` - Определяет, состоит ли строка целиком из **цифр**.
   - `isalnum()` - Определяет, состоит ли строка целиком из **буквенных символов или цифр**.
   - `startswith(sub)` - возвращает `True`, если строка начинается с указанной подстроки, и `False` в противном случае.
   - `endswith(sub)` - возвращает `True`, если строка заканчивается указанной подстрокой, и `False` в противном случае.

4. **Управление пробелами и выравнивание**:

   - `strip()` - Метод используется для **удаления пробелов** (или других символов) с начала и конца строки.
   - `ljust(width)` - Расширяет строку, добавляя символы **справа**.
   - `rjust(width)` - Расширяет строку, добавляя символы **слева**.

5. **Разделение и объединение строк**:
   - `split()` - **Разбивает строку** на подстроки и возвращает `список`.
   - `join(iterable)` - **Объединяет элементы итерируемого объекта** в одну строку, используя строку, на которой он был вызван, в качестве разделителя.

### Вопросы:

1. Какие методы используются для изменения регистра символов в строке?
2. Что делает метод lower()?
3. Как найти индекс первого вхождения подстроки в строке?
4. Что делает метод count()?
5. Как объединить список строк в одну строку?
6. Что делает метод split()?
7. Как удалить пробелы из начала и конца строки?
8. Как заменить одну подстроку на другую в строке?
9. Как выровнять строку по левому краю в заданной ширине?
10. Как проверить, начинается ли строка с определенной подстроки?
11. Как проверить, заканчивается ли строка определенной подстрокой?

### Задачи:

1. Напишите программу, которая принимает строку от пользователя и выводит её в верхнем регистре.

2. Напишите программу, которая удаляет пробелы в начале и конце строки, введенной пользователем.

3. На вход программе подается слово в виде строки. Необходимо прочитать это слово и его первую букву сделать заглавной, а остальные - малыми. Результат отобразить на экране.

4. Напишите программу, которая заменяет все вхождения слова `"старый"` на `"новый"` в строке, введенной пользователем.

5. На вход программе подается строка. Необходимо прочитать эту строку и определить число вхождений дефисов `-` в ней. На экране отобразить полученное число. **Пример входящей строки**: `osnovnye-metody-strok`.

6. На вход программе подается строка. Прочитайте эту строку и найдите в ней индекс первого вхождения фрагмента `"world"`. Полученное число (индекс) выведите на экран.

7. На вход программе подается строка. Прочитайте ее и замените в ней все двойные дефисы `--` и тройные `---` на одинарные `-`. Результат выведите на экран. **Пример входящей строки**: `osnovnye-metody---strok--practica`.

8. На вход программе подаются три целых положительных числа (максимум трехзначные), записанные в одну строчку через пробел. Необходимо их прочитать из входного потока. Затем, для двухзначных и однозначных чисел добавить слева незначащие нули так, чтобы все числа содержали по **три цифры**. Вывести на экран полученные числа в столбик (каждое с новой строки) в порядке их чтения из входного потока.

9. На вход программе подается строка, состоящая из слов, разделенных пробелом. Необходимо прочитать строку и **подсчитать число слов в ней**. Результат (число слов) отобразить на экране.

10. На вход программе подается строка, состоящая из названий городов, разделенных пробелом. Необходимо прочитать эту строку и преобразовать так, чтобы названия городов шли через точку с запятой (без пробелов). Результат отобразите на экране. **Пример входящей строки**: `Москва Тверь Казань`.

11. На вход программе подается строка, содержащая список продуктов, разделённых запятыми. Разделения строки на отдельные продукты так, что бы получить только первые два продукта. **Пример входящей строки**: `"Яблоко, Банан, Апельсин, Груша"`.

## Урок 8. Экранирование символов. Спецсимволы

### 8.1 Специальные символы

**Специальные символы** - это символы, которые имеют **особое значение** и **используются для определенных целей** в строках или коде на языке Python.

### 8.2 Экранирование символов.

**Экранирование символов** - это процесс использования **обратной косой черты** `(\)` перед специальными символами, чтобы указать, что они **должны быть интерпретированы как обычные символы, а не как часть синтаксиса языка Python**.  
Это позволяет **использовать символы, которые обычно имеют специальное значение, в строках или коде Python**.

### 8.3 Список специальных символов в Python:

- `\n` - Перевод строки
- `\\` - Символ обратного слеша
- `\’` - Символ апострофа
- `\"` - Символ двойной кавычки
- `\a` - Звуковой сигнал
- `\b` - Эмуляция клавиши BackSpace
- `\f` - Перевод формата
- `\r` - Возврат каретки
- `\t` - Горизонтальная табуляция (размером в 4 пробела)
- `\v` - Вертикальная табуляция
- `\0` - Символ Null (не признак конца строки)
- `\xhh` - Символ с шестнадцатиричным кодом hh
- `\ooo` - Символ с восьмиричным кодом ooo
- `\N{id}` - Идентификатор из кодовой таблицы Unicode
- `\uhhhh` - 16-битный символ Unicode в шестнадцатиричной форме
- `\Uhhhhhhhh` - 32-битный символ Unicode в шестнадцатиричной форме
- `\другое` - Не является экранированной последовательностью

### 8.4 Наиболее распространенные специальные символы:

- `\n` - символ новой строки
- `\t` - символ табуляции
- `\"` - двойная кавычка
- `\'` - одинарная кавычка
- `\\` - обратная косая черта

### 8.5 Явное указание специальных символов

#### Примеры:

- **Символ новой строки** `\n`:
  ```python
  print("Привет,\nмир!")
  ```
- **Символ табуляции** `\t`:
  ```python
  print("Имя:\tДжон")
  ```
- **Двойная кавычка** `\"`:
  ```python
  print("Он сказал: \"Привет!\"")
  ```
- **Одинарная кавычка** `\'`:
  ```python
  print('Она сказала: \'Привет!\'')
  ```
- **Обратная косая черта** `\\`:
  ```python
  print("Путь к файлу: C:\\папка\\файл.txt")
  ```
- Символ возврата каретки `\r`. :

  ```python
  print("Привет,\rмир!")
  ```

  `Возврат каретки (\r)` - это специальный символ в Python, который обозначает **перевод каретки в начало текущей строки**.  
  При использовании этого символа, **курсор перемещается в начало строки, и последующий вывод замещает уже существующий текст** на этой строке.  
  Например, если вы используете символ `\r` в строке вывода, то **следующий текст будет начинаться с начала строки, перезаписывая предыдущий текст** на этой строке.  
  Это может быть полезно, например, при **создании анимаций в терминале или обновлении прогресс-бара**.  
  **Пример использования**:

  ```python
  import time

  for i in range(10):
      print(f"Прогресс: {i}/10", end="\r")
      time.sleep(1)
  ```

- **Символ возврата на одну позицию назад**. Эмуляция клавиши BackSpace `\b`:

  ```python
  print("Привет\bмир!")
  ```

  Специальный символ, который используется для эмуляции действия клавиши BackSpace. Этот символ перемещает курсор на одну позицию влево, что позволяет "удалить" символ, находящийся перед курсором, при выводе текста.

- Символ перевода страницы `\f`:
  ```python
  print("Заголовок\n\nТекст\fПодзаголовок")
  ```
  Это символ перевода страницы (form feed). Он используется для управления печатью и в основном предназначен для старых принтеров, чтобы начать новую страницу. В современных приложениях его использование довольно редкое.
  ```python
  print("Первая строка\fВторая строка")
  ```
  **Вывод может зависеть от среды**, в которой выполняется код, но **в большинстве случаев он просто не будет иметь заметного эффекта** в текстовом выводе.

### Вопросы:

1. Что такое спецсимволы?
2. Что такое экранирование символов?
3. Что происходит, если в строке не экранировать специальный символ?
4. Какие основные спецсимволы для строк существуют?

### Задачи:

1. Задать строку со следующим содержимым: `Он сказал: "спецсимволы"`. Вывести ее на экран.
2. На вход программе подается строка, состоящая из двух слов, записанных в одну строчку через пробел. Необходимо прочитать строку и между словами поставить символ обратного слеша вместо пробела. Результирующую строку отобразите на экране.
3. На вход программе подается слово в виде строки. Необходимо прочитать его и сформировать новую строку, где введенное слово будет заключено в двойные кавычки. Результат вывести на экран.
4. На вход программе подается строка со словами, разделенными пробелами. В строке может присутствовать от одного и более слов. Необходимо прочитать строку и первый пробел заменить на **одинарную кавычку** `'`, а все **остальные** - на двойные `"`. Результирующую строку вывести на экран. **Пример входящей строки**: `Экранирование символов`.

## Урок 9. Форматирование строк. F-строки. Сырые строки

### 9.1 Форматирование и Формирование строк.

**Форматирование строк** в Python относится к процессу **создания строки, в которой значения переменных вставляются в определенные места с использованием заполнителей**.

Это позволяет контролировать **формат вывода и вставлять значения различных типов данных в строку**.

В Python существует несколько способов форматирования строк, таких как метод `format()` и `f-строки (f-strings)`.

**Формирование строк** в Python относится к процессу **создания строки путем объединения нескольких значений или переменных**.

Это может быть достигнуто с помощью `оператора конкатенации (+)` или `метода join()`.

C оператором конкатенации `+` и методом `join()` мы уже знакомы.

### 9.2 Способы Форматирования строк.

- **Использование метода `format()`**:  
  Метод **format()** позволяет вставлять значения переменных в строку, используя заполнители {}.  
  **Например**:
  ```python
  name = "John"
  age = 25
  message = "Меня зовут {} и мне {} лет.".format(name, age)
  ```
- **Использование `f-строк (f-strings)`**:  
  **F-строки** - это новый способ форматирования строк, доступный в Python 3.6 и выше.  
  Они позволяют вставлять **значения переменных** непосредственно в строку, используя выражение в фигурных скобках `{}`.  
  **Например**:

  ```python
  # Вставка переменных:
  name = "John"
  age = 25
  message = f"Меня зовут {name} и мне {age} лет."
  print(message)

  # Использование выражений:
  a = 5
  b = 10
  result = f"Сумма {a} и {b} равна {a + b}."
  print(result)
  ```

### 9.3 Сырые строки.

**Сырые строки** - это строки, в которых **специальные символы не интерпретируются и остаются в их исходном виде**. Они задаются с помощью префикса `r` **перед открывающей кавычкой строки**.

**Примеры**:

- **Избегание экранирования специальных символов**: В сырых строках специальные символы, такие как обратная косая черта `(\)`, не экранируются.  
  Это может быть полезно, например, **при работе с путями файлов в операционной системе Windows**, где обратная косая черта используется в путях файлов.  
  **Пример**:
  ```python
  path = r'C:\Users\Username\Documents\file.txt'
  print(path)
  ```
- **Удобное использование регулярных выражений**: Регулярные выражения часто содержат специальные символы, которые могут быть интерпретированы в обычных строках.  
  Использование сырых строк позволяет избежать необходимости экранирования специальных символов в регулярных выражениях.  
  **Пример**:
  ```python
  import re
  pattern = r'\d+'  # Ищем одну или более цифр
  ```
- **Сохранение форматирования**: Сырые строки также сохраняют все пробелы и отступы, что может быть полезно, например, при создании многострочных текстовых блоков или сохранении форматирования в SQL-запросах.  
  **Пример**:
  ```python
  query = r'''
  SELECT *
  FROM table
  WHERE condition = 'value'
  '''
  ```

### Вопросы:

1. Каковы основные способы форматирования строк в Python?
2. Что такое f-строки и как они работают?
3. Как можно использовать выражения внутри f-строк?
4. Что такое сырые строки и в чем их отличие от обычных строк?

### Задачи:

1. На вход программе подаются следующие данные (каждое с новой строки):

   - имя (строка);
   - фамилия (строка);
   - возраст (целое положительное число).  
     Необходимо прочитать эти данные и, используя строковый метод format, сформировать новую строку по шаблону:
     `Уважаемый <имя> <фамилия>! Поздравляем Вас с <возраст>-летием!`
     Результат вывести на экран (без кавычек).

2. На вход программе подаются габариты изделия (целые числа): ширина, глубина, высота, записанные в одну строчку через пробел. Необходимо прочитать эти числа и с помощью метода format, используя ключи в качестве имен переменных, сформировать строку по шаблону:
   `Габариты: <ширина> x <глубина> x <высота>`
   Полученную строку вывести на экран (без кавычек).

3. На вход программе подаются два целых числа, записанных в одну строку через пробел. Необходимо прочитать эти числа и сформировать новую **F-строку** со значениями прочитанных чисел, записанных по возрастанию через пробел. Полученную строку вывести на экран.

4. На вход программе подаются следующие данные (каждое с новой строки):

   - курс доллара (вещественное значение);
   - число рублей (целое число) для обмена рублей на доллары.  
     Необходимо прочитать эти данные и вычислить целое количество получаемых долларов (с отбрасыванием дробной части) и сформировать строку, по шаблону:
     `Вы можете получить <долларов>$ за <число рублей> рублей по курсу <курс доллара>`.
     Вывести полученную строку на экран (без кавычек).

5. Используя **raw-строки**, задайте строку, содержащую путь к файлу `"main.py"` вашего проекта. Выведите эту строку на экран.

## Урок 10. Списки. Операторы и функции работы со списками

### 10.1 Список.

**Списки** - это **упорядоченные коллекции элементов**, которые могут содержать объекты **разных типов**.

**Списки** являются **изменяемыми типами данных**, что означает, что их элементы могут быть изменены после создания списка.

**Списки** используются **для хранения и манипулирования наборами данных**,  
а также для выполнения различных операций, таких как **добавление, удаление и доступ к элементам списка**.

### 10.2 **Примеры использования списков в Python**:

- Хранение списка студентов в классе:
  ```python
  students = ['Анна', 'Иван', 'Мария']
  ```
- Хранение координат точек на плоскости:
  ```python
  points = [(0, 0), (1, 2), (3, 4)]
  ```
- Хранение результатов эксперимента:
  ```python
  results = [10.2, 8.7, 9.5, 11.1]
  ```

### 10.3 Как задавать список

**В Python есть несколько способов задать список**:

- Задание списка с помощью квадратных скобок и перечисления элементов через запятую:
  ```python
  my_list = [1, 2, 3, 4, 5]
  ```
- Задание пустого списка:
  ```python
  empty_list = []
  ```
- Задание списка с помощью функции list():
  ```python
  my_list = list('hello')
  ```
- Задание списка с использованием генератора списка:
  ```python
  my_list = [x for x in range(10)]
  ```
- Задание списка с помощью метода append():
  ```python
  my_list = []
  my_list.append(1)
  my_list.append(2)
  my_list.append(3)
  ```

### 10.4 Обращение по индексу к элементу списка.

**Списки** являются **упорядоченными коллекциями**, и каждый элемент списка имеет свой **индекс**, который начинается с `нуля`.

**Первый элемент** списка имеет индекс `0`, **второй** — индекс `1` и так далее.

**Обращение** к элементу списка осуществляется с помощью квадратных скобок `[]`, в которых указывается индекс элемента.

**Примеры обращения к элементам списка**:

```python
# Обращение к первому элементу списка:
fruits = ['яблоко', 'банан', 'вишня']
print(fruits[0])  # Вывод: яблоко

# Обращение к последнему элементу списка
print(fruits[-1])  # Вывод: вишня

# Обращение к элементу по конкретному (2) индексу
numbers = [10, 20, 30, 40, 50]
print(numbers[2])  # Вывод: 30 (третий элемент)

# Изменение элемента списка по индексу:
numbers[1] = 25  # Изменяем второй элемент
print(numbers)  # Вывод: [10, 25, 30, 40, 50]

# Ошибка: индекс, выходящий за границы списка:
print(fruits[3])  # Ошибка: IndexError: list index out of range
```

### 10.5 Список - изменяемый тип даных

**Списки** в Python являются изменяемыми типами данных, что означает, что их **элементы могут быть изменены после создания списка**. Это отличает их от неизменяемых типов данных, таких как строки или кортежи.

**Примеры**:

- Пример изменения первого элемента списка:
  ```python
  my_list = [1, 2, 3, 4, 5]
  my_list[0] = 10
  print(my_list)
  ```
- Пример удаления элемента из списка:
  ```python
  my_list = [1, 2, 3, 4, 5]
  del my_list[2]
  print(my_list)
  ```
- Пример добавления элемента в список:
  ```python
  my_list = [1, 2, 3, 4, 5]
  my_list.append(6)
  print(my_list)
  ```

### 10.6 Встроенные функции для работы со списками:

- `len(iterable)` – **определение числа элементов в списке `iterable` (длина списка)**.
  ```python
  my_list = [1, 2, 3, 4, 5]
  length = len(my_list)
  print(length)  # Вывод: 5
  ```
- `max(iterable)` – **для нахождения максимального значения**. Эта функция не изменяет исходный объект, а возвращает новый отсортированный список.
  ```python
  my_list = [1, 2, 3, 4, 5]
  maximum = max(my_list)
  print(maximum)  # Вывод: 5
  ```
- `min(iterable)` – **для нахождения минимального значения**. Эта функция не изменяет исходный объект, а возвращает новый отсортированный список.
  ```python
  my_list = [1, 2, 3, 4, 5]
  minimum = min(my_list)
  print(minimum)  # Вывод: 1
  ```
- `sum(iterable)` – **для вычисления суммы**. Эта функция не изменяет исходный объект, а возвращает новый отсортированный список.
  ```python
  my_list = [1, 2, 3, 4, 5]
  total = sum(my_list)
  print(total)  # Вывод: 15
  ```
- `sorted(iterable)` – **для сортировки коллекции**. Функция может принимать дополнительный аргумент: `reverse`. Синтаксис: `sorted(iterable, reverse=True)`. Эта функция не изменяет исходный объект, а возвращает новый отсортированный список.
  ```python
  my_list = [5, 2, 4, 1, 3]
  sorted_list = sorted(my_list)
  print(sorted_list)  # Вывод: [1, 2, 3, 4, 5]
  ```

### 10.7 Операторы для работы со списками:

- `+` – **соединение двух списков в один**
  ```python
  list1 = [1, 2, 3]
  list2 = [4, 5, 6]
  combined_list = list1 + list2
  print(combined_list)  # Вывод: [1, 2, 3, 4, 5, 6]
  ```
- `*` – **дублирование списка**:
  ```python
  my_list = [1, 2, 3]
  duplicated_list = my_list * 2
  print(duplicated_list)  # Вывод: [1, 2, 3, 1, 2, 3]
  ```
- `in` – **проверка вхождения элемента в список**:
  ```python
  my_list = [1, 2, 3, 4, 5]
  if 3 in my_list:
      print("Элемент 3 присутствует в списке")
  ```
- `del` – **удаление элемента списка**:
  ```python
  my_list = [1, 2, 3, 4, 5]
  del my_list[2]
  print(my_list)  # Вывод: [1, 2, 4, 5]
  ```

### Вопросы:

1. К каким типам данных относится список?
2. Как создать список в Python?
3. Как можно получить доступ к элементам списка?
4. По какому индексу можно обратиться к значению `5` списка: `a = [0, True, "Москва", 5, False, "Омск"]`.
5. Что означает, что список является изменяемым типом данных?
6. Как отсортировать список?
7. Как узнать количество элементов в списке?
8. Как объединить два списка в один?
9. Как проверить, содержится ли элемент в списке?

### Задачи:

1. На вход программе подаются три целых числа. Необходимо прочитать эти числа и сформировать список `lst`, хранящий прочитанные значения в порядке их чтения. Результат выведите на экран, используя команду: `print(lst)`.

2. На вход программе подается **строка с названиями городов**, записанных в одну строчку через пробел. Необходимо прочитать эту строку и на ее основе сформировать список. Затем, необходимо проверить, присутствует ли в этом списке город `"Нальчик"`. Вывести на экран `True`, если присутствует и `False` - в противном случае. **Пример входящей строки**: `Москва Казань Ростов Нальчик`.

3. На вход программе подается **строка с названиями городов**, записанных в одну строчку через **пробел**. Сформируйте список из этой строки. Выведите значение последнего элемента списка на экран. **Пример входящей строки**: `Москва Казань Ростов Нальчик`.

4. На вход программе подается **строка с оценками студента**, записаными через **пробел**. Необходимо вычислить средний балл списка и вывести его на экран с точностью до десятых. **Пример входящей строки**: `10 12 9 10 11`.

5. На вход программе подаются следующие данные по книге (каждое значение с новой строки):

   - **название** (строка);
   - **автор** (строка);
   - **число страниц** (целое число);
   - **цена** (вещественное число).  
     Необходимо прочитать эти данные и **сохранить в списке в порядке их чтения**.  
     Затем, из этого списка **удалить 3-й элемент** (число страниц).  
     В качестве автора записать `"Пушкин"`.  
     Цену увеличить в 2 раза.  
     Результат вывести на экран.  
     **Пример входных данных**:
     ```
     Война и мир
     Лев Толстой
     1225
     749.9
     ```

6. На вход программе подается **строка с числами новых подписчиков** канала по дням, записанных в одну строку через **пробел**. Необходимо прочитать эти числа и сохранить в списке, как **целые числа** в порядке их следования в строке. Затем, **вывести** через пробел на экран **максимальное**, **минимальное** и **суммарное** значения этого списка. **Пример входящей строки**: `100 102 90 105 115`.

7. На вход программе подается **строка с числами новых подписчиков** канала по дням, записанных в одну строку через пробел. Необходимо прочитать эти числа и сохранить в списке, как целые числа в порядке их следования в строке. Затем, **отсортировать** элементы этого списка по убыванию и результат вывести на экран. **Пример входящей строки**: `100 102 90 105 115`.

8. На вход программе подается **строка, содержащая названия городов**, записанных через пробел. Необходимо прочитать эту строку и на ее основе создать список `lst` из названий городов, добавив в его начало список `cities`: `cities = ["Москва", "Тверь", "Вологда"]`. Выведите полученный список lst на экран. **Пример входящей строки**: `Казань Ростов Нальчик`.

## Урок 11. Срезы списков. Сравнение списков

### 11.1 Срезы списка

**Срез списка** - это операция, которая позволяет получить `подсписок` из `исходного списка`.

**Срез** определяется с помощью указания **начального** и **конечного индексов** элементов списка, которые нужно включить в подсписок.

**Синтаксис среза списка выглядит следующим образом**:

```
список[начало:конец:шаг]
```

При этом **элемент с индексом начала включается в подсписок**, а **элемент с индексом конца не включается**.

**Примеры использования срезов списков**:

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Пример среза с двумя аргументами
sublist1 = numbers[2:5]
print(sublist1)  # [2, 3, 4]

# Пример среза с тремя аргументами
sublist2 = numbers[1:8:2]
print(sublist2)  # [1, 3, 5, 7]
```

### 11.2 Срезы с отрицательными индексами

**Отрицательные индексы** позволяют **обращаться** к элементам списка **с конца**. Например, индекс `-1` соответствует **последнему элементу**, `-2` — **предпоследнему** и так далее.

**Срезы** также могут использовать **отрицательные индексы**. Например, `a[-3:]` вернет **последние три элемента списка**.

**Пример**:

```python
# Отрицательные индексы
a = [10, 20, 30, 40, 50]
print(a[-1])  # Вывод: 50
print(a[-2])  # Вывод: 40

# Срез с отрицательным индексом
print(a[-3:])  # Вывод: [30, 40, 50]
```

### 11.3 Шаги в срезах

**Шаги в срезах** позволяют выбирать элементы с **определенным интервалом**. Синтаксис среза с шагом выглядит как `list[start:stop:step]`.

**Пример**:

```python
# положительный шаг
b = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(b[::2])  # Вывод: [0, 2, 4, 6, 8] (каждый второй элемент)
print(b[1::2])  # Вывод: [1, 3, 5, 7, 9] (каждый второй элемент, начиная с первого)

# отрицательный шаг
print(b[::-1])  # Вывод: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] (весь список в обратном порядке)
```

### 11.4 Создания поверхностной копии списка с помощью среза

**Срезы** можно использовать для **создания поверхностной копии списка**. Это полезно, когда нужно **работать с копией, не изменяя оригинал**.

**Пример**:

```python
original = [1, 2, 3, 4, 5]
copy = original[:]  # Создание копии
copy[0] = 10  # Изменяем копию
print(original)  # Вывод: [1, 2, 3, 4, 5] (оригинал не изменился)
print(copy)     # Вывод: [10, 2, 3, 4, 5] (копия изменена)
```

### 11.5 Изменение списка с помощью среза

**Срез списка** позволяет выбирать определенные элементы списка и изменять их значения.

```python
numbers = [1, 2, 3, 4, 5]
numbers[1:4] = [10, 20, 30]
print(numbers)  # [1, 10, 20, 30, 5]
```

### 11.6 Использование срезов для удаления элементов из списка.

**Срезы** в Python можно использовать для **удаления нескольких элементов из списка одновременно**. Это делается путем присвоения пустого списка срезу.

**Пример**:

```python
# удаление элементов с помощью присвоения пустого списка
my_list = [10, 20, 30, 40, 50]
my_list[1:3] = []  # Удаляем элементы с индексами 1 и 2
print(my_list)  # Вывод: [10, 40, 50]
```

### 11.7 Ошибка или пустой список.

При попытке доступа к элементу **по индексу, который выходит за границы списка**, Python выдаст ошибку `IndexError`. Однако, если **вы используете срезы**, Python вернет **пустой список**, если границы указаны неверно.

**Пример**:

```python
c = [1, 2, 3]
print(c[5:])  # Вывод: [] (пустой список)
print(c[1:5])  # Вывод: [2, 3] (срез работает корректно)
print(c[5])  # Ошибка: IndexError: list index out of range
```

### 11.8 Сравнение списков.

Сравнение списков в Python выполняется с помощью операторов сравнения, таких как `==`, `!=`, `<`, `>`, `<=` и `>=`.

- Оператор `==` используется для **проверки равенства двух списков**. Если все элементы исходных списков **равны и имеют одинаковый порядок**, то результатом будет `True`, в противном случае - `False`.
- Оператор `!=` используется для **проверки неравенства двух списков**. Если хотя бы **один элемент отличается** или **порядок элементов различается**, то результатом будет `True`, в противном случае - `False`.
- Операторы `<`, `>`, `<=` и `>=` используются для сравнения списков в **лексикографическом порядке**. Сравнение **выполняется покомпонентно**, начиная с первого элемента. Если первый отличающийся элемент в первом списке меньше (или больше) соответствующего элемента во втором списке, то результатом будет `True`, в противном случае - `False`.

  ```python
  list1 = [1, 2, 3]
  list2 = [1, 2, 3]
  list3 = [4, 5, 6]

  print(list1 == list2)  # True
  print(list1 != list3)  # True
  print(list1 < list3)   # True
  print(list1 > list3)   # False
  ```

### Вопросы:

1. Что такое срез списка и как его использовать?
2. Как можно использовать отрицательные индексы в срезах?
3. Что такое шаги в срезах и как они работают?
4. Как создать поверхностную копию списка с помощью среза?
5. Как изменить элементы списка с помощью среза?
6. Что произойдет, если срез списка будет выходить за границы его длины?
7. Как сравнивать два списка в Python?
8. Какой результат будет, если сравнить два списка с одинаковыми элементами, но в разном порядке?
9. Как можно использовать срезы для удаления элементов из списка?
10. Что такое ошибка `IndexError` и когда она возникает при работе со срезами?
11. Какой результат сравнения будет получен при выполнении команды: `[1, 2, 3] > [1, 1, 10]`
12. Какой результат сравнения будет получен при выполнении команды: `[1, 2, 3] < [1, 2, 3, 4]`
13. Какой результат сравнения будет получен при выполнении команды: `[1, 2, 3] >= [1, 2, 3]`
14. Какой результат сравнения будет получен при выполнении команды: `[1, 2, 3, "4"] > [1, 2, 3, "5"]`
15. Какой результат сравнения будет получен при выполнении команды: `[1, 2, 3, 7] > [1, 2, 3, "5"]`

### Задачи:

1. Объявите в программе следующий список: `my_list = [10, 20, 30, 40, 50]`. С помощью среза создайте новый список, содержащий элементы с индексами `0`, `2` и `4`.

2. Объявите в программе следующий список: `my_list = [5, 10, 15, 20, 25]`. Удалите элементы с индексами `1` и `2`.

3. Объявите в программе следующий список: `my_list = [1205, 1101, 1434, 1320, 923, 874]`. Выберите из списка `my_list` первые три значения и выведите этот срез как список на экран.

4. Объявите в программе следующий список: `my_list = [10, 20, 30, 40, 50, 60]`. Создайте поверхностную копию списка с помощью среза и измените первый элемент в копии на `100`. Выведите оба списка на экран.

5. Объявите в программе следующий список: `my_list = [1, 2, 3, 4, 5]`. Используя срезы, измените элементы с индексами `1` и `2` на `[20, 30]`. Выведите изменённый список на экран.

6. Объявите в программе следующий список с названиями городов: `cities = ["Москва", "Ульяновск", "Самара", "Тверь", "Вологда", "Омск", "Уфа"]`. С помощью срезов выберите из этого списка города через один и результат выведите на экран в виде полученного списка.

7. Объявите в программе следующий список с названиями городов: `cities = ["Москва", "Ульяновск", "Самара", "Тверь", "Вологда", "Омск", "Уфа"]`. С помощью срезов выберите из этого списка города через один (начиная со второго) и результат выведите на экран в виде полученного списка.

8. Объявите в программе следующий список с оценками студента: `scores = [2, 3, 5, 5, 2, 2, 3, 3, 4, 5, 4, 4]`. С помощью срезов выберите элементы с `3` по `7` (включительно) и выведите их на экран в виде списка в обратном порядке.

9. Объявите в программе следующий список с оценками студента: `scores = [2, 3, 5, 5, 2, 2, 3, 3, 4, 5, 4, 4]`. С помощью срезов выберите элементы через один, начиная с последнего, и выведите результат (срез) на экран в виде списка.

## Урок 12. Методы списков.

### 12.1 Метод

**Метод** - это функция, которая применяется к объекту определенного типа, такому как строка или список.

Методы позволяют **выполнять различные операции** с объектами и изменять их состояние.  
**Например**, **для строки** можно использовать методы, такие как `replace()`, чтобы **заменить определенные подстроки в строке**.  
**Для списков** доступны методы, такие как `append()`, чтобы **добавить элемент в конец списка**, или `insert()`, чтобы **вставить элемент в определенное место** списка.

**Методы** могут быть вызваны на объекте, используя **точечную нотацию**. Например, для строки `my_string`, чтобы вызвать метод `replace()`, мы можем написать `my_string.replace()`.

Аналогично, для **списка** `my_list`, чтобы вызвать метод `append()`, мы можем написать `my_list.append()`.

Методы могут **возвращать результаты**, такие как **новую строку** или **измененный список**, или они могут **изменять сам объект**, на котором они вызываются.

### 12.2 Методы списков.

1. Методы для **добавление элементов**:

- `my_lst.append(element)`: Добавляет элемент `element` в **конец списка**

  ```python
  # список чисел:
  numbers = [1, 2, 3]
  numbers.append(4)
  print(numbers)  # Вывод: [1, 2, 3, 4]

  # список строк:
  fruits = ['apple', 'banana']
  fruits.append('orange')
  print(fruits)  # Вывод: ['apple', 'banana', 'orange']

  # комбинированный список:
  mixed = [1, 'two', 3.0]
  mixed.append('four')
  print(mixed)  # Вывод: [1, 'two', 3.0, 'four']
  ```

- `my_lst.insert(index, element)`: Вставляет элемент `element` на позицию `index`

  ```python
  # список чисел:
  numbers = [1, 2, 4]
  numbers.insert(2, 3)
  print(numbers)  # Вывод: [1, 2, 3, 4]

  # список строк:
  fruits = ['apple', 'orange']
  fruits.insert(1, 'banana')
  print(fruits)  # Вывод: ['apple', 'banana', 'orange']

  # комбинированный список:
  mixed = [1, 'two', 3.0]
  mixed.insert(1, 'one')
  print(mixed)  # Вывод: [1, 'one', 'two', 3.0]
  ```

- `my_lst.extend(iterable)`: Добавляет элементы из итерируемого объекта `iterable` в **конец списка**

  ```python
  # список чисел:
  numbers = [1, 2]
  numbers.extend([3, 4])
  print(numbers)  # Вывод: [1, 2, 3, 4]

  # список строк:
  fruits = ['apple', 'banana']
  fruits.extend(['orange', 'grape'])
  print(fruits)  # Вывод: ['apple', 'banana', 'orange', 'grape']

  # комбинированный список:
  mixed = [1, 'two']
  mixed.extend([3.0, 'four'])
  print(mixed)  # Вывод: [1, 'two', 3.0, 'four']
  ```

2. Методы для **удаление элементов**:

- `my_lst.remove(element)`: Удаляет первое вхождение элемента `element` из списка

  ```python
  # список чисел:
  numbers = [1, 2, 3, 2]
  numbers.remove(2)
  print(numbers)  # Вывод: [1, 3, 2]

  # список строк:
  fruits = ['apple', 'banana', 'apple']
  fruits.remove('apple')
  print(fruits)  # Вывод: ['banana', 'apple']

  # комбинированный список:
  mixed = [1, 'two', 1]
  mixed.remove(1)
  print(mixed)  # Вывод: ['two', 1]
  ```

- `my_lst.pop(index)`: Удаляет и возвращает элемент по индексу `index`; если индекс не указан, удаляет последний элемент

  ```python
  # список чисел:
  numbers = [1, 2, 3]
  last = numbers.pop()
  print(last)  # Вывод: 3
  print(numbers)  # Вывод: [1, 2]

  # список строк:
  fruits = ['apple', 'banana', 'orange']
  last_fruit = fruits.pop()
  print(last_fruit)  # Вывод: orange
  print(fruits)  # Вывод: ['apple', 'banana']

  # комбинированный список:
  mixed = [1, 'two', 3.0]
  item = mixed.pop(1)
  print(item)  # Вывод: two
  print(mixed)  # Вывод: [1, 3.0]
  ```

- `my_lst.clear()`: Удаляет **все элементы** из списка

  ```python
  # список чисел:
  numbers = [1, 2, 3]
  numbers.clear()
  print(numbers)  # Вывод: []

  # список строк:
  fruits = ['apple', 'banana']
  fruits.clear()
  print(fruits)  # Вывод: []

  # комбинированный список:
  mixed = [1, 'two', 3.0]
  mixed.clear()
  print(mixed)  # Вывод: []
  ```

3. Методы для **копирования и подсчета**:

- `my_lst.copy()`: Создает поверхностную **копию списка**
  ```python
  # комбинированный список:
  mixed = [1, 'two', 3.0]
  copied_mixed = mixed.copy()
  print(copied_mixed)  # Вывод: [1, 'two', 3.0]
  ```
- `my_lst.count(element)`: Возвращает количество вхождений элемента `element` в списке
  ```python
  # список строк:
  fruits = ['apple', 'banana', 'apple']
  count_of_apples = fruits.count('apple')
  print(count_of_apples)  # Вывод: 2
  ```

4. Метод для **поиска и индексации**:

- `my_lst.index(element)`: Возвращает индекс **первого вхождения** элемента `element` в списке

  ```python
  # список чисел:
  numbers = [1, 2, 3]
  index_of_two = numbers.index(2)
  print(index_of_two)  # Вывод: 1

  # список строк:
  fruits = ['apple', 'banana', 'orange']
  index_of_banana = fruits.index('banana')
  print(index_of_banana)  # Вывод: 1

  # комбинированный список:
  mixed = [1, 'two', 3.0]
  index_of_two = mixed.index('two')
  print(index_of_two)  # Вывод: 1
  ```

5. Методы для **сортировки и реверса**:

- `my_lst.reverse()`: Разворачивает элементы списка в **обратном порядке**

  ```python
  # список чисел:
  numbers = [1, 2, 3]
  numbers.reverse()
  print(numbers)  # Вывод: [3, 2, 1]

  # список строк:
  fruits = ['apple', 'banana', 'orange']
  fruits.reverse()
  print(fruits)  # Вывод: ['orange', 'banana', 'apple']

  # комбинированный список:
  mixed = [1, 'two', 3.0]
  mixed.reverse()
  print(mixed)  # Вывод: [3.0, 'two', 1]
  ```

- `my_lst.sort(key=None, reverse=False)`: Сортирует элементы списка; можно указать функцию `key` и параметр `reverse`

  ```python
  # список чисел:
  numbers = [3, 1, 2]
  numbers.sort()
  print(numbers)  # Вывод: [1, 2, 3]

  # список строк:
  fruits = ['banana', 'apple', 'orange']
  fruits.sort()
  print(fruits)  # Вывод: ['apple', 'banana', 'orange']

  # комбинированный список: Для сортировки комбинированного списка нужно привести все элементы к одному типу.
  mixed = [1, "two", 3.0]
  mixed.sort()  # ошибка: TypeError: '<' not supported between instances of 'str' and 'int'
  print(mixed)
  ```

### 12.3 Методы меняющие начальный список:

- `append()`: Добавляет элемент в конец списка. Этот метод изменяет сам список.
- `insert()`: Вставляет элемент в указанное место списка. Этот метод изменяет сам список.
- `remove()`: Удаляет элемент по значению. Этот метод изменяет сам список.
- `pop()`: Удаляет последний элемент списка или элемент с указанным индексом. Этот метод изменяет сам список.
- `clear()`: Очищает список, удаляя все элементы. Этот метод изменяет сам список.
- `reverse()`: Меняет порядок следования элементов на обратный. Этот метод изменяет сам список.
- `sort()`: Сортирует элементы списка. Этот метод изменяет сам список.

### Вопросы:

1. Какой метод списка добавляет элемент в конец списка?
2. Какой метод списка вставляет элемент в указанное место списка?
3. Какой метод списка удаляет элемент по значению?
4. Какой метод списка удаляет последний элемент, либо элемент с указанным индексом?
5. Какой метод списка очищает список (удаляет все элементы)?
6. Какой метод списка возвращает копию списка?
7. Какой метод списка возвращает число элементов с указанным значением?
8. Какой метод списка возвращает индекс первого найденного элемента?
9. Какой метод списка меняет порядок следования элементов на обратный?
10. Какой метод списка сортирует элементы списка?

### Задачи:

1. Объявите в программе следующий список: `my_list = [10, 20, 30, 40, 50]`. Удалите число `20` из этого списка. Выведите `my_list` на экран.

2. На вход программе подается строка содержащая названия фруктов. Создайте список строк, содержащий эти названия. Добавьте строку 'груша' на вторую позицию. Выведите результат на экран. **Пример входящей строки**: `яблоко банан апельсин`.

3. На вход программе подается строка из слов через запятую и пробел. Создайте список из входяшей строки. Удалите последний элемент списка. Выведите на экран получившейся список и удаленный элемент.

4. Объявите в программе следующий список: `my_list = [1, 'два', 3.0]`. Добавьте в конец списка элементы из `second_list = [4, 'пять']`. Выведите результат на экран.

5. На вход программе подается строка, содержащая целые числа, записанные через пробел. Необходимо прочитать эти числа и сохранить в списке `my_lst` (как числа). Проверить, если первое число сформированного списка не равно последнему числу, то в список добавить значение `True`, а иначе - добавить значение `False`. Результирующий список `my_lst` вывести на экран.

6. Объявите в программе следующий список городов: `cities = ["Москва", "Казань", "Ярославль"]`. Необходимо вставить во вторую позицию (вторым элементом) этого списка строку `"Ульяновск"`. Выведите полученный список на экран.

7. На вход программы подается строка с номером телефона в формате: `+7(xxx)xxx-xx-xx`. Необходимо прочитать эту строку и преобразовать ее в список `lst` (посимвольно, то есть, элементами списка будут являться отдельные символы строки). Затем, удалить первый `'+'`, число `7` заменить на `8` и убрать дефисы. Отобразить полученный список на экране.

8. На вход программы подается строка с именем, отчеством и фамилией, записанными через пробел. Необходимо прочитать эту строку и представить прочитанные данные в виде новой строки в формате: `Фамилия И.О.`. Например, строка: `"Potnin Igor Vadimovich"` преобразуется в строку: `"Potnin I.V."`.

9. На вход программы подаются целые числа, записанные в одну строку через пробел (не менее четырех). Необходимо прочитать эти числа и среди них найти три наименьших числа. Выведите на экран найденные три числа в порядке возрастания в одну строчку через пробел.

10. На вход программы подаются целые числа, записанные в одну строку через пробел. Необходимо прочитать эти числа и сохранить их в списке `lst`. Удалите последнее значение из списка `lst` и если оно нечетное, то в список (в конец) добавьте булево значение `True`, а иначе `False`. Отобразите полученный список на экране.

11. Объявите в программе следующий список: `my_list = [10, 20, 30, 40, 50]`. Очистите список. Затем проверьте, пуст ли список `my_list`. Если `my_list` пуст выведите на экран `True`, иначе выведите `False`.

12. На вход программы подаются оценки студента (числа от 2 до 5), записанные в одну строку через пробел. Необходимо прочитать эти числа и сохранить их в списке. Определите количество двоек в сформированном списке и выведите это значение на экран.

## Урок 13. Вложенные списки. Многомерные списки.

### 13.1 Вложенные и многомерные списки.

**Многомерные списки** - это списки, **которые содержат другие списки в качестве своих элементов**. Они **используются** для представления структур данных с **более чем одним измерением**, таких как **матрицы** или **таблицы**. Каждый внутренний список представляет строку или столбец в многомерном списке.

**Вложенные списки** - это списки, которые содержат **другие списки в качестве элементов**. Они используются для **создания иерархических структур данных** или для **представления вложенных структур**, таких как **деревья** или **графы**. **Вложенные списки** могут иметь **различные уровни вложенности**, где каждый **внутренний список может содержать свои собственные элементы** или **другие вложенные списки**.

### 13.2 Отличия:

- **Структура данных**: **Вложенные** списки представляют собой **одномерные списки**, каждый элемент которых является другим списком. **Многомерные** списки - это списки, которые имеют **более одного измерения**, то есть представляют собой массивы с двумя или более индексами.
- **Доступ к элементам**: Для доступа к элементам вложенных списков используется **двойная индексация**, например `my_list[i][j]`. Для многомерных списков используется **столько индексов, сколько измерений имеет список**, например `my_list[i][j][k]`.
- **Создание**: Вложенные списки создаются путем **вложения одних списков в другие**. Многомерные списки создаются с помощью **вложенных списков, но с одинаковой длиной для каждого внутреннего списка**.
- **Использование**: Вложенные списки удобны для представления табличных данных, таких как матрицы или таблицы. Многомерные списки чаще используются для работы с многомерными массивами данных, например, в научных вычислениях или обработке изображений.

Чтобы получить **доступ к элементам** `многомерного` или `вложенного` списка, мы можем использовать синтаксис **индексов**.

**Пример многомерного списка**:

```python
# 3D-массив, который хранит информацию о температуре в разных городах по часам за несколько дней.
# Создание 3D-массива
temperature_data = [
    # День 1
    [
        # Час 1
        [22.5, 23.1, 21.8, 22.3],
        # Час 2
        [23.0, 23.5, 22.2, 22.7],
        # Час 3
        [23.2, 23.8, 22.5, 23.0]
    ],
    # День 2
    [
        # Час 1
        [21.8, 22.4, 21.2, 21.9],
        # Час 2
        [22.3, 22.9, 21.7, 22.4],
        # Час 3
        [22.6, 23.1, 22.0, 22.7]
    ],
    # День 3
    [
        # Час 1
        [20.5, 21.1, 19.9, 20.6],
        # Час 2
        [21.0, 21.6, 20.4, 21.1],
        # Час 3
        [21.3, 21.8, 20.7, 21.4]
    ]
]

# Получение температуры в городе 1, в 2-й час, 2-го дня
temp = temperature_data[1][1][0]
print(temp)  # Вывод: 22.3
```

**Пример вложенного списка**:

```python
# Во вложенном списке можем хранить информацию о студентах и их оценках по разным предметам.
students_grades = [
    ['Иван', [85, 92, 88, 90]],
    ['Мария', [92, 88, 85, 91, 90]],
    ['Петр', [80, 85, 82, 88]],
    ['Анна', [88, 90, 92, 87, 90]]
]

# Получение оценок Ивана
ivan_grades = students_grades[0][1]
print(ivan_grades)  # Вывод: [85, 92, 88, 90]

# Получение оценки Марии по 3-му предмету
maria_grade_3 = students_grades[1][1][2]
print(maria_grade_3)  # Вывод: 85
```

`**` Матрица - это структура данных, представляющая собой прямоугольную таблицу элементов, разделенных на строки и столбцы. Каждый элемент матрицы имеет свои координаты, обозначаемые индексами. Матрицы широко используются в математике, науке, программировании и других областях для представления и обработки данных.  
Матрицы могут содержать элементы различных типов данных, таких как числа, символы или даже другие структуры данных. Они могут быть одномерными (векторами), двумерными (матрицами) или иметь более высокую размерность.

### 13.3 Изменение вложенных списков:

```python
# Пример 1: Добавление элемента во вложенный список
matrix = [[1, 2, 3], [4, 5, 6]]

matrix[0].append(4)
print(matrix) # Результат: [[1, 2, 3, 4], [4, 5, 6]]

# Пример 2: Удаление элемента из вложенного списка
matrix[1].remove(5)
print(matrix) # Результат: [[1, 2, 3, 4], [4, 6]]

# Пример 3: Изменение элемента во вложенном списке
matrix[0][2] = 10
print(matrix) # Результат: [[1, 2, 10, 4], [4, 6]]

# Пример 4: Преобразование элементов во вложенном списке в строки
matrix[1] = [str(element) for element in matrix[1]]
print(matrix) # Результат: [[1, 2, 10, 4], ['4', '6']]

# Пример 5: Объединение элементов во вложенном списке в одну строку
joined_string = "".join(matrix[1])
print(joined_string) # Результат: '46'
```

### Вопросы:

1. Чем отличаются вложенные списки от многомерных списков в Python?
2. Как создать вложенный список в Python?
3. Как создать многомерный список с 3 измерениями в Python?
4. Как получить доступ к элементу вложенного списка, используя двойную индексацию?
5. Как получить доступ к элементу многомерного списка с 3 измерениями, используя тройную индексацию?
6. Можно ли изменять элементы вложенного и многомерного списка?
7. Имеется список: `a = [True, [1, 0, ["True", ["Истина", "Ложь"], "False"]], False]`. Как записать индексы, чтобы обратиться к элементу со значением "Истина"?
8. Имеется список: `a = [True, [1, 0, ["True", ["Истина", "Ложь"], "F"]], False]`. Какую команду следует выполнить, чтобы удалить элемент со значением "F"?

### Задачи:

1. Создайте вложенный список `grades` с оценками студентов **Аслана**, **Ивана**, **Марии** и **Фатимы**.
   Оценки:

   - Оценки Аслана: 11, 10, 11, 9
   - Оценки Ивана: 10, 10, 11, 10
   - Оценки Марии: 9, 10, 10, 12
   - Оценки Фатимы: 12, 10, 11, 10

   Выведите строку `"Имя_студента: первая_оценка и последняя_оценка"` для каждого студента.

1. Создайте вложенный список `grades` с оценками студентов **Аслана**, **Ивана**, **Марии** и **Фатимы**.
   Оценки:

   - Оценки Аслана: 11, 10, 11, 9
   - Оценки Ивана: 10, 10, 11, 10
   - Оценки Марии: 9, 10, 10, 12
   - Оценки Фатимы: 12, 10, 11, 10

     Добавьте каждому студенту в список оценок в конец списка средний бал студента.

1. Создайте вложенный список с числами `digits = [[1, 3, 5], [3, 5, 9], [4, 8, 12]]`. Добавьте четвертым элементом в список `digits` список из **сумм каждого вложенного списка**.

1. Создайте вложенный список с числами `digits = [[1, 3, 5], [3, 5, 9], [4, 8, 12]]`. Добавьте четвертым элементом в список `digits` новый список, который будет содержать произведения первых, вторых и третьих элементов из каждой из трех вложенных списокв. Например, первое произведение будет `1 * 3 * 4 = 12`.

1. В программе объявлен следующий список: `my_lst = [5.4, 6.7, 10.4]`. На вход программе подаются целые числа, записанные через пробел. Необходимо прочитать эти числа и сохранить в отдельном списке `digs`. Добавить в конец списка `my_lst` список `digs` отдельным элементом (как вложенный). Результирующий список `my_lst` вывести на экран.

1. На вход программе подаются четыре строки стихотворения (каждая с новой строки). Необходимо прочитать эти строки и каждую представить в виде отдельного списка слов (слова разделяются пробелом). Все полученные списки вложить в список `my_lst` и вывести его.  
   Пример строк для ввода:

   ```
   У лукоморья дуб зелёный
   Златая цепь на дубе том
   И днём и ночью кот учёный
   Всё ходит по цепи кругом
   ```

   Пример для вывода на экран:

   ```
   [['У', 'лукоморья', 'дуб', 'зелёный'], ['Златая', 'цепь', 'на', 'дубе', 'том'], ['И', 'днём', 'и', 'ночью', 'кот', 'учёный'], ['Всё', 'ходит', 'по', 'цепи', 'кругом']]
   ```

1. На вход программе подается матрица чисел из трех строк. В каждой строке числа разделяются пробелом. Необходимо прочитать эти числа и сохранить в виде двумерного (вложенного) списка. Затем, вывести на экран последний столбец этой матрицы (двумерного списка) в виде строки.  
   Пример строк для ввода:
   ```
    8 11 12 1
    9 4 36 -4
    1 12 49 5
   ```
   Пример для вывода на экран:
   ```
   1 -4 5
   ```

## Урок 14. Условный оператор if. Конструкция if-else.

### 14.1 Оператор `if`.

**Условный оператор** позволяет выполнять определенные действия в зависимости от **выполнения определенного условия**.

Он используется для принятия решений в программе и позволяет программе **выбирать различные пути выполнения в зависимости от значения переменных или других условий**.

**Синтаксис**:

```javascript
if условие:
    действие1
    действие2
    ...
```

**Пример**:

```python
# проверка числа на знак
x = 10

if x > 0:
    print("Число положительное")

# проверка суммы чисел в списке
digs = [5, 10, 15, 20, 25, 30]

if sum(digs) > 100:
    print(f"Сумма цифр в digs больше 100")

# проверка строки
role = input("Введите вашу роль: ")

if role.lower() == "Admin".lower():
    print("Вы вошли как Админ")
```

### 14.2 Отступы.

В `Python` **отступы** играют важную роль в **определении блоков кода**.  
Они используются для обозначения **группы инструкций, которые должны быть выполнены вместе**.

Отступы в `Python` **состоят из пробелов или табуляции и должны быть одинаковыми в пределах одного блока кода**.

Отступы определяют, **какие инструкции должны быть выполнены внутри блока кода, связанного с оператором `if`**.

Если отступы не правильно установлены, то возникнет **ошибка синтаксиса** или **неправильная интерпритация задуманного кода**.

```python
x = 10

if x > 0:
    print("Число положительное")
print("Это сообщение будет тут всегда!")
```

### 14.3 Оператор `in` в конструкции `if`.

**Оператор `in`** используется для **проверки наличия элемента в списке**. Он может быть использован в конструкции `if` для проверки, принадлежит ли значение переменной к определенному списку значений.

**Синтаксис**:

```javascript
if значение in последовательность:
    действие1
    действие2
    ...
```

**Пример использования оператора `in` с конструкцией `if`**:

```python
# проверка строки на наличие в ней буквы
my_str = "Моя строка"

if "а" in my_str:
    print(f"В строке '{my_str}' есть бука 'а'")

# проверка списка на наличие в нем цифры
digs = [5, 10, 15, 20, 25, 30]

if 10 in digs:
    print("В списке digs есть цифра 10")

# проверка списка на наличие в нем слова
fruits = ["яблоко", "банан", "груша"]

if "яблоко" in fruits:
    print("Это яблоко!")
```

### 14.4 Конструкция `if-else`.

**Конструкция if-else** позволяет программе принимать решения на основе выполнения условия.

**Блок else** в конструкции if-else **выполняется, когда условие в блоке if является ложным**. Он предоставляет альтернативный путь выполнения кода, **когда условие не выполняется**.

**Синтаксис**:

```javascript
if условие:
    действие1
    действие2
    ...
else:
    действие3
    действие4
    ...
```

**Пример**:

```python
# проверка числа
x = 10

if x > 0:
    print("Число положительное")
else:
    print("Число отрицательное или равно нулю")

# проверка строки
password = input("Введите пароль: ")
good_password = "233444"

if password == good_password:
    print("Вы вошли!")
else:
    print("Не правильный пароль!")

# проверка списка на наличие в нем слова
fruits = ["яблоко", "банан", "груша"]
word = "яблоко"

if word in fruits:
    print(f"В списке fruits есть слово {word}")
else:
    print(f"В списке fruits нет слова {word}")
```

### Вопросы:

1. Что такое оператор `if` в Python и для чего он используется?
2. Какой общий синтаксис оператора `if`?
3. Что произойдет, если условие в операторе `if` будет ложным?
4. Как можно использовать оператор `in` внутри условия `if`?
5. Что такое конструкция `if-else` в Python и как она работает?
6. Что произойдет, если условие в операторе `if` будет истинным в конструкции `if-else`?
7. Что произойдет, если условие в операторе `if` будет ложным в конструкции `if-else`?
8. Как отступы влияют на код в Python?

### Задачи:

1. На вход программе подается число. Напишите программу, которая проверяет, является ли это число **положительным** или **отрицательным или равно нулю**. Если число положительное на экран вывести строку `Число положительное`, в противном случае на экран вывести сообщение `Число отрицательное или равно нулю`.

2. На вход программе подается строка из чисел `digits_str`, записанных через пробел. Создайте список `digits_lst` с числами из строки `digits_str`. Напишите программу, которая проверяет, есть ли в списке число `7`. Если число `7` будет в списке на экран вывести сообщение `В списке есть число 7!`, в противном случае вывести сообщение `Числа 7 в списке нет!`.

3. На вход программе подается строка `my_str`. Напишите программу, которая проверяет, содержит ли строка `my_str` слово `Python`. Если слово `Python` присутствует в `my_str` выведите на экран сообщение `Слово Python есть в строке!`, в противном случае вывести сообщение `Такого слова в строке нет!`. Пример входящей строки: `JavaScript, C++, Python`.

4. На вход программе подаются два вещественных числа, записанных в одну строку через пробел. Необходимо их прочитать и вывести на экран наибольшее из этих чисел. Задачу решить с помощью условного оператора. Записать переменные можно с помощью: `a, b = map(float, input().split())`.

5. На вход программе подается строка со словом. Необходимо его прочитать и определить, является ли это слово палиндромом (одинаково читается вперед и назад, например, АННА). Регистр букв не учитывать, т.е. Анна, анна, аННА - это все должно определяться, как палиндромы. Если введенное слово палиндром, на экран вывести `ДА`, иначе `НЕТ`.

6. На вход программе подаются два целых положительных числа, записанных в одну строку через пробел. Необходимо прочитать эти числа в переменные `m` и `n` (в порядке считывания). Определить, если число m делится нацело на число n, то вывести на экран результат деления в виде целого числа. В противном случае вывести сообщение `m на n нацело не делится` и вместо m и n подставить соответствующие числа, например: `13 на 2 нацело не делится`. Записать переменные можно с помощью: `m, n = map(int, input().split())`.

7. На вход программе подаются три целых положительных числа, записанных в одну строку через пробел. Необходимо прочитать эти числа и убедиться, что первые два числа - это катеты прямоугольного треугольника, а третье - его гипотенуза. Если проверка проходит (истина), то вывести на экран `ДА`, иначе `НЕТ`. Записать переменные можно с помощью: `a, b, c = map(int, input().split())`.

8. На вход программе подается четырехзначное число, которое нужно прочитать из входного потока. Проверить, что это число оканчивается на цифру 7. Вывести на экран `ДА`, если это так, и `НЕТ` в противном случае.

9. На вход программе подается слово. Необходимо прочитать это слово и проверить, что в нем присутствуют все три буквы: t, h и o (в произвольном порядке и хотя бы в одном экземпляре). Реализовать программу следует с помощью одного условного оператора. Если искомая проверка проходит, вывести `ДА`, иначе `НЕТ`.

10. На вход программе подается строка из названий городов, записанных через пробел. Необходимо прочитать эту строку и сформировать на ее основе список `cities` из названий городов. Затем, проверить, если в списке `cities` присутствует город `Москва`, то удалить этот элемент из списка. Вывести на экран результирующий список `cities`. **Пример входящей строки**: `Москва Санкт-Петербург Казань Нальчик`

11. На вход программе подается шестизначное число. Необходимо его прочитать и определить, является ли это число **счастливым**. (Счастливым называют такое шестизначное число, в котором сумма его **первых трех цифр** **равна** **сумме последних трех его цифр**). Вывести `ДА`, если число счастливое, и `НЕТ` в противном случае.

## Урок 15. Вложенные условия и множественный выбор. Конструкция if-elif-else.

### 15.1 Вложенные условия.

**Вложенное условие** - это конструкция, в которой одно условие находится **внутри** другого.

Оно позволяет **проверять несколько условий последовательно и выполнять соответствующий блок кода** в зависимости от результата каждого условия.

**Пример**: проверяем, является ли число **положительным**, **отрицательным** или **нулем**, и затем проверяем, **четное** оно или **нечетное**:

```python
number = int(input("Введите целое число: "))

# Проверяем, больше ли число нуля. Если да, выводим, что число положительное.
if number > 0:
    print("Число положительное.")
    # Вложенное условие проверяет, четное ли число.
    if number % 2 == 0:
        print("Число четное.")
    else:
        print("Число нечетное.")
else:
    # Проверяем, меньше ли число нуля. Если да, выводим, что число отрицательное
    if number < 0:
        print("Число отрицательное.")
        # Проверяем, четное ли оно.
        if number % 2 == 0:
            print("Число четное.")
        else:
            print("Число нечетное.")
    else:
        # Если число равно нулю, выводим соответствующее сообщение.
        print("Число равно нулю.")
```

### 15.2 Нахождение наибольшего среди трех чисел с помощью вложенных условий.

```python
# нахождение максимального значения среди трех переменных
a = int(input("Введите число a: "))
b = int(input("Введите число b: "))
c = int(input("Введите число c: "))

if a >= b:
    if a >= c:
        print("Наибольшее число: ", a)
    else:
        print("Наибольшее число: ", c)
else:
    if b >= c:
        print("Наибольшее число: ", b)
    else:
        print("Наибольшее число: ", c)

# нахождение максимального значения в списке
numbers = [10, 20, 30]

if numbers[0] >= numbers[1]:
    if numbers[0] >= numbers[2]:
        print("Наибольшее число: ", numbers[0])
    else:
        print("Наибольшее число: ", numbers[2])
else:
    if numbers[1] >= numbers[2]:
        print("Наибольшее число: ", numbers[1])
    else:
        print("Наибольшее число: ", numbers[2])


# нахождение максимального значения в списке с помощью создания промежуточной переменной
numbers = [10, 25, 15]

max_number = numbers[0]

if max_number < numbers[1]:
    max_number = numbers[1]
    if max_number < numbers[-1]:
        max_number = numbers[-1]
else:
    if max_number < numbers[-1]:
        max_number = numbers[-1]

print(max_number)
```

### 15.3 Множественный выбор. Конструкция if-elif-else.

**Множественный выбор** - это ситуация, когда необходимо **выполнить различные действия в зависимости от значения переменной или условия**.

В Python для реализации **множественного выбора** используется **конструкция `if-elif-else`**.

Конструкция `if-elif-else` позволяет **проверять несколько условий последовательно** и **выполнять соответствующий блок кода**, соответствующий первому истинному условию.  
**Если ни одно из условий не является истинным**, выполняется блок кода, связанный с **else**.

- **Пример**: проверяем, является ли число **положительным**, **отрицательным** или **равным нулю**:

  ```python
  num = int(input("Введите число: "))

  if num > 0:
      print("Число положительное")
  elif num < 0:
      print("Число отрицательное")
  else:
      print("Число равно нулю")
  ```

- **Пример**: определяем день недели по номеру.

  ```python
  day_number = int(input())

  if day_number == 1:
      print("Понедельник")
  elif day_number == 2:
      print("Вторник")
  elif day_number == 3:
      print("Среда")
  elif day_number == 4:
      print("Четверг")
  elif day_number == 5:
      print("Пятница")
  elif day_number == 6:
      print("Суббота")
  elif day_number == 7:
      print("Воскресенье")
  else:
      print("Некорректный номер дня.")
  ```

### 15.4 Операторы `and`, `or`, `not` в условном операторе.

Операторы `and`, `or` и `not` позволяют **комбинировать условия** в конструкциях `if`, `elif` и `else`.

#### Оператор `not`:

- **В этом примере** используется оператор `not`, чтобы проверить, **не идет ли дождь**. Если дождя нет, выводится сообщение о том, **что можно выйти на улицу**.

  ```python
    is_raining = False

    if not is_raining:
        print("Можно выйти на улицу.")
    else:
        print("Лучше остаться дома.")
  ```

- **В этом примере** мы проверяем, **вошел ли пользователь в систему**. Если нет, выводится просьба войти.

  ```python
  is_logged_in = False

  if is_logged_in:
      print("Добро пожаловать!")
  elif not is_logged_in:
      print("Пожалуйста, войдите в систему.")
  ```

#### Оператор `and`:

- **В этом примере** проверяется два условия: **возраст должен быть 18 лет** или больше, и у **человека должна быть лицензия**. Если оба условия истинны, выводится сообщение о том, что человек может управлять автомобилем.

  ```python
  age = 25
  has_license = True

  if age >= 18 and has_license:
      print("Вы можете управлять автомобилем.")
  else:
      print("Вы не можете управлять автомобилем.")
  ```

- **В этом примере** мы используем оператор `and` в первом условии и `not` во втором. Если температура выше `25` градусов и солнечно, выводится сообщение о пикнике. Если температура выше `25`, но не солнечно, выводится предупреждение о зонте.

  ```python
  temperature = 30
  is_sunny = True

  if temperature > 25 and is_sunny:
      print("Идеальная погода для пикника!")
  elif temperature > 25 and not is_sunny:
      print("Погода хорошая, но не забудьте взять зонт.")
  else:
      print("Лучше остаться дома.")
  ```

#### Оператор `or`:

- **В этом примере** проверяется, является ли **день выходным** или **праздничным**. Если хотя бы одно из условий истинно, выводится сообщение о том, что **можно отдохнуть**.

  ```python
  is_weekend = True
  is_holiday = False

  if is_weekend or is_holiday:
      print("Можно отдохнуть!")
  else:
      print("Время работать.")
  ```

- **В этом примере** мы используем оператор `or` в условии `elif`. Если оценка `75` или выше, или равна `85`, выводится сообщение о хорошем результате.

  ```python
  score = 85

  if score >= 90:
      print("Отлично!")
  elif score >= 75 or score == 85:
      print("Хорошо!")
  else:
      print("Нужно улучшить результат.")
  ```

#### Использования операторов `and`, `or`, `not` вместе:

- **В этом примере** мы комбинируем все три оператора. Если возраст 18 лет или больше и есть разрешение, или если не солнечно, выводится сообщение о том, что можно выйти на улицу. В противном случае выводится сообщение о том, что лучше остаться дома.

  ```python
  age = 20
  has_permission = True
  is_sunny = False

  if (age >= 18 and has_permission) or (not is_sunny):
      print("Вы можете выйти на улицу.")
  else:
      print("Оставайтесь дома.")
  ```

### Вопросы:

1. Что такое вложенные условия в Python и как они работают?
2. Что такое конструкция `if-elif-else` и в чем ее отличие от простого `if-else`?
3. Как можно использовать конструкцию `if-elif-else` для проверки, является ли число положительным, отрицательным или нулем?
4. Какой блок коды выполниться, если ни одно из нескольких условий конструкции `if-elif-else` не выполнилось?
5. Как можно использовать логические операторы (and, or, not) в условиях? Приведите пример, где используются логические операторы для проверки нескольких условий одновременно.

### Задачи:

1. Напишите программу, которая запрашивает у пользователя целое число и проверяет, является ли оно положительным, отрицательным или нулем.

2. Напишите программу, которая запрашивает у пользователя целое число и выводит, является ли оно четным или нечетным.

3. Напишите программу, которая запрашивает у пользователя номер дня недели (от 1 до 7) и выводит название дня (например, 1 - Понедельник, 2 - Вторник и т.д.)

4. На вход программе подается строка из трех чисел записанных через пробел. Напишите программу, которая находит наибольшее из них.

5. Напишите программу, которая запрашивает у пользователя количество баллов (от 0 до 100) и выводит оценку: "Отлично", если баллы 90 и выше; "Хорошо", если 75-89; "Удовлетворительно", если 60-74; "Неудовлетворительно", если менее 60.

6. Напишите программу, которая запрашивает у пользователя номер месяца (от 1 до 12) и выводит, к какому времени года он относится (зима, весна, лето, осень).

7. Напишите программу, которая запрашивает у пользователя три длины сторон и определяет, может ли существовать треугольник с такими сторонами.

8. Напишите программу, которая реализует простой калькулятор. Запрашивает у пользователя два числа и оператор (+, -, \*, /). Обработайте возможные ошибки, такие как деление на ноль.

9. На вход программе подается вещественное число: номер меню программы. Прочитайте это число и выведите соответствующий пунк меню на экран. Пункты меню:

   ```
   1. Введение в Python
   2. Строки и списки
   3. Условные операторы
   4. Циклы
   5. Словари, кортежи и множества
   6. Выход
   ```

10. На вход программе подается вещественное число: вес боксера-любителя (в кг). Прочитайте это число и определите номер категории, в которой будет выступать боксер. Боксер может быть отнесен к одной из следующих весовых категорий:

    ```
      1 - легкий вес – до 60 кг (включительно);
      2 - первый полусредний вес – до 64 кг (включительно);
      3 - полусредний вес – до 69 кг (включительно);
      4 - тяжелый вес - более 69 кг.
    ```

11. На вход программе подается целое число k (1 <= k <= 365). Прочитайте это число и определите, каким днем недели (понедельник, вторник, среда, четверг, пятница, суббота или воскресенье) является k-й день не високосного года, в котором 1 января является понедельником.

12. На вход программе подаются два целых числа, записанных через пробел.
    Необходимо прочитать эти числа по порядку в переменные m (порядковый номер месяца) и n (число, день месяца).
    Затем, по переменным m и n определить:

- дату предыдущего дня (принять, что m и n не могут являться 1 января);
- дату следующего дня (принять, что m и n не могут являться 31 декабря).

  В задаче принять, что год не является високосным. Вывести предыдущую дату и следующую дату (в формате: mm.dd, где m - число месяца; d - номер дня) в одну строчку через пробел.
  Число дней в месяцах не високосного года, начиная с января: `31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31`.

## Урок 16. Тернарный условный оператор

### 16.1 Тернарный условный оператор.

**Тернарный условный оператор** - это специальный оператор, который позволяет **сократить запись условного выражения в одну строку**.

Он имеет следующий синтаксис:

```
<выражение1> if <условие> else <выражение2>
```

Он выполняет следующее действие: **если условие истинно, то возвращается значение выражения1, иначе возвращается значение выражения2**.

Например, если вы хотите присвоить переменной `x` значение 1, если условие истинно, и значение `0` в противном случае, вы можете записать следующее:

```
x = 1 if условие else 0
```

**Пример использования тернарного условного оператора**:

```python
x = 10
result = "Число положительное" if x > 0 else "Число неположительное"
print(result)  # Вывод: Число положительное
```

**Та же запись с использованием оператора if-else**:

```python
x = 10
if x > 0:
  result = "Число положительное"
else:
  result = "Число неположительное"
print(result)
```

**Результат работы** тернарного оператора, обычно, **сохраняем в переменной**.

```python
a = 3
b = 4
res = a + 2 if a > b else b - 5
print(res)
```

Внутри тернарного оператора может быть **любая конструкция** языка Python, но только одна!
Для примера мы можем даже вернуть результат работы функции `print()`

```python
a = 3
b = 4
res = print(a) if a > b else print(b)
print(res)
```

Но результатом таких действий будет `None`, так как функция `print()` ничего не возвращает.

Тернарный оператор **можно вызывать** прямо **внутри различных конструкций**,  
**Например**:

```python
z = -3
print("Число положительное" if z > 0 else "Число неположительное")  # Вывод: Число неположительное

a = 2
str = f"a - {'четное' if a % 2 == 0 else 'нечетное'} число"
print(str)
```

### 16.2 Вложенный тернарный оператор.

**Вложенное тернарное условие** - это использование **одного тернарного оператора внутри другого**.  
Это позволяет нам создавать **более сложные условия** и возвращать различные значения **в зависимости от результатов этих условий**.
**Например**:

```python
x = 10
result = "больше 5" if x > 5 else ("равно 5" if x == 5 else "меньше 5")
print(result)

value = 0
result = "Положительное" if value > 0 else "Отрицательное" if value < 0 else "Ноль"
print(result)  # Вывод: Ноль
```

Вложенные тернарные условные операторы **могут быть полезны, когда у нас есть несколько вариантов условий**, которые нужно проверить и вернуть разные значения в зависимости от этих условий.

### Вопросы:

1. Что такое тернарный условный оператор?
2. Каков синтаксис тернарного условного оператора?
3. В чем разница между обычным условным оператором `if` и тернарным оператором?
4. Сколько возвращаемых конструкций может быть внутри тернарного оператора?
5. Что такое вложенный тернарный оператор?
6. Каковы потенциальные недостатки использования тернарного оператора по сравнению с обычными конструкциями `if-else`?
7. Можно ли использовать функции (например `print()`) внутри тернарного оператора?

### Задачи:

1. На вход программе подается целое число. Напишите программу, которая использует тернарный оператор для проверки, является ли число положительным или отрицательным. Выведите соответствующее сообщение.

2. На вход программе подается строка. Создайте переменную name и присвойте ей значение из этой строки. Используйте тернарный оператор, чтобы вывести "Привет, [имя]" если строка не пустая, и "Привет, незнакомец", если строка пустая.

3. Напишите программу, которая проверяет, является ли элемент списка my_list = [1, 2, 3] пустым. Используйте тернарный оператор для вывода "Список не пустой" или "Список пустой".

4. На вход программе подается целое число. Создайте переменную age и присвойте ей значение этого числа. Используйте тернарный оператор, чтобы вывести "Взрослый" если возраст больше или равен 18, и "Несовершеннолетний" в противном случае.

5. На вход программе подается дробное число. Создайте переменную temperature и присвойте ей это число. Используйте тернарный оператор, чтобы вывести "Тепло", если температура выше 20 градусов, "Комфортно", если больше 15 градусов и "Холодно" в остальных случаях.

6. На вход программе подаются два вещественных числа, каждое с новой строки. Необходимо их прочитать и с помощью тернарного условного оператора вычислить наибольшее среди них и присвоить переменной `d`. Полученное значение переменной `d` вывести на экран.

7. На вход программе подается целое число. Необходимо его прочитать и переменной msg присвоить строку: `"кратно 3"`, если введенное число кратно 3 или `"не кратно 3"`, если введенное число не кратно 3. Программу реализовать с использованием тернарного оператора. Значение переменной msg вывести на экран.

8. На вход программе подается слово (строка). Необходимо ее прочитать и переменной msg присвоить строку "палиндром", если введенное слово является палиндромом (одинаково читается и вперед и назад), иначе присвоить строку "не палиндром". Проверку на палиндром проводить без учета регистра. Программу реализовать с помощью тернарного условного оператора. Значение переменной msg отобразить на экране.

9. На вход программе подается целое число 0 или 1. Необходимо его прочитать и преобразовать в строку по правилу: если число 0 вернуть строку "False", если число равно 1 вернуть строку "True". Программу реализовать с помощью тернарного условного оператора. Результат (строку) отобразить на экране.

10. На вход программе подается целое число: текущее время (секунды) в диапазоне `[0; 59]`. Необходимо его прочитать и вычислить следующее за ним значение в секундах с учетом границ диапазона `[0; 59]`. То есть, если прочитанное значение равно 59, то следующее должно быть равно 0. И так по кругу. Реализуйте программу с помощью тернарного условного оператора. Результат (следующее значение) отобразите на экране.

11. Напишите программу, которая принимает три числа от пользователя и использует вложенный тернарный оператор для определения наибольшего из них. Выведите наибольшее число.

## Урок 17. Циклы в Python. Цикл While

### 17.1 Циклы в Python.

**Циклы в программировании** - это конструкции, которые позволяют выполнять **повторяющиеся действия**.  
Они позволяют **автоматизировать выполнение определенных задач**, которые требуют **повторения одного и того же кода несколько раз**.

### 17.2 Зачем нужны циклы?

**Циклы** позволяют нам **выполнять один и тот же блок кода несколько раз**, что делает программы **более эффективными и гибкими**.  
Они позволяют **обрабатывать** **большие объемы данных**, **выполнять итерации по элементам списка или массива**, а также **повторять действия до тех пор, пока выполняется определенное условие**.

### 17.3 Примеры циклов на языке программирования Python.

1. Цикл `for`

```python
numbers = [1, 2, 3, 4, 5]
for num in numbers:
    print(num)
```

2. Цикл `while`

```python
count = 0
while count < 5:
    print(count)
    count += 1
```

### 17.4 Цикл `While`

Цикл `while` в Python позволяет выполнять **повторяющиеся действия до тех пор, пока выполняется определенное условие**.

**Синтаксис**:

```
while условие: <= заголовок цикла
    тело цикла
```

- **Условие**: это выражение, которое проверяется перед каждой итерацией цикла. Если условие истинно, то выполняется заголовок и тело цикла. Если условие ложно, то выполнение цикла прекращается и программа продолжает выполняться после цикла.
- **Заголовок цикла**: это блок кода, который выполняется перед каждой итерацией цикла. Обычно в заголовке цикла происходит инициализация переменных, которые используются в условии цикла.
- **Тело цикла**: это блок кода, который выполняется при каждой итерации цикла. В теле цикла можно выполнять нужные действия, например, обработку данных или изменение значений переменных.

### 17.5 Цикл `while` для нахождения суммы

```python
N = 10
sum = 0
i = 1

while i <= N:
    sum = sum + i
    i = i + 1

print("Сумма чисел от 1 до", N, ":", sum)
```

В этом примере мы **инициализируем переменные** `N`, `sum` и `i`.  
Затем мы используем цикл `while`, чтобы при каждой итерации добавлять значение `i` к сумме `sum` и увеличивать `i` на 1.  
Цикл продолжается, пока `i` не станет больше `N`.  
После окончания цикла мы выводим на экран сумму чисел от **1 до N**.

### 17.6 Условия в цикле. Итерация.

**Итерация** - Однократное выполнение тела цикла.

В цикле **while** можно прописывать различные условия. Условие должно быть **выражением, которое возвращает логическое значение `True` или `False`**. **Цикл будет выполняться, пока условие остается истинным (`True`)**. **Когда условие становится ложным (`False`), выполнение цикла прекращается**.

**Примеры условий**, которые можно прописывать в цикле `while`:

- **Сравнение чисел**: `x < y`, `x <= y`, `x > y`, `x >= y`, `x == y`, `x != y`.
- **Логические операции**: `and`, `or`, `not`.
- **Использование функций**: `len(some_list) > 0`, `is_valid(input)`.
- **Использование переменных**: `count < max_count`, `total_sum != 100`.

### 17.7 Цикл `while` для проверки пароля пользователя.

```python
password = input("Введите пароль: ")

while password != "good_pass":
    print("Неверный пароль. Попробуйте еще раз.")
    password = input("Введите пароль: ")

print("Доступ разрешен. Добро пожаловать!")
```

### Вопросы:

1. Что такое циклы в программировании?
2. Какие циклы есть в Python?
3. Какие условия можно прописывать в цикле While?
4. Что такое Заголовок цикла?
5. Что такое Тело Цикла?
6. Что такое Итерация?

### Задачи:

1. На вход программы подаются два целых положительных числа `n` и `m`, записанных через пробел, причем, `n` < `m`. Необходимо прочитать эти числа и вывести в одну строку через пробел квадраты целых чисел в диапазоне `[n; m]`. Программу реализовать при помощи цикла `while`.

2. На вход программы подается вещественное число: стоимость одной книги `x` рублей. Необходимо прочитать это число и вывести на экран в одну строчку через пробел стоимости `2`, `3`, ... `10-ти` таких книг с точностью до десятых. Программу реализовать при помощи цикла while.

3. На вход программы подается целое положительное число `n`. Прочитайте это число, а затем, вычислите и выведите на экран следующую сумму с точностью до тысячных (три знака после запятой): `S = 1 + 1/2 + 1/3 + ... + 1/N`. Программу реализовать при помощи цикла `while`.

4. Написать программу, в которой пользователь на каждой итерации цикла (`while`) должен вводить целое число. Цикл должен продолжаться, пока пользователь не введет число `0`. Необходимо вычислить сумму введенных в цикле чисел и вывести результат (`сумму`) на экран. Программу реализовать при помощи цикла `while`.

5. На вход программе подается строка (слаг). Прочитайте эту строку и замените в ней все подряд идущие дефисы (`--`, `---`, `----` и т.д.) на одинарные (`-`). Результат преобразования строки выведите на экран. Программу реализовать при помощи цикла `while`. Пример входящей строки: `osnovnye--metody-----spiska`.

6. На вход программе подается натуральное число (то есть, целое положительное) от трехзначного и более. Необходимо прочитать это число и найти произведение всех его цифр. Результат (произведение) вывести на экран. Программу реализовать при помощи цикла `while`.

7. Последовательность Фибоначчи образуется так: первые два числа равны `1` и `1`, а каждое последующее равно сумме двух предыдущих. В итоге, получаем такую последовательность чисел: `1, 1, 2, 3, 5, 8, 13, ...` На вход программе подается целое положительное число `n`. Прочитайте это число и сформируйте последовательность Фибоначчи длиной `n`. Например, при `n = 4` получается последовательность: `1 1 2 3`. Результат отобразите в виде строки полученных чисел, записанных через пробел. Программу реализовать при помощи цикла `while`.

8. На вход программе подается целое положительное число (количество часов). Прочитайте это число и сохраните в переменной `n`. Пусть одноклеточная амеба каждые `3 часа` делится на `2 клетки`. Необходимо определить, сколько клеток будет через `n` часов. Считать, что изначально была одна амеба. Результат (итоговое число клеток) вывести на экран. Задачу необходимо решить с использованием цикла while. Если пользователь ввел `11` результат будет `8`.

9. Гражданин 1 января открыл счет в банке, вложив `1000 руб`. Каждый год размер вклада увеличивается на `5%` от имеющейся суммы. Определить сумму вклада через `n` лет (n - целое положительное число, читаемое из входного потока). Результат (сумму вклада) округлить до сотых и вывести на экран. Программу реализовать при помощи цикла `while`.

10. На вход программе подаются два натуральных четных числа `n` и `m`, записанных в одну строчку через пробел, причем `n < m`. Необходимо прочитать эти числа и напечатать все нечетные числа из интервала от `n` до `m`. Задачу следует решить без применения условного оператора. Результат вывести на экран в виде строки чисел, записанных через пробел. Программу реализовать при помощи цикла `while`.

11. Составить программу поиска всех трехзначных чисел, которые при делении на `47` дают в остатке `43` и кратны `3`. Вывести найденные числа в одну строчку через пробел в порядке возрастания. Программу реализовать при помощи цикла `while`.

## Урок 18. Цикл for

### 18.1 Цикл for в Python

**Цикл `for` в Python** используется для **итерации по последовательности элементов**, таких как **строки**, **списки**, **кортежи** и другие. Он позволяет **выполнять определенный блок кода для каждого элемента в последовательности**.

**Итерации по последовательности проходят с помощью оператора `in`**. Он позволяет выполнять определенный блок кода для каждого элемента в последовательности.

**Синтаксис цикла `for` с использованием оператора `in` выглядит следующим образом**:

```
for элемент in последовательность:
    # выполняемые действия
```

- `элемент` - переменная, которая будет принимать значение каждого элемента из последовательности на каждой итерации цикла.
- `последовательность` - итерируемый объект, такой как список, строка, кортеж или другой объект, по которому будет происходить итерация.

**Примеры использования цикла `for`**:

1. Пример использования цикла `for` для итерации по списку чисел и вывода каждого числа плюс два:
   ```python
   numbers = [10, 40, 20, 30]
   for item in numbers:
       print(item + 2)
   ```
2. Пример использования цикла `for` с функцией `range()` для итерации по диапазону чисел:

   ```python
   for i in range(1, 6):
       print(i)
   ```

3. Пример использования цикла `for` для итерации по строке и вывода каждого символа:

   ```python
   word = "Hello"
   for char in word:
       print(char)
   ```

4. Пример использования цикла `for` с оператором `enumerate()` для получения индекса и значения элемента:
   ```python
   fruits = ["apple", "banana", "cherry"]
   for index, fruit in enumerate(fruits):
       print("Index:", index, "Fruit:", fruit)
   ```

### 18.2 Функция `range()` в цикле `for`

**Функция `range()`** в цикле for используется для создания **последовательности чисел**, которые могут быть использованы для итерации в цикле.

**Функция `range()` создает последовательность чисел в заданном диапазоне**. Функция `range()` возвращает объект диапазона, который представляет последовательность чисел.

```python
r = range(9)
lst = list(r)
print(lst)
```

### 18.3 Примеры использования range():

1. Функция `range()` может быть вызвана с **одним аргументом**, который указывает на **конечное значение диапазона**. **Начальное значение** по умолчанию равно `0,` а **шаг** равен `1`.

   ```python
   for i in range(5):
       print(i)
   ```

2. Функция `range()` может быть вызвана с **двумя аргументами**, которые указывают на **начальное** и **конечное** **значения диапазона**. **Шаг** по умолчанию равен `1`.

   ```python
   for i in range(2, 8):
       print(i)
   ```

3. Функция `range()` может быть вызвана с **тремя аргументами**, которые указывают на **начальное**, **конечное** значения диапазона и **шаг**. Шаг определяет, **какое значение будет добавлено или вычитано на каждой итерации**.
   ```python
   for i in range(1, 10, 2):
       print(i)
   ```

### 18.4 for + range() + len()

**Универсальный проход по списку любой длины с помощью** `цикла for`, `range()` и `len()` можно осуществить следующим образом:

```python
lst = [1, 2, 3, 4, 5]

for i in range(len(lst)):
    element = lst[i]
    print(element)
```

### 18.5 Отличия циклов for и while.

Циклы `for` и `while` являются **двумя основными типами циклов в языке программирования**.

#### Цикл for

- `Отличия`: Цикл `for` используется **для итерации по последовательности элементов**, такой как **список**, **строка** или **диапазон чисел**. Он выполняет **заданный блок кода для каждого элемента в последовательности**.
- `Применение`: Цикл `for` обычно используется, когда **мы заранее знаем количество итераций или когда нам нужно выполнить определенные действия для каждого элемента в последовательности**.

```python
# Пример 1: Итерация по списку
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)

# Пример 2: Итерация по диапазону чисел
for i in range(1, 5):
    print(i)
```

В первом примере мы используем цикл `for` для **итерации по списку `fruits`** и выводим каждый элемент на экран. Во втором примере мы используем цикл `for` и функцию `range()` для итерации по диапазону чисел от 1 до 4 и выводим каждое число на экран.

#### Цикл while

- `Отличия`: Цикл `while` выполняет заданный блок кода **до тех пор, пока условие истинно**. Он **проверяет условие перед каждой итерацией**.
- `Применение`: Цикл `while` обычно используется, когда мы **не знаем заранее, сколько итераций будет выполнено, и мы хотим продолжать выполнение до тех пор, пока условие истинно**.

```python
# Пример 1: Итерация с использованием счетчика
count = 0
while count < 5:
    print(count)
    count += 1

# Пример 2: Итерация с использованием условия
number = 10
while number > 0:
    print(number)
    number -= 2
```

В первом примере мы используем цикл `while` с **переменной-счетчиком `count`**, чтобы выполнить итерацию **пять раз** и **вывести значение счетчика на экран**. Во втором примере мы используем цикл `while` с условием, чтобы **выполнить итерацию, пока значение переменной `number` больше `0`**, и выводим значение на экран, **уменьшая его на `2` на каждой итерации**.

**Циклы `for` и `while` имеют разные сценарии использования, и выбор между ними зависит от конкретной задачи и требований программы.**

### Вопросы:

1. Что такое цикл `for` в Python и как он работает?
2. Для чего используется функция `range()` в цикле `for`?
3. Какую роль выполняет функция `len()` в цикле `for`? Приведите пример кода.
4. Как можно использовать цикл `for` для перебора элементов списка?
5. Чем отличается цикл `for` от цикла `while`?
6. Объясните, что происходит в следующем коде и что будет выведено:
   ```python
   numbers = [10, 20, 30, 40]
   for i in range(len(numbers)):
       print(i, numbers[i])
   ```

### Задачи:

1. Используя функцию `range()` и `list()`, создайте список целых чисел `0, 1, 2, ..., 10`. Выведите на экран список.

2. Используя функцию `range()` и `list()`, создайте список целых чисел `-10, -9, -8, ..., 0`. Выведите на экран список.

3. Используя функцию `range()` и `list()`, создайте список целых чисел `-10, -8, -6, -4, -2`. Выведите на экран список.

4. Напишите программу, которая с помощью цикла `for` находит сумму всех четных чисел от `1` до `100` включительно.

5. Напишите программу, которая создает новый список, содержащий квадраты всех чисел от `1` до `10` с использованием цикла `for`.

6. На вход программе подаются целые числа, записанные в одну строчку через пробел. Необходимо прочитать эти числа и сохранить в списке (в виде чисел, а не строк). Затем, с помощью цикла `for` перебрать полученный список и просуммировать все нечетные значения. Результат (сумму) вывести на экран.

7. На вход программе подается целое число `n`. Напишите программу, которая с помощью цикла `for` вычисляет факториал числа, введенного пользователем. (Факториал - Произведение всех чисел от `1` до `n`)

8. На вход программе подается строка с названиями городов, записанных в одну строчку через пробел. Необходимо прочитать эту строку и сформировать список из названий городов. Затем, перебрать полученный список циклом `for` и заменить названия городов на длины их строк. Результат вывести на экран в виде последовательности чисел через пробел в одну строчку. Пример входящей строки: `Москва Уфа Караганда Тверь Минск Казань`

9. На вход программе подается строка. Напишите программу, которая подсчитывает количество гласных букв в введенной пользователем строке. Для решения используйте цикл `for`.

10. На вход программе подаются целые числа, записанные в одну строчку через пробел. Необходимо прочитать эти числа и сохранить в списке (в виде чисел, а не строк). Напишите программу, которая выводит элементы этого списка в обратном порядке с использованием цикла `for` (не используя встроенную функцию reversed()).

11. На вход программе подаются целые числа, записанные в одну строчку через пробел. Необходимо прочитать эти числа и сохранить в списке (в виде чисел, а не строк). Напишите программу, которая с помощью цикла `for` находит минимальный элемент в заданном списке чисел (**не используя встроенную функцию `min()`**).

12. На вход программе подаются две строки с целыми числами, записанными в одну строчку через пробел. Необходимо прочитать эти строки и сохранить в два списка (в виде чисел, а не строк). Напишите программу, которая будет объединять эти два списка в один с чередованием элементов. Используйте цикл `for`. Например, если есть списки `[1, 2, 3]` и `['a', 'b', 'c']`, результат должен быть `[1, 'a', 2, 'b', 3, 'c']`.

13. На вход программе подается натуральное число `n`. Прочитайте это число и вычислите сумму всех натуральных чисел меньше `n`, которые кратны или `3` или `5`. Результат (сумму) выведите на экран (Натура́льные числа - числа, возникающие естественным образом при счёте (1, 2, 3, 4, 5, 6, 7 и так далее)).

14. На вход программе подается натуральное число `n`. Прочитайте это число и с помощью цикла `for` найдите все делители этого числа (то есть, целые числа от `1` до `n`, которые делят число `n` нацело). Найденные делители выводить сразу в столбик без формирования списка.

15. \* На вход программе подается строка с названиями городов, записанных в одну строчку через пробел. Необходимо прочитать эту строку и сформировать список из названий городов. Переберите полученный список с помощью цикла `for` и определите, начинается ли название следующего города на последнюю букву предыдущего города в списке. Если последними встречаются буквы `ь`, `ъ`, `ы`, то берется следующая с конца буква. Вывести на экран `ДА`, если последовательность удовлетворяет этому правилу и `НЕТ` в противном случае.

16. \* На вход программе подается натуральное число `n`. а затем `n` различных натуральных чисел последовательности, каждое на отдельной строке. Напишите программу, которая выводит наибольшее и второе наибольшее число последовательности.

17. \* На вход программе подается целое число `n`. Напишите программу, которая с помощью цикла `for` проверяет, является ли введенное число `n` простым (Простое число - натуральное число, большее 1, если оно ни на что не делится, кроме себя и 1).

## Урок 19. Примеры задач решаемых с помощью цикла for

### 19.1 Вычисление факториала от натурального числа n.

**Факториал числа** - это **произведение всех положительных целых чисел от 1 до данного числа**.

**Решение**:

```python
number = 5
factorial = 1

for i in range(1, number + 1):
    factorial = factorial * i

print(factorial)
```

В этом коде мы инициализируем переменную `factorial` значением `1`. Затем мы используем цикл `for`, чтобы умножить `factorial` на каждое число от `1` до `number`. В результате получаем факториал числа `number`.

### 19.2 Отображение символов \* в виде елочки.

```
*
**
***
****
*****
******
```

**Решение**:

```python
for i in range(1, 7):
    print('*' * i)
```

Счетчик `i` будет принимать значения `1`, `2`, `3`, `4`, `5` и `6`. Соответственно, функция `print()` будет дублировать символ `*` `i` раз.

### 19.3 Cоединить все слова списка в одно предложение.

```python
words = ["Python", "JavaScript", "C++", "Java", "TypeScript", "PHP", "Rust", "Go"]

str = ''
for word in words:
    str += ' ' + word

print(str.lstrip())
```

### 19.4 Все двузначные числа в списке заменить нулями.

```python
digs = [4, 3, 100, -53, -30, 1, 34, -8]

for i in range(len(digs)):
    if 10 <= abs(digs[i]) <= 99:
        digs[i] = 0

print(digs)
```

в цикле перебираем индексы элементов списка, а не сами элементы. Благодаря этому, в цикле получаем возможность изменять значение i-го элемента.

### 19.5 Цикл for и функция enumerate()

Функция **enumerate()** используется вместе с циклом for для получения **индекса** и **значения** элемента во время итерации. Она возвращает **объект**, который генерирует пары значений - **индекс элемента** и **сам элемент**.

**Задача**: Все двузначные числа в списке заменить нулями используя функцию enumerate()

```python
digs = [4, 3, 100, -53, -30, 1, 34, -8]

for i, d in enumerate(digs):
    if 10 <= abs(d) <= 99:
        digs[i] = 0

print(digs)
```

### 19.6 Преобразование кириллицы в латиницу.

```python
# список замен для соответствующих русских букв
t = ['a', 'b', 'v', 'g', 'd', 'e', 'zh',
     'z', 'i', 'y', 'k', 'l', 'm', 'n', 'o', 'p',
     'r', 's', 't', 'u', 'f', 'h', 'c', 'ch', 'sh',
     'shch', '', 'y', '', 'e', 'yu', 'ya'
]
# кодовое значение для первой буквы этого списка
start_index = ord('а')
# зададим строку и переменную slug, где будем формировать строку на латинице
title = "Программирование на Python - лучшее занятие"
slug = ''
#  преобразование в цикле, перебирая каждый символ исходной строки
for s in title.lower():
    if 'а' <= s <= 'я':
        slug += t[ord(s) - start_index]
    elif s == 'ё':
        slug += 'yo'
    elif s in ' !?:,.':
        slug += '-'
    else:
        slug += s
# удалим все подряд идущие символы дефиса
while slug.count('--'):
    slug = slug.replace('--', '-')
# выводим результат
print(slug)
```

### Задачи:

1. На вход программе подается строка. Необходимо ее прочитать и найти в ней все индексы строкового фрагмента "ра". Выведите найденные индексы на экран в одну строчку через пробел. Если же фрагмент "ра" отсутствует в строке, то вывести -1.

2. На вход программе подается строка с номером телефона. Ожидается следующий формат номера в строке: `+7(xxx)xxx-xx-xx`. Число введенных символов считается всегда верным. Необходимо прочитать строку из входного потока и проверить, что она содержит номер телефона в соответствии с приведенным форматом. Вывести "ДА", если это так и "НЕТ" в противном случае.

3. На вход программе подается строка, в которой записано арифметическое выражение. Например: `10 + 25 - 12`. Количество действий сложения или вычитания может быть произвольным. Необходимо прочитать эту строку из входного потока и выполнить вычисление, записанного в ней арифметического выражения. Результат вычисления отобразить на экране. Полагается, что в качестве арифметических операций используется только сложение (+) и вычитание (-), а в качестве операндов только целые неотрицательные числа. Следует учесть, что математические операции могут быть записаны как с пробелами (до и после), так и без них.

4. На вход программе подаются целые числа, записанные в одну строку через пробел. Необходимо прочитать эти числа и сохранить в списке. Затем, каждое значение этого списка изменить на квадрат соответствующего числа. Результат (список) выведите на экран в виде последовательности чисел, записанных через пробел. Программу следует реализовать с использованием функции enumerate.

5. На вход программе подаются целые числа, записанные в одну строку через пробел. Необходимо прочитать эти числа и сохранить в списке. Затем, каждый элемент этого списка продублировать один раз. Например, для списка: `[1, 2, 3]`. после дублирования должны получить: `[1, 1, 2, 2, 3, 3]`. Результат (список) выведите на экран.

6. На вход программе подаются вещественные числа, записанные через пробел. Необходимо прочитать эти числа и сохранить в списке. Затем, с помощью цикла for нужно найти наименьшее число в этом списке. Полученный результат (минимальное число) вывести на экран. Реализовать программу без использования функции min, max и сортировки.

7. На вход программе подаются вещественные числа, записанные через пробел. Необходимо прочитать эти числа и сохранить в списке. Затем, все отрицательные значения в этом списке заменить на -1.0. Результат (список) выведите на экран в виде последовательности чисел, записанных через пробел. Программу следует реализовать с использованием функции enumerate.

## Урок 20. Операторы циклов break, continue. Блок else для циклов for и while.

Операторы `break` и `continue` являются часто используемыми инструментами в циклах.

### 20.1 break.

- `break`: Оператор `break` используется для **немедленного прерывания выполнения цикла**. Когда интерпретатор Python встречает оператор `break`, он немедленно выходит из цикла и продолжает выполнение кода после цикла. Оператор `break` полезно использовать, когда нам нужно **прервать** выполнение цикла, когда выполняется определенное условие.

  ```python
  i = 0
  while i < 10:
      if i == 5:
          break
      print(i)
      i += 1
  ```

  В этом примере цикл `while` будет выполняться, пока значение переменной `i` меньше `10`. Однако, когда `i` становится равным `5`, оператор `break` прерывает выполнение цикла, и код продолжает выполняться после цикла. В результате на экран будет выведено: `0, 1, 2, 3, 4`.

### 20.2 continue.

- `continue`: Оператор `continue` используется для **пропуска текущей итерации цикла и перехода к следующей итерации**. Когда интерпретатор Python встречает оператор `continue`, он пропускает оставшуюся часть текущей итерации и переходит к следующей итерации. Оператор `continue` полезно использовать, когда нам нужно **пропустить** выполнение определенных действий в цикле для некоторых условий.

  ```python
  numbers = [1, 2, 3, 4, 5]
  for number in numbers:
      if number == 3:
          continue
      print(number)
  ```

  В этом примере цикл for итерируется по списку `numbers`. Однако, когда значение переменной number становится равным `3`, оператор continue пропускает оставшуюся часть текущей итерации и переходит к следующей итерации. В результате на экран будет выведено: `1, 2, 4, 5`.

### 20.3 Блок else для цикла for

Блок `else` позволяет добавить код, который выполнится **после завершения цикла `for`**, **если цикл завершился нормально**, то есть **без выхода через `break`**. **Если цикл прерывается оператором `break`, блок `else` пропускается**.

**Синтаксис**:

```python
for элемент in последовательность:
    # Действия, выполняемые для каждого элемента
else:
    # Действия, выполняемые, если цикл завершился без break
```

**Как работает**:

- Цикл `for` выполняет код в своём теле для каждого элемента последовательности.
- Если цикл завершился естественным образом (дошел до конца последовательности **без `break`**), то выполняется блок `else`.
- Если `break` встречается в теле цикла, то цикл прерывается, и блок `else` не выполняется.

### 20.4 Основные случаи применения else.

Блок `else` удобен, когда нужно определить, был ли выполнен цикл полностью, или прервался досрочно.

**Это полезно в следующих сценариях**:

- **Поиск элемента**: Если элемент найден, `break` прерывает цикл. Если нет — цикл завершается естественно, и выполняется блок `else`, указывающий, что элемент не был найден.
- **Проверка условий**: Блок `else` может сигнализировать, что все элементы прошли через проверку и удовлетворяют условию.

### 20.5 Примеры использования блока else в цикле for.

#### Пример 1: Поиск элемента в списке

Допустим, мы хотим **найти число в списке** и вывести сообщение, найдено оно или нет.

```python
numbers = [2, 4, 6, 8, 10]
target = 5

for num in numbers:
    if num == target:
        print(f"Число {target} найдено в списке.")
        break
else:
    print(f"Число {target} не найдено в списке.")
```

#### Пример 2: Проверка простого числа

Мы можем использовать `for...else` для проверки, является ли число **простым**. Простое число — **это число, которое делится без остатка только на 1 и на само себя**.

```python
number = 17

if number > 1:
    for i in range(2, number):
        if number % i == 0:
            print(f"{number} — не является простым числом (делится на {i}).")
            break
    else:
        print(f"{number} — простое число.")
else:
    print(f"{number} — не является простым числом.")
```

#### Пример 3: Поиск уникальных значений в списке

Этот пример демонстрирует, как использовать **`for...else` для проверки уникальности значений**.

```python
items = [1, 2, 3, 4, 5, 3]
unique = True

for i in range(len(items)):
    if items[i] in items[i + 1:]:
        print(f"Элемент {items[i]} не уникален.")
        unique = False
        break
else:
    print("Все элементы уникальны.")
```

#### Пример 4: Поиск строки в списке строк

Этот пример показывает, как `else` может использоваться для **вывода информации, если строка не найдена**.

```python
words = ["apple", "banana", "cherry", "date"]
search_word = "fig"

for word in words:
    if word == search_word:
        print(f"Слово '{search_word}' найдено в списке.")
        break
else:
    print(f"Слово '{search_word}' не найдено.")
```

### 20.6 else в цикле while

Блок `else` можно использовать с циклом `while`, и его поведение будет аналогично `for...else`.

#### Пример 1: Проверка числа на простоту

```python
n = int(input("Введите число: "))
i = 2

while i * i <= n:
    if n % i == 0:
        print(f"{n} не является простым числом (делится на {i}).")
        break
    i += 1
else:
    print(f"{n} является простым числом.")
```

#### Пример 2: Поиск первого четного числа в списке

```python
numbers = [1, 3, 5, 7, 9]
index = 0

while index < len(numbers):
    if numbers[index] % 2 == 0:
        print(f"Первое четное число: {numbers[index]}")
        break
    index += 1
else:
    print("Четных чисел в списке нет.")
```

### Вопросы:

1. Какой оператор используется для немедленного прерывания выполнения цикла?
2. Какой оператор используется для пропуска текущей итерации цикла и перехода к следующей?
3. В чем основная цель использования блока else в цикле for?
4. Как работает else в цикле for? Когда он выполняется, а когда нет?
5. Чем отличается поведение блока else в цикле for от конструкции if...else?

### Задачи:

1. На вход программе подается натуральное число `n`. Напишите программу, которая выводит все четные числа от 1 до `n`, но завершает работу, если встречает число, кратное `7`.

2. На вход программе подается натуральное число `n`. Напишите программу, которая выводит все числа от 1 до `n`, но пропускает числа, кратные 3.

3. На вход программе подается строка, содержащая целые числа, записанные через пробел. Напишите программу, которая выводит все положительные числа.

4. На вход программе подается строка состоящая из нескольких слов через пробел. Выведите все слова, кроме тех, которые содержат букву `"a"`. Пример входящей строки: `"яблоко банан апельсин"`.

5. На вход программе подается строка состоящая из нескольких слов через пробел. Напишите программу, которая проверяет, есть ли буква `"ц"` в строке. Если буква найдена, программа должна выводить сообщение `"Буква 'ц' в строке есть"` и прерывать цикл. Если же буква не встречается в строке нужно вывести сообщение: `"Буквы 'ц' в строке нет."`. Пример входящей строки: `"яблоко банан апельсин"`.

6. На вход программе подается натуральное число `n`. В цикле переберите все целые числа в интервале `[1; n]` (включая границы) и сформируйте список из чисел, кратных `3` и `5` одновременно. Выведите на экран полученный список чисел, если значение `n` меньше `100`. Иначе выведите на экран сообщение: `слишком большое значение n`.

7. Напишите программу, в которой на каждой итерации цикла читается целое число. Программа должна завершиться, как только встретит первое отрицательное число.

8. На вход программе подается натуральное число `n`. Напишите программу, которая выводит числа от `1 до n`, но пропускает все четные числа до того момента, как встретит пять четных чисел, после чего завершает выполнение.

9. Напишите программу, в которой на каждой итерации цикла читается целое число. Программа должна складывать числа до тех пор, пока сумма не станет больше `100`, после чего завершить выполнение.

10. Напишите программу, в которой на каждой итерации цикла читается целое число. Необходимо подсчитать произведение только положительных чисел, до тех пор, пока не встретится число `0`.

11. На вход программе подается натуральное число `n`. Прочитайте это число и определите является ли оно простым (Простое число - натуральное число, большее 1, если оно ни на что не делится, кроме себя и 1). Вывести на экран строку `"ДА"`, если `n` простое и строку `"НЕТ"` в противном случае.

12. На вход программе подается строка, содержащая целые числа, записанные через пробел. Напишите программу, которая находит минимальное число, меньшее `10`. Если в списке нет чисел меньше `10`, выведите сообщение `"В списке нет числа меньше 10"`.

13. На вход программе подается натуральное число `n`. Прочитайте это число и выведите первое найденное натуральное число (то есть, перебирать числа, начиная с 1), квадрат которого больше значения `n`.

14. На вход программе подается строка, содержащая целые числа, записанные через пробел. Напишите программу, которая проверяет, упорядочены ли числа в списке по возрастанию. Если порядок нарушается, программа должна выводить сообщение об этом и завершаться. Если же весь список упорядочен, выведите сообщение `"Это упорядоченный список"`.

15. На вход программе подается строка с названиями городов, записанных в одну строчку через пробел. Необходимо прочитать эту строку и сформировать список из названий городов. Переберите полученный список и определите, начинается ли название следующего города на последнюю букву предыдущего города в списке. Если последними встречаются буквы `'ь'`, `'ъ'`, `'ы'`, то берется следующая с конца буква. Вывести на экран `"ДА"`, если последовательность удовлетворяет этому правилу и `"НЕТ"` в противном случае. Пример входящей строки: `"Москва Анапа Архангельск Казань Нальчик"`.

## Урок 21. Итератор и итерируемые объекты. Функции iter() и next()

### 21.1 Итератор

**Итератор** - это объект в языке программирования Python, который предоставляет последовательный доступ к элементам коллекции или контейнера. Он позволяет перебирать элементы по одному, не раскрывая внутреннюю структуру коллекции.

### 21.2 Итерируемый объект

**Итерируемый объект** - это объект, который может быть использован в цикле `for` для **итерации по его элементам**. Он должен иметь метод `__iter__()`, который возвращает **итератор**. Итератор, в свою очередь, должен иметь методы `__iter__()` и `__next__()`.

### 21.3 Функции iter() и next()

Для получения доступа к итератору объекта в Python можно использовать функцию `iter()`. Функция `iter()` принимает итерируемый объект в качестве аргумента и возвращает соответствующий итератор.

```python
numbers = [1, 2, 3]
iterator = iter(numbers)

print(next(iterator))  # Выводит 1
print(next(iterator))  # Выводит 2
print(next(iterator))  # Выводит 3
```

В этом примере мы создаем список `numbers` и получаем его **итератор с помощью функции `iter()`**. Затем мы используем функцию `next()` для получения **следующего элемента из итератора**. Каждый вызов `next()` **возвращает следующий элемент в последовательности**.

Функция `next()` используется для **получения следующего элемента из итератора**. Если больше элементов нет, она вызывает исключение **`StopIteration`**, чтобы указать, что итерация завершена.

Таким образом, функция `iter()` позволяет **создать итератор для итерируемого объекта**, а функция `next()` используется для **получения следующего элемента из итератора**.

Когда **итератор** дошел до конца коллекции, его уже **нельзя вернуть назад** и пройти все элементы заново. Для этого придется **создавать новый итератор с помощью функции `iter()`**.

### 21.4 Функция range() - итерируемый объект

Функция `range()` в языке программирования Python представляет собой **итерируемый объект**, который генерирует последовательность чисел. Она позволяет **создавать последовательности чисел с определенным `началом`, `концом` и `шагом`**.

```python
r = range(5)
iterator = iter(r)
print(next(iterator))
print(next(iterator))
print(next(iterator))
print(next(iterator))
print(next(iterator))
```

**Итератор** - `единственный` **универсальный и безопасный способ перебирать итерируемые объекты** самых разных типов.

### Вопросы:

1. Что такое Итератор?
2. Что такое Итерируемый объект?
3. Когда мы получаем ошибку Stopiteration?

### Задачи:

1. На вход программе подается строка с названиями городов, записанных в одну строчку через пробел. Необходимо прочитать эту строку и на ее основе сформировать список из названий городов. После этого создайте итератор для полученного списка и с помощью итератора выведите на экран в столбик первые два названия города.

2. На вход программе подается строка. Нужно ее прочитать и создать итератор для перебора символов этой строки. Затем, через созданный итератор перебрать все символы до первого пробела. В процессе перебора символы выводить на экран в одну строчку друг за другом (без пробелов). Гарантируется, что во введенной строке имеется хотя бы один пробел.

3. На вход программе подается четырехзначное целое положительное число. Прочитайте это число и подумайте, как можно определить итератор для перебора его цифр. Выведите все цифры введенного числа (с помощью итератора) в одну строчку через пробел.

## Урок 22. Вложенные циклы.

### 22.1 Вложенные циклы for и while

В Python можно использовать **вложенные циклы**, такие как цикл `for` вложенный в `while`, цикл `while` вложенный в `for` и цикл `for` вложенный в `for`.

### 22.2 Цикл for, вложенный в while

Рассмотрим, как `for-цикл` может быть вложен в `while` для выполнения повторяющихся действий с условием.

#### Печать последовательности чисел с вложением for в while.

```python
counter = 1
while counter <= 3:
    print(f"Внешний цикл, итерация {counter}")
    for i in range(1, 4):
        print(f"Внутренний цикл, значение {i}")
    counter += 1
```

**Пояснение**:

- `while counter <= 3` запускает основной цикл, пока переменная `counter` не станет больше `3`.
- На каждой итерации внешнего цикла `for` проходит по значениям от `1` до `3`, что выводит номера итераций внутреннего цикла.
- Так мы получаем **три повторяющихся цикла** с внутренним диапазоном `1–3`.

**Применение**:

Подобная структура удобна при **выполнении повторяющихся действий с ограниченным количеством итераций**. Например, можно использовать для повторного выполнения запросов, где `while` отслеживает `успех/ошибку`, а `for` повторяет действия с изменяемыми данными.

### 22.3 Цикл while, вложенный в for

Пример использования `while` внутри `for`, когда требуется выполнение до достижения условия на каждом шаге `for`.

#### Проверка делимости для чисел в диапазоне.

```python
for num in range(1, 4):
    print(f"Число {num}")
    divisor = 1
    while divisor <= num:
        if num % divisor == 0:
            print(f"{num} делится на {divisor}")
        divisor += 1
```

**Пояснение**:

- Внешний цикл `for` проходит по **диапазону чисел**.
- Внутренний цикл `while` проверяет делимость каждого числа на `divisor`.
- На каждом шаге цикла `while` `divisor` увеличивается, пока не достигнет значения `num`.

**Применение**:

В подобной структуре удобно **проводить операции, зависящие от изменения условия для каждого нового значения внешнего цикла**, например, **проверка простых чисел, нахождение делителей и т.д.**

### 22.4 Цикл for, вложенный в for

Вложенные циклы `for` позволяют **работать с многомерными структурами данных**, например, с `матрицами`.

#### Создание таблицы умножения.

```python
for i in range(1, 4):
    for j in range(1, 4):
        print(f"{i} * {j} = {i * j}")
    print("------")
```

**Пояснение**:

- Внешний `for` цикл проходит по числам от `1` до `3`.
- Внутренний `for` умножает каждое значение внешнего цикла на текущий элемент.
- Результат — таблица умножения от `1` до `3`, разделенная на группы.

**Применение**:

Вложенные `for` циклы часто **используют для обработки двумерных массивов** или **создания таблиц**.

### 22.5 Использование вложенных циклов:

1. Чтобы **вывести все элементы двумерного списка** `lst = [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]`, вы можете использовать вложенные циклы.

   ```python
   lst = [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]

   for sublist in lst:
       for element in sublist:
           print(element, end=' ')
   ```

2. Для **выполнения сложения значений из двух двумерных списков** `lst1` и `lst2`.

   ```python
   lst1 = [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]
   lst2 = [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]]

   r_lst = []
   for i in range(len(lst1)):
       sublist = []
       for j in range(len(lst2[i])):
           sublist.append(lst1[i][j] + lst2[i][j])
       r_lst.append(sublist)
   print(r_lst)
   ```

3. Для **удаления повторяющихся символов**.

   ```python
   lst = [ "Я   помню  чудное    мгновенье",
   "Передо  мной    явилась   ты",
   "Как    мимолетное   виденье",
   "Как     гений   чистой  красоты"]

   for index, line in enumerate(lst):
       while lst[index].count("  "):
           lst[index] = lst[index].replace("  ", " ")

   print(lst)
   ```

4. Для **формирования вложенного списка размерами `MxN`**, **заполненного нулями** с помощью цикла `for`, а затем **замены всех элементов на единицы** с использованием вложенных циклов.

   ```python
   M = int(input("Введите количество строк: "))
   N = int(input("Введите количество столбцов: "))

   nested_list = []
   for i in range(M):
       sublist = []
       for j in range(N):
           sublist.append(0)
       nested_list.append(sublist)

   for i in range(M):
       for j in range(N):
           nested_list[i][j] = 1
   ```

5. Для **замены строк на столбцы и получить новое представление списка**. В математике это называется **транспонированием матрицы**.

   ```python
   lst = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]

   for i in range(len(lst)):
       for j in range(i + 1, len(lst)):
           lst[i][j], lst[j][i] = lst[j][i], lst[i][j]

   for row in lst:
       for number in row:
           print(number, end='\t')
       print()
   ```

### Задачи

1. На вход программе подаются два натуральных числа: `n` - высота и `m` - ширина прямоугольника. С помощью вложенных циклов создайте прямоугольник из символов \* по заданной **высоте** и **ширине**. Вывести этот список на экран.

2. На вход программе подается натуральное число `n` - высота треугольника. С помощью вложенных циклов создайте треугольник чисел. Вывести этот треугольник на экран.
   Пример треугольника для высоты `5`:

   ```
   1
   12
   123
   1234
   12345
   ```

3. Напишите программу, которая определяет сколько элементов совпадают в двух списках `lst1` и `lst2`. `lst1 = [1, 2, 3, 4, 5]` и `lst2 = [4, 5, 6, 7, 8]`. Вывести этот список с общими элементами на экран.

4. С помощью вложенных циклов создайте таблицу умножения для чисел от `1` до `10`. Вывести таблицу умножения на экран.

5. Даны два двумерных списка `list1 = [[1, 2, 3], [4, 5, 6]]` и `list2 = [[4, 5, 6], [7, 8, 9]]`. Найдите и выведите все элементы, которые присутствуют и в одном, и в другом.

6. Дана матрица `matrix = [[1, 2, 3], [4, 5, 6]]`. Транспонируйте её, то есть поменяйте строки на столбцы. Вывести матрицу на экран.

7. Дана матрица `matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]`. Найдите сумму всех элементов этой матрицы. Вывести сумму на экран.

8. Выведите шахматную доску размером 8x8 с чередующимися символами `#` и `0`.
   Пример шахматной доски:

   ```
   #0#0#0#0
   0#0#0#0#
   #0#0#0#0
   0#0#0#0#
   #0#0#0#0
   0#0#0#0#
   #0#0#0#0
   0#0#0#0#
   ```

9. Даны две матрицы `matrix1 = [[1, 2], [3, 4]]` и `matrix2 = [[5, 6], [7, 8]]`. Создайте новую матрицу, где каждый элемент — это сумма элементов из двух матриц. Вывести матрицу на экран.

10. Создайте двумерный список `3х3` `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]`, где каждый элемент — это его **индекс**. Вывести список на экран.

11. Постройте матрицу `3x3` из чисел в обратном порядке `[[9, 8, 7], [6, 5, 4], [3, 2, 1]]`. Вывести матрицу на экран.

12. На вход программе подается натуральное число `n`. Требуется создать двумерный список размером `n x n` элементов, состоящий из всех единиц, а затем, в последний столбец записать пятерки. Вывести список на экран.

## Урок 23. Генераторы списков. Условия в генераторах списков. Вложенные генераторы списков

### 23.1 Генератор списка

**Генераторы списков** в языке Python - это **компактный** способ **создания списков** на основе других списков или итерируемых объектов. Они позволяют создавать новый список, применяя выражение к каждому элементу исходного списка или итерируемого объекта. Генераторы списков предоставляют более краткий и эффективный способ создания списков по сравнению с использованием обычных циклов.

### 23.2 Синтаксис генератора списка

**[выражение for элемент in исходный-список/итерируемый-объект]**

- **выражение** - это выражение, которое будет применено к каждому элементу исходного списка или итерируемого объекта.
- **элемент** - это переменная, которая будет использоваться для представления каждого элемента исходного списка или итерируемого объекта.
- **исходный*список/итерируемый*объект** - это список или итерируемый объект, на основе которого будет создан новый список.

**Пример**:

```python
# Пример 1: Создание списка чисел от 1 до 10
numbers = [i for i in range(1, 11)]
# Результат: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Пример 2: Создание списка квадратов чисел от 1 до 10
squares = [i**2 for i in range(1, 11)]
# Результат: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

### 23.3 Создание списка с помощью обычного цикла и создание списка с помощью генератора списков.

**Создание списка с помощью обычного цикла** и **создание списка с помощью генератора списков** позволяют **создавать списки**, но **существуют некоторые различия в синтаксисе и подходе**.

При использовании обычного цикла, вы должны объявить пустой список, затем использовать цикл для итерации по элементам исходного списка или итерируемого объекта, и внутри цикла добавлять элементы в новый список с помощью метода `append()`.

**Пример**:

```python
# Создание списка чисел от 1 до 10 с помощью обычного цикла
numbers = []
for i in range(1, 11):
    numbers.append(i)
print(numbers)
```

При использовании **генератора списков**, вы можете **создать новый список в одной строке**, **применяя выражение к каждому элементу исходного списка** или **итерируемого объекта**.

**Пример**:

```python
# Создание списка чисел от 1 до 10 с помощью генератора списков
numbers = [i for i in range(1, 11)]
print(numbers)
```

**Оба подхода дают одинаковый результат, но генераторы списков обычно считаются более краткими и эффективными**.

### 23.4 Генератор списков с использованием input().split()

Генератор списков с использованием `input().split()` позволяет создавать список на основе введенных пользователем значений, разделенных пробелами.

```python
# Ввод чисел с клавиатуры и создание списка
numbers = [int(i) for i in input().split()]
```

В этом примере мы используем `input().split()` для получения ввода от пользователя. `input()` считывает строку, а `split()` разделяет эту строку на отдельные значения, используя пробел в качестве разделителя. Затем мы используем генератор списка `[int(i) for i in input().split()]`, чтобы преобразовать каждое значение в целое число и создать список из этих чисел.

### 23.5 Генератор списка с условием.

**Генератор списка с условием** позволяет **создавать список** на основе определенного условия.
**Синтаксис**:

**[выражение for элемент in исходный-список/итерируемый-объект if условие]**

- **выражение** - это выражение, которое будет применено к каждому элементу исходного списка или итерируемого объекта.
- **элемент** - это переменная, которая будет использоваться для представления каждого элемента исходного списка или итерируемого объекта.
- **исходный*список/итерируемый*объект** - это список или итерируемый объект, на основе которого будет создан новый список.
- **условие (необязательно)** - это условие, которое определяет, должен ли быть включен элемент в новый список.

```python
# Список городов
cities = ['Москва', 'Санкт-Петербург', 'Нью-Йорк', 'Лондон', 'Париж', 'Мадрид']
# Создание списка городов, начинающихся с буквы "М"
filtered_cities = [city for city in cities if city.startswith('М')]
print(filtered_cities)
```

В этом примере мы используем генератор списка `[city for city in cities if city.startswith('М')]`, чтобы создать новый список, содержащий только города, которые начинаются с буквы "М". Мы проверяем каждый элемент `city` в списке `cities` с помощью условия `city.startswith('М')`, и только те элементы, которые удовлетворяют условию, включаются в новый список `filtered_cities`.

```python
# Список чисел
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# Создание списка четных чисел
even_numbers = [num for num in numbers if num % 2 == 0]
print(even_numbers)
```

В этом примере мы используем генератор списка `[num for num in numbers if num % 2 == 0]`, чтобы создать новый список, содержащий только четные числа из списка `numbers`. Мы проверяем каждое число `num` в списке `numbers` с помощью условия `num % 2 == 0`, и только четные числа включаются в новый список `even_numbers`.

**Генераторы списков с условием позволяют более компактно и эффективно создавать списки на основе определенных условий**.

### 23.6 Несколько циклов for в генераторах списков.

В языке Python можно использовать **вложенные циклы for в генераторах списков для создания списков с более сложной структурой** или для выполнения операций над элементами вложенных списков.

#### Вложенные циклы for в генераторе списка

**Пример 1**: **Вложенные циклы for в генераторе списка**

```python
# Создание списка с парами чисел от 1 до 3
pairs = [(x, y) for x in range(1, 4) for y in range(1, 4)]
# Результат: [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]
print(pairs)
```

В этом примере мы используем два вложенных цикла `for` в генераторе списка `[(x, y) for x in range(1, 4) for y in range(1, 4)]`, чтобы создать список с парами чисел от 1 до 3. Первый цикл `for x in range(1, 4)` перебирает значения x от 1 до 3, а второй цикл `for` y `in range(1, 4)` перебирает значения y от 1 до 3. Каждая комбинация `(x, y)` добавляется в список `pairs`.

**Пример 2**: **Преобразование двумерного списка в одномерный с помощью вложенных циклов for в генераторе списка**

```python
# Преобразование двумерного списка в одномерный
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat_list = [num for row in matrix for num in row]
# Результат: [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(flat_list)
```

В этом примере мы используем два вложенных цикла `for` в генераторе списка `[num for row in matrix for num in row]`, чтобы преобразовать двумерный список `matrix` в одномерный список `flat_list`. Первый цикл `for row in matrix` перебирает строки в списке `matrix`, а второй цикл `for num in row` перебирает числа в каждой строке. Каждое число добавляется в список `flat_list`.

### 23.7 Вложенные генераторы списков.

**Вложенные генераторы списков** в языке Python позволяют **создавать списки с более сложной структурой или выполнять операции над элементами вложенных списков**. Они позволяют **использовать вложенные циклы и условия внутри генератора списка для создания более гибких и мощных выражений**.

**Пример 1**: **Получение двумерного списка с помощью вложенного генератора списков**

```python
# Получение двумерного списка с помощью вложенного генератора списков
matrix = [[i+j for j in range(3)] for i in range(3)]
# Результат: [[0, 1, 2], [1, 2, 3], [2, 3, 4]]
print(matrix)
```

В этом примере мы используем вложенный генератор списков `[[i+j for j in range(3)] for i in range(3)]`, чтобы создать двумерный список `matrix`. Внешний генератор списка `for i in range(3)` перебирает значения i от 0 до 2, а внутренний генератор списка `for j in range(3)` перебирает значения j от 0 до 2. Каждое значение `i+j` добавляется во внутренний список, и в результате получается двумерный список.

**Пример 2**: **Возвести все значения двумерного списка в квадрат с помощью вложенного генератора списков**

```python
# Возвести все значения двумерного списка в квадрат с помощью вложенного генератора списков
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
squared_matrix = [[num**2 for num in row] for row in matrix]
# Результат: [[1, 4, 9], [16, 25, 36], [49, 64, 81]]
print(squared_matrix)
```

В этом примере мы используем вложенный генератор списков `[[num**2 for num in row] for row in matrix]`, чтобы возвести все значения двумерного списка `matrix` в **квадрат**. Внешний генератор списка `for row in matrix` перебирает строки в списке `matrix`, а внутренний генератор списка `for num in row` перебирает значения в каждой строке. Каждое значение `num**2` добавляется во внутренний список, и в результате получается двумерный список `squared_matrix`.

**Пример 3**: **Транспонирование матрицы с использованием вложенных генераторов**

```python
# Транспонирование матрицы с использованием вложенных генераторов
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
transposed_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]
# Результат: [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
print(transposed_matrix)
```

В этом примере мы используем вложенный генератор списков `[[row[i] for row in matrix] for i in range(len(matrix[0]))]`, чтобы выполнить **транспонирование матрицы**. Внешний генератор списка `for i in range(len(matrix[0]))` перебирает индексы столбцов, а внутренний генератор списка `for row in matrix` перебирает строки. Каждый элемент `row[i]` добавляется во внутренний список, и в результате получается транспонированная матрица `transposed_matrix`.

**Пример 4**: **Генератор списка в качестве итерируемого объекта в генераторе списка**

```python
# Пример: Создание списка кубов чисел от 1 до 5 с использованием вложенного генератора списков
cubes = [num ** 3 for num in [value + 1 for value in range(5)]]
# Результат: [1, 8, 27, 64, 125]
print(cubes)
```

В этом примере внутренний генератор списка `[value + 1 for value in range(5)]` создает список чисел от 1 до 5, а внешний генератор списка `num ** 3 for num in [...]` возводит каждое число из внутреннего списка в куб и формирует итоговый список кубов.

### Вопросы:

1. Что такое генератор списка в Python?
2. Какие преимущества предоставляют генераторы списков по сравнению с обычными циклами?
3. Как создать список чисел от 1 до 10 с использованием генератора списка?
4. Какие операции можно выполнять над элементами вложенных списков с помощью вложенных генераторов списков?
5. Какие условия можно добавить в генератор списка для фильтрации элементов?
6. Можно ли использовать генератор списка в качестве итерируемого объекта в другом генераторе списка?

### Задачи:

1. На вход программе подаются вещественные числа, записанные через пробел. Необходимо их прочитать и сохранить в списке lst. Затем, используя генератор списков сформировать новый список lst_abs из модулей чисел списка lst. Список lst_abs вывести на экран.

2. На вход программе подается семизначное целое положительное число. Необходимо его прочитать и с помощью генератора списков сформировать список lst_in, содержащий цифры этого числа. Полученный список вывести на экран.

3. На вход программе подается натуральное число `N`. Прочитайте его и с помощью генератора списков сформируйте двумерный список размером `N x N`, состоящий из нулей, а по главной диагонали - единицы. (Главная диагональ - это элементы, идущие по диагонали от верхнего левого угла матрицы до ее нижнего правого угла). Полученный двумерный список вывести на экран.

4. На вход программе подается строка с названиями городов, записанных через пробел. Необходимо прочитать эту строку и сформировать список с помощью генератора списков, содержащий названия городов длиной более пяти символов. Элементы полученного списка вывести в одну строчку через пробел. **Пример вводимой строки**: `Казань Уфа Москва Челябинск Омск Тур Самара`.

5. На вход программе подается натуральное число `n`. Необходимо его прочитать и сформировать список с помощью генератора списков, состоящий из делителей числа n (включая и само число n). Элементы полученного списка вывести в одну строчку через пробел. Делителями числа `n` называются целые числа, которые делят `n` нацело (без остатка).

6. На вход программе подается натуральное число `N`. Необходимо его прочитать и сгенерировать вложенный список с помощью генератора списков, размером `N x N`, где первая строка содержала бы все нули, вторая - все единицы, третья - все двойки и так до N-й строки. Результат вывести на экран.

7. Объявите в программе следующий список:

   ```python
   matrix = [
     [1, 2, 3, 4],
     [5, 6, 7, 8],
     [9, 8, 7, 6],
     [5, 4, 3, 2],
   ]
   ```

   С помощью генератора списков необходимо преобразовать список matrix в одномерный так, чтобы значения элементов шли в обратном порядке. Результат отобразить в виде строки из чисел, записанных через пробел.

8. Объявите в программе следующий список из строк:

   ```python
   str_lst = [
     'Я помню чудное мгновенье:',
     'Передо мной явилась ты',
     'Как мимолетное виденье',
     'Как гений чистой красоты'
   ]
   ```

   Необходимо преобразовать его в двумерный список lst_words, где каждая строка представляется списком из слов (слова разделяются пробелом), но сохранять слова только длиной более трех символов. Решить данную задачу следует с использованием генератора списков. Результат отобразить на экран.

9. На вход программе поступает матрица:

   ```python
   matrix = [
     [1, 2, 3],
     [4, 5, 6],
     [7, 8, 9],
     [5, 4, 3],
   ]
   ```

   Нужно транспонировать `matrix` (строки заменяются на столбцы) и результат сохранить в списке `result` и вывести на экран.

## Урок 24. Словари (dict). Методы словарей. Словари и циклы

### 24.1 Словари. Получение значения.

**Словари** (`dictionaries`) — это **изменяемые**, **неупорядоченные** коллекции пар **"ключ-значение"**. Они используются для **хранения данных**, которые ассоциируются с **уникальными ключами**.

Словари позволяют быстро получать доступ **к значениям** по их **ключам**.

Словарь определяется с помощью **фигурных скобок** `{}` и содержит пары `ключ-значение`, разделенные двоеточием `:`. Пары разделяются запятыми:

```python
# Создание словаря
my_dict = {
    "name": "Alice",
    "age": 30,
    "city": "New York"
}
print(my_dict)
```

### 24.2 Для чего используются словари:

**Словари используются для**:

- **Хранения данных**, которые логически связаны друг с другом.
- **Быстрого доступа** к значениям по уникальным ключам.
- **Организации данных в структуре**, где каждый элемент имеет уникальный идентификатор.

### 24.3 Получение значения словаря по ключу

**Для получения значения по ключу используется синтаксис** `dict[key]`. Если ключ **не существует**, будет вызвано исключение `KeyError`. Чтобы избежать этого, можно **использовать метод** `get()`, который возвращает `None` (или другое указанное значение) если ключ не найден.

**Пример**:

```python
my_dict = {
    "name": "Alice",
    "age": 30,
    "city": "New York"
}

# Получение значения по ключу
name = my_dict["name"]
print(name)  # Выведет: Alice

# Использование метода get()
age = my_dict.get("age")
print(age)  # Выведет: 30

# Использование метода get() с указанием значения по умолчанию
country = my_dict.get("country", "Unknown")
print(country)  # Выведет: Unknown
```

### 24.4 Особенности ключей в словаре.

- **Уникальность**: Ключи в словаре должны быть **уникальными**. Если вы попытаетесь добавить элемент с уже существующим ключом, **старое значение будет перезаписано новым**.
- **Неизменяемость**: Ключи должны быть **неизменяемыми** (immutable). Это означает, что в качестве ключей можно **использовать** только те типы данных, **которые не могут быть изменены** после их создания.

### 24.5 Типы данных, которые можно использовать в качестве ключей

В качестве **ключей** в словаре можно использовать **следующие неизменяемые типы данных**:

- **Числа** (`integers`, `floats`)
- **Строки** (`strings`)
- **Кортежи** (`tuples`), если они содержат только неизменяемые объекты
- **Булевы значения** (`booleans`)

**Пример**:

```python
my_dict = {
    1: "one",
    3.14: "pi",
    "name": "Alice",
    (1, 2): "tuple",
    True: "boolean"
}
```

### 24.6 Создание словаря

1. Создание словаря с помощью функции `dict()`. Функция `dict()` позволяет **создавать словари различными способами**.

- **Создание пустого словаря**:

  ```python
  empty_dict = dict()
  print(empty_dict)  # Выведет: {}
  ```

- **Создание словаря с парами ключ-значение**:

  ```python
  my_dict = dict(name="Alice", age=30, city="New York")
  print(my_dict)  # Выведет: {'name': 'Alice', 'age': 30, 'city': 'New York'}
  ```

2. **Создание словаря из вложенных списков**. Можно **создать словарь из вложенных списков или кортежей**, где каждый вложенный элемент содержит пару `ключ-значение`.

   ```python
   # Вложенные списки
   list_of_pairs = [["name", "Alice"], ["age", 30], ["city", "New York"]]
   dict_from_list = dict(list_of_pairs)
   print(dict_from_list)  # Выведет: {'name': 'Alice', 'age': 30, 'city': 'New York'}

   # Вложенные кортежи
   tuple_of_pairs = (("name", "Alice"), ("age", 30), ("city", "New York"))
   dict_from_tuple = dict(tuple_of_pairs)
   print(dict_from_tuple)  # Выведет: {'name': 'Alice', 'age': 30, 'city': 'New York'}
   ```

3. **Создать пару "ключ-значение" в словаре**. Использовать синтаксиса `dict[new_key] = value`, чтобы создать пару `ключ-значение`. **Если ключ уже существует, его значение будет перезаписано**. **Если ключа нет, он будет добавлен**.

   ```python
   # Исходный словарь
   my_dict = {'a': 1, 'b': 2}
   # Ключ и значение для добавления
   key_to_add = 'c'
   value_to_add = 3
   # Создание пары ключ-значение
   my_dict[key_to_add] = value_to_add

   print(my_dict) # {'a': 1, 'b': 2, 'c': 3}
   ```

### 24.7 Функции `len()`, оператора `del` и оператора `in` для работы со словарями

- Функция `len()`: возвращает количество пар `ключ-значение` в словаре.

  **Пример**:

  ```python
  my_dict = {'a': 1, 'b': 2, 'c': 3}
  print(len(my_dict))  # Вывод: 3
  ```

- Оператор `del`: используется для **удаления элемента** из словаря по ключу.

  **Пример**:

  ```python
  my_dict = {'a': 1, 'b': 2, 'c': 3}
  del my_dict['b']
  print(my_dict)  # Вывод: {'a': 1, 'c': 3}
  ```

- Оператор `in`: позволяет проверить, **содержится ли ключ в словаре**.

  **Пример**:

  ```python
  my_dict = {'a': 1, 'b': 2, 'c': 3}
  key_to_check = 'b'

  if key_to_check in my_dict:
      print(f"Ключ '{key_to_check}' присутствует в словаре.")
  else:
      print(f"Ключ '{key_to_check}' отсутствует в словаре.")
  ```

### 24.8 Основные методы словаря.

1. `clear()`: **Удаляет все элементы из словаря**.

   ```python
   my_dict = {'a': 1, 'b': 2}
   my_dict.clear()
   print(my_dict)  # {}
   ```

2. `copy()`: **Возвращает копию словаря**.

   ```python
   my_dict = {'a': 1, 'b': 2}
   new_dict = my_dict.copy()
   print(new_dict)  # {'a': 1, 'b': 2}
   ```

3. `fromkeys()`: **Создает новый словарь с заданными ключами и значением по умолчанию**.

   ```python
   keys = ('a', 'b', 'c')
   new_dict = dict.fromkeys(keys, 0)
   print(new_dict)  # {'a': 0, 'b': 0, 'c': 0}
   ```

4. `get()`: **Возвращает значение по ключу, если ключ не найден, возвращает `None` или заданное значение**.

   ```python
   my_dict = {'a': 1, 'b': 2}
   print(my_dict.get('a'))  # 1
   print(my_dict.get('c', 'not found'))  # not found
   ```

5. `items()`: **Возвращает представление пар (`ключ, значение`) словаря**.

   ```python
   my_dict = {'a': 1, 'b': 2}
   print(my_dict.items())  # dict_items([('a', 1), ('b', 2)])
   ```

6. `keys()`: **Возвращает представление `ключей` словаря**.

   ```python
   my_dict = {'a': 1, 'b': 2}
   print(my_dict.keys())  # dict_keys(['a', 'b'])
   ```

7. `values()`: **Возвращает представление значений словаря**.

   ```python
   my_dict = {'a': 1, 'b': 2}
   print(my_dict.values())  # dict_values([1, 2])
   ```

8. `pop()`: **Удаляет элемент с указанным ключом и возвращает его значение**.

   ```python
   my_dict = {'a': 1, 'b': 2}
   value = my_dict.pop('a')
   print(value)  # 1
   print(my_dict)  # {'b': 2}
   ```

9. `popitem()`: **Удаляет и возвращает последнюю добавленную пару (`ключ, значение`)**.

   ```python
   my_dict = {'a': 1, 'b': 2}
   item = my_dict.popitem()
   print(item)  # ('b', 2)
   print(my_dict)  # {'a': 1}
   ```

10. `setdefault()`: **Возвращает значение по ключу, если ключ не существует, добавляет его с заданным значением**.

    ```python
    my_dict = {'a': 1}
    value = my_dict.setdefault('b', 2)
    print(value)  # 2
    print(my_dict)  # {'a': 1, 'b': 2}
    ```

11. `update()`: **Обновляет словарь, добавляя пары (**ключ, значение**) из другого словаря или итерируемого объекта**.

    ```python
    my_dict = {'a': 1}
    my_dict.update({'b': 2, 'c': 3})
    print(my_dict)  # {'a': 1, 'b': 2, 'c': 3}
    ```

### 24.9 Проход по словарю с помощью цикла `for`

1. **Проход по `словарю`**. При проходе по словарю в цикле `for` **по умолчанию перебираются ключи**:

   ```python
   my_dict = {'a': 1, 'b': 2, 'c': 3}

   for key in my_dict:
       print(key)  # Выводит ключи: a, b, c
   ```

2. **Проход по `ключам` словаря**. Можно явно использовать метод `keys()` для **перебора ключей**.

   ```python
   my_dict = {'a': 1, 'b': 2, 'c': 3}

   for key in my_dict.keys():
       print(key)  # Выводит ключи: a, b, c
   ```

3. **Проход по `значениям` словаря**. Для **перебора значений** используйте метод `values()`.

   ```python
   my_dict = {'a': 1, 'b': 2, 'c': 3}

   for value in my_dict.values():
       print(value)  # Выводит значения: 1, 2, 3
   ```

4. **Проход по элементам словаря**. Для **перебора пар (`ключ, значение`)** используйте метод `items()`.

   ```python
   my_dict = {'a': 1, 'b': 2, 'c': 3}

   for key, value in my_dict.items():
       print(f'Ключ: {key}, Значение: {value}')
       # Выводит:
       # Ключ: a, Значение: 1
       # Ключ: b, Значение: 2
       # Ключ: c, Значение: 3
   ```

### Вопросы:

1. Что такое словарь?
2. Способы объявления словаря.
3. Как узнать количество элементов в словаре?
4. Как удалить элемент по ключу?
5. Как проверить наличие ключа в словаре?
6. Какими способами можно создавать копию словаря?
7. Какой метод очищает словарь?
8. Какой метод возвращает значение по ключу?
9. Какой метод удаляет элемент словаря по ключу и возвращает удаленное значение?
10. Какой метод возвращает коллекцию из ключей словаря
11. Какой метод возвращает коллекцию из значений словаря
12. Какой метод возвращает записи в виде кортежей (ключ, значение)

### Задачи:

1. Создайте словарь: `{"Анна": 85, "Борис": 90, "Виктория": 78}`. Программа должна запрашивать у пользователя имя студента и выводить его оценку на экран, либо сообщение `"Студент не найден"`.

2. Создайте словарь: `{ "отлично": 5, "хорошо": 4, "удовлетворительно": 3, "неудовлетворительно": 2 }`. Программа должна запрашивать у пользователя оценку (число) и выводить соответствующее слово. Если оценка не найдена, вывести сообщение `"Такой оценки нет"`.

3. Создайте словарь: `{"Россия": "Москва", "Франция": "Париж", "Италия": "Рим", "Германия": "Берлин"}`. Программа должна запрашивать у пользователя название страны и выводить столицу. Если страна не найдена, вывести `"Страна не найдена"`.

4. На вход программе подаются данные в формате `ключ=значение`, записанные через пробел. Значениями здесь являются целые числа. Необходимо прочитать строку с этими данными и на их основе сформировать словарь `my_dict`, используя функцию `dict()`. Результирующий словарь вывести на экран. Пример входных данных: `one=1 two=2 three=3`.

5. На вход программе подаются данные в формате `ключ=значение`, записанные через пробел. Необходимо прочитать строку с этими данными и на их основе сформировать словарь. Затем проверить, существуют ли в словаре ключи со значениями: `'house'`, `'True'` и `'5'` (все ключи - строки). Если все они существуют, то вывести на экран `"ДА"`, иначе `"НЕТ"`. Пример входных данных: `вологда=город house=дом True=1 5=отлично 9=хорошо`.

6. На вход программе подается строка с названиями продуктов и их стоимостью в формате: `название:цена`. Создайте из этой строки словарь, где ключ — название продукта, значение — цена. Далее запросите у пользователя название продукта и отобразите его цену, если продукт есть в словаре. Если нет, выведите `"Продукт не найден"`. Пример входящей строки: `"Лаваш:85.0 Сыр:799.0 Багет:30.0 Сок:41.99 Макароны:69.99"`.

7. На вход программе подаются данные в формате `ключ=значение`, записанные через пробел. Необходимо прочитать строку с этими данными и на их основе сформировать словарь `my_dict`. Затем удалить из этого словаря ключи `'False'` и `'3'`, если они существуют. Ключами и значениями словаря являются строки. Вывести полученный словарь на экран. Пример входных данных: `лена=имя дон=река москва=город False=ложь 3=удовлетворительно True=истина`.

8. На вход программе подается строка из нескольких целых числе. Создайте словарь, где ключи — `"четные"` и `"нечетные"`, а значения — списки с соответствующими числами. Выведите словарь на экран.

9. На вход программе подается строка из нескольких слов через пробел. Создайте словарь, где ключами будут уникальные слова, а значениями — их количество в строке. Выведите словарь на экран. Пример входящей строки: `"Hello world! This is a test. This test is only a test"`.

10. Создайте словарь: `{'a': 1, 'b': 2, 'c': 3}`. Напишите программу, которая создает новый словарь, где ключи и значения поменяны местами: `{1: 'a', 2: 'b', 3: 'c'}`.

11. Создайте словарь: `{'Иван': 25, 'Кантемир': 30, 'Анна': 30, 'Фатима': 21, 'Петр': 22, 'Азрет': 25}`. Программа должна определить и вывести, кто самый старший и самый младший из пользователей, а также средний возраст.

12. Создайте словарь: `{"Молоко": 50, "Хлеб": 30, "Яблоко": 70, "Курица": 120, "Лаваш": 30, "Макароны": 50, "Сок": 120}`. Создайте новый словарь, где ключи — это уникальные цены, а значения — список товаров с такой ценой. Выведите словарь на экран.

13. На вход программе подаются номера телефонов, записанные в одну строчку через пробел, с разными кодами стран: `+7`, `+6`, `+2`, `+4 `и т.д. Необходимо прочитать строку и на ее основе сформировать словарь d. Ключами словаря должны быть коды (строки: `+7`, `+6`, `+2` и т. п.), а значениями список номеров в виде строк (следующих в том же порядке, что и в исходной строке) с соответствующими кодами. Полученный словарь вывести на экран. Пример входных данных: `+71234567890 +71234567854 +61234576890 +52134567890 +21235777890 +21234567110 +71232267890`. Пример получившегося словаря: `'+2': ['+21235777890', '+21234567110'], '+5': ['+52134567890'], '+6': ['+61234576890'], '+7': ['+71234567890', '+71234567854', '+71232267890']`.

14. На вход программе подается строка из русских букв и символов пробела. Необходимо ее прочитать и закодировать азбукой Морзе, где каждой букве ставится в соответствие код из точки и тире. Полученную строку вывести на экран.

    ```python
    # Словарь морзе
    morze = {
      'а': '.-', 'б': '-...', 'в': '.--', 'г': '--.', 'д': '-..', 'е': '.', 'ё': '.', 'ж': '...-', 'з': '--..', 'и': '..', 'й': '.---', 'к': '-.-', 'л': '.-..', 'м': '--', 'н': '-.', 'о': '---', 'п': '.--.', 'р': '.-.', 'с': '...', 'т': '-', 'у': '..-', 'ф': '..-.', 'х': '....', 'ц': '-.-.', 'ч': '---.', 'ш': '----', 'щ': '--.-', 'ъ': '--.--', 'ы': '-.--', 'ь': '-..-', 'э': '..-..', 'ю': '..--', 'я': '.-.-', ' ': '-...-'
    }
    ```

15. На вход программе подается закодированная строка с помощью азбуки Морзе. Коды разделены между собой пробелом. Необходимо ее раскодировать, используя азбуку Морзе из предыдущего задания. Все буквы в строке должны быть малыми (нижний регистр). Полученное сообщение (строку) вывести на экран. Пример входных данных: `.-- ... . -...- .-- . .-. -. ---`.

## Урок 25. Кортежи (tuple). Методы кортежей.

### 25.1 Что такое Кортежи в Python?

**Кортеж** — это **неизменяемая** последовательность, которая может содержать **элементы разных типов**.

Кортежи используются для **хранения нескольких значений в одной переменной**.

### 25.2 Способы создания кортежа

- **С помощью круглых скобок**:

  ```python
  my_tuple = (1, 2, 3)
  print(my_tuple)
  ```

- **С помощью функции `tuple()`**:

  ```python
  my_tuple = tuple([1, 2, 3])
  print(my_tuple)
  ```

### 25.3 Методы создания пустого кортежа

- **С помощью круглых скобок**:

  ```python
  empty_tuple = ()
  print(empty_tuple)
  ```

- **С помощью функции `tuple()`**:

  ```python
  empty_tuple = tuple()
  print(empty_tuple)
  ```

### 25.4 Методы создания кортежа с одним элементом

Чтобы создать **кортеж с одним элементом, нужно добавить запятую после элемента**:

```python
single_element_tuple = (1,)
print(single_element_tuple)
```

### 25.5 Длина кортежа

**Длину кортежа можно узнать с помощью функции `len()`**:

```python
my_tuple = (1, 2, 3)
print(len(my_tuple))  # 3
```

### 25.6 Использование синтаксиса срезов в кортежах

**Срезы** позволяют **извлекать подмножества элементов** из кортежа:

```python
my_tuple = (1, 2, 3, 4, 5)
sliced_tuple = my_tuple[1:4]
print(sliced_tuple)  # (2, 3, 4)
```

### 25.7 Преимущества кортежей перед другими структурами данных

- **Неизменяемость**: Кортежи **нельзя изменять после создания**, что делает их безопасными для использования в качестве ключей в словарях.
- **Использование** в качестве ключей: Кортежи могут быть использованы **в качестве ключей в словарях**, в отличие от списков.
- **Меньше памяти**: **Кортежи занимают меньше памяти, чем списки**, что делает их более эффективными для хранения фиксированных наборов данных.

### 25.8 Создание кортежа из любого итерируемого объекта

**Кортеж можно создать из любого итерируемого объекта, например, списка или строки**:

```python
my_list = [1, 2, 3]
my_tuple = tuple(my_list)
print(my_tuple)  # (1, 2, 3)

my_string = "abc"
my_tuple_from_string = tuple(my_string)
print(my_tuple_from_string)  # ('a', 'b', 'c')
```

### 25.9 Методы кортежа

**Кортежи имеют несколько встроенных методов**:

1. `count()` — возвращает **количество вхождений элемента в кортеже**.

   ```python
   my_tuple = (1, 2, 2, 3)
   print(my_tuple.count(2))  # 2
   ```

2. `index()` — возвращает **индекс первого вхождения элемента**. **Если значение не найдено, то этот метод приводит к ошибке**.

   ```python
   my_tuple = (1, 2, 3)
   print(my_tuple.index(2))  # 1
   ```

### 25.10 Добавление элемента в кортеж

**В Python кортежи являются неизменяемыми, что означает, что вы не можете добавлять, изменять или удалять элементы после их создания. Однако вы можете создать новый кортеж, объединив существующий кортеж с другим**.

```python
# Исходный кортеж
my_tuple = (1, 2, 3)

# Новый элемент
new_element = 4

# Создание нового кортежа
new_tuple = my_tuple + (new_element,)
print(new_tuple)  # (1, 2, 3, 4)
```

### Вопросы:

1. Способы создания кортежа
2. Основные преимущества использования кортежей
3. Какой метод возвращает количество вхождений элемента в кортеже?
4. Какой метод возвращает индекс первого вхождения элемента?

### Задачи:

1. На вход программе подается строка из чисел, разделённых пробелами. Создайте кортеж из введённых чисел. Найдите сумму всех чисел в кортеже. Выведите сумму в консоль. Пример входных данных: `1 2 3 4 5`.

2. На вход программе подается строка из чисел, разделённых пробелами. Создайте кортеж из введённых чисел. Найдите количество уникальных элементов в кортеже. Выведите в консоль количество уникальных элементов и значение каждого уникального элемента. Пример входных данных: `3 5 7 3 7 2 8 1 5 2`.

3. На вход программе подается строка из чисел, разделённых пробелами. Создайте кортеж из введённых чисел. Проверьте, содержит ли кортеж заданное 5. Выведите "Да", если число присутствует, иначе "Нет". Пример входных данных: `3 5 7 3 7 2 8 1 5 2`.

4. Дан кортеж: (3.4, -56.7). На вход программы подается число с плавающей точкой. Добавьте это число следующим элементом в уже имеющийся кортеж. Выведите кортеж в консоль. Пример входных данных: `89.5`.

5. На вход программе подается строка с названиями городов, записанных через пробел. Создайте кортеж из введённых городов. Если в полученном кортеже нет города "Нальчик", то следует его добавить в конец кортежа. Выведите на экран названия городов из итогового кортежа. Пример входных данных: `Нальчик Москва Казань`.

6. На вход программе подается строка с именами студентов, записанных через пробел. Создайте кортеж из введённых имен. Выведите на экран все имена из этого кортежа, которые содержат фрагмент "ва" (без учета регистра). Пример входных данных: `Василий Аслан Олег Тимур Валандеморт`.

7. Дан список: [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]. Создайте словарь из этого списка, где ключами будут кортежи из двух чисел (например, координаты), а значениями — их сумма. Выведите словарь в консоль.

8. На вход программе подается строка из чисел, разделённых пробелами. Создайте кортеж из введённых чисел. Найдите сумму элементов, находящихся на нечётных позициях. Выведите сумму в консоль. Пример входных данных: `3 5 7 3 7 2 8 1 5 2`.

9. На вход программе подается строка с названиями городов, записанных через пробел. Создайте кортеж из введённых городов. Если в полученном кортеже присутствует город "Ульяновск", то этот элемент следует удалить. Выведите на экран названия городов из итогового кортежа. Пример входных данных: `Нальчик Москва Краснодар Ульяновск Ростов`.

10. На вход программе подаётся строка. Создайте кортеж из символов строки. Составьте словарь, где ключами будут символы, а значениями — их количество в строке. Выведите словарь в консоль. Пример входных данных: `hello friends, hello world!`.

11. На вход программе подается строка из слов, разделённых пробелами. Создайте кортеж из введённой строки. Создайте словарь, где ключами будут индексы слов в кортеже, а значениями — сами слова. Выведите словарь в консоль. Пример входных данных: `apple banana cherry date elderberry`.

12. На вход программе подаются целые числа, записанные в одну строку через пробел. Создайте кортеж из введённых чисел. Создать еще один кортеж с уникальными значениями из первого кортежа. Выведите кортеж в консоль. Пример входных данных: `2 8 11 -5 -2 8 11 -5`.

13. На вход программе подается строка из чисел, разделённых пробелами. Создайте кортеж из введённых чисел. Разделите числа на два списка: чётные и нечётные. В каждом списке не должно быть дубликатов. Выведите оба списка в консоль. Пример входных данных: `3 5 7 3 7 2 8 1 5 2`.

14. На вход программе подаются целые числа, записанные в одну строку через пробел. Создайте кортеж из введённых чисел. Выведите в консоль все индексы неуникальных значений. Пример входных данных: `8 11 -5 -2 8 11 -5`.

## Урок 26. Множества (set). Методы множества.

### 26.1 Что такое Множество в Python?

**Множество** (set) — это **неупорядоченная коллекция уникальных элементов**.  
Множества используются для хранения множества элементов, где каждый элемент может присутствовать только один раз.

Они поддерживают математические операции, такие как **объединение**, **пересечение**, **разность** и **симметрическая разность**.

### 26.2 Способы создания множества

- **Использование литерала множества**:

  ```python
  my_set = {1, 2, 3, 4}
  print(my_set)
  ```

- **Использование функции `set()`**:

  ```python
  my_set = set([1, 2, 3, 4])
  print(my_set)
  ```

- **Создание пустого множества**:

  ```python
  my_set = set()
  print(my_set)
  ```

### 26.3 Какие типы данных можно записывать в множества?

В множества можно записывать **любые неизменяемые (`immutable`) типы данных**, такие как **числа**, **строки**, **кортежи**.

**Изменяемые типы данных**, такие как списки и словари, **не могут быть элементами множества**.

Примеры:

```python
# Числа
num_set = {1, 2, 3.5}
print(num_set)  # Output: {1, 2, 3.5}

# Строки
str_set = {"apple", "banana", "cherry"}
print(str_set)  # Output: {'apple', 'banana', 'cherry'}

# Кортежи
tuple_set = {(1, 2), (3, 4)}
print(tuple_set)  # Output: {(1, 2), (3, 4)}

# Неправильный пример (список внутри множества)
# invalid_set = {[1, 2], [3, 4]}  # Это вызовет ошибку TypeError
```

### 26.4 Создание множества из нескольких итерируемых объектов

```python
# Создание множества из строки
set_from_string = set("hello")
print(set_from_string)  # Output: {'h', 'e', 'l', 'o'}

# Создание множества из списка
set_from_list = set([1, 2, 3, 4, 4, 5])
print(set_from_list)  # Output: {1, 2, 3, 4, 5}

# Создание множества из кортежа
set_from_tuple = set((1, 2, 3, 4, 4, 5))
print(set_from_tuple)  # Output: {1, 2, 3, 4, 5}
```

### 26.5 Множества не поддерживают индексацию, так как они неупорядочены.

**Нельзя обратиться к элементу множества по индексу**, как это делается в списках или кортежах.

### 26.6 Прохождение по всем элементам множества с помощью цикла for

```python
my_set = {1, 2, 3, 4, 5}
for element in my_set:
    print(element)
```

### 26.7 Методы множества

1. `add()` — **добавляет элемент в множество**.

   ```python
   my_set = {1, 2, 3}
   my_set.add(4)
   print(my_set)  # Output: {1, 2, 3, 4}
   ```

2. `remove()` — **удаляет элемент из множества, вызывает ошибку, если элемент не найден**.

   ```python
   my_set = {1, 2, 3}
   my_set.remove(2)
   print(my_set)  # Output: {1, 3}
   ```

3. `discard()` — **удаляет элемент из множества, не вызывает ошибку, если элемент не найден**.

   ```python
   my_set = {1, 2, 3}
   my_set.discard(2)
   print(my_set)  # Output: {1, 3}
   ```

4. `pop()` — **удаляет и возвращает случайный элемент из множества**.

   ```python
   my_set = {1, 2, 3}
   element = my_set.pop()
   print(element)  # Output: 1 (или 2, или 3)
   print(my_set)  # Output: {2, 3} (или {1, 3}, или {1, 2})
   ```

5. `clear()` — **удаляет все элементы из множества**.

   ```python
   my_set = {1, 2, 3}
   my_set.clear()
   print(my_set)  # Output: set()
   ```

6. `union()` — **возвращает объединение множеств**.

   ```python
   set1 = {1, 2, 3}
   set2 = {3, 4, 5}
   union_set = set1.union(set2)
   print(union_set)  # Output: {1, 2, 3, 4, 5}
   ```

7. `intersection()` — **возвращает пересечение множеств**.

   ```python
   set1 = {1, 2, 3}
   set2 = {2, 3, 4}
   intersection_set = set1.intersection(set2)
   print(intersection_set)  # Output: {2, 3}
   ```

8. `difference()` — **возвращает разность множеств**.

   ```python
   set1 = {1, 2, 3}
   set2 = {2, 3, 4}
   difference_set = set1.difference(set2)
   print(difference_set)  # Output: {1}
   ```

9. `symmetric_difference()` — **возвращает симметрическую разность множеств**.

   ```python
   set1 = {1, 2, 3}
   set2 = {2, 3, 4}
   sym_diff_set = set1.symmetric_difference(set2)
   print(sym_diff_set)  # Output: {1, 4}
   ```

10. `issubset()` — **проверяет, является ли множество подмножеством другого множества**.

    ```python
    set1 = {1, 2}
    set2 = {1, 2, 3}
    print(set1.issubset(set2))  # Output: True
    ```

11. `issuperset()` — **проверяет, является ли множество надмножеством другого множества**.

    ```python
    set1 = {1, 2, 3}
    set2 = {1, 2}
    print(set1.issuperset(set2))  # Output: True
    ```

12. `copy()` — **возвращает копию множества**.

    ```python
    set1 = {1, 2, 3}
    set_copy = set1.copy()
    print(set_copy)  # Output: {1, 2, 3}
    ```

### Вопросы:

1. Отличия множества от других структур данных
2. Способы создания множества
3. Какой метод добавляет элемент в множество?
4. Какими методами можно удалить элемент из множества? Их отличия.

### Задачи:

1. На вход программе подаются вещественные числа, записанные в одну строчку через пробел. Необходимо их прочитать и сохранить в множестве s. Выведите на экран значения множества s в порядке возрастания.

2. На вход программе подается строка со словами, разделенные пробелом. Необходимо прочитать эту строку, разбить на слова и с помощью множества подсчитать число уникальных слов (без учета регистра). Результат (число уникальных слов) вывести на экран. Пример входных данных: `Мама мыла раму а потом мыла кота и еще мыла пол`.

3. На вход программе подается строка, содержащая латинские символы, пробелы и цифры. Необходимо прочитать эту строку и выделить из нее все неповторяющиеся цифры (символы от 0 до 9). Выведите на экран все найденные уникальные цифры в одну строчку через пробел в порядке возрастания их значений. Если цифры отсутствуют, то вывести строку "НЕТ". Пример входных данных: `Python 3.9.11 - best language!`. Пример выходных данных: `1 3 9`.

4. В ночном клубе фиксируется список гостей. Причем гости могут выходить из помещения, а затем, снова заходить. Тогда их имена фиксируются повторно. На вход программы поступает такой список. Требуется подсчитать по списку lst_in общее число гостей, которые посетили ночной клуб. Полагается, что гости имеют уникальные имена. На экран вывести общее число гостей клуба.

5. На вход программе подаются названия городов, каждое с новой строки. Необходимо в цикле читать эти названия, пока не встретится строка "q". С помощью множества определить общее уникальное число городов, которые читались в программе (за исключением "q"). На экран вывести это число.

6. На вход программе подаются два списка целых чисел, каждый с новой строки (в строке наборы чисел следующих через пробел). Необходимо прочитать эти наборы чисел и сохранить их в отдельных списках (или кортежах). Затем, с помощью множеств(а) выбрать только уникальные числа, присутствующие и в первом и во втором списках одновременно. Результат выведите на экран. Пример входных данных: `8 11 12 15 -2` и `4 11 10 15 -5 1 -2`.

7. На вход программе подаются два списка целых чисел, каждый с новой строки (в строке наборы чисел следующих через пробел). Необходимо прочитать эти наборы чисел и сохранить их в отдельных списках (или кортежах). Затем, с помощью множеств(а) выбрать уникальные числа, присутствующие в первом списке, но отсутствующие во втором. Результат выведите на экран. Пример входных данных: `8 5 3 5 -3 1` и `1 2 3 4`.

8. На вход программе подаются два списка целых чисел, каждый с новой строки (в строке наборы чисел следующих через пробел). Необходимо прочитать эти наборы чисел и сохранить их в отдельных списках (или кортежах). Затем, с помощью множеств(а) выбрать уникальные числа, присутствующие в первом или втором списках, но отсутствующие одновременно в обоих. Результат выведите на экран. Пример входных данных: `1 2 3 4 5` и `4 5 6 7 8`.

9. На вход программе подаются две строки со списком городов, каждый с новой строки (в строках названия городов следуют через пробел). Необходимо прочитать эти строки и сохранить их в отдельных списках (или кортежах). Затем, с помощью множеств(а) сравнить их между собой на равенство по уникальным (не повторяющимся) городам. Если списки содержат одни и те же уникальные города (не важно в каком порядке), то вывести на экран "ДА", иначе "НЕТ". Пример входных данных: `Москва Тверь Уфа Казань Уфа Москва` и `Уфа Тверь Москва Казань`.

## Урок 27. Генераторы множеств. Генераторы словарей.

### 27.1 Генератор множеств.

**Генератор множеств** — это удобный способ создания множеств (`set`) с использованием выражений.

- **Синтаксис**:

  ```
  {выражение for элемент in итерируемый_объект}
  ```

### 27.2 Пример: Выделение уникальных значений из списка.

```python
my_list = [1, 2, 2, 3, 4, 4, 5]
unique_values = {x for x in my_list}
print(unique_values)  # {1, 2, 3, 4, 5}
```

### 27.3 Генератор словарей.

**Генератор словарей** позволяет создавать словари с использованием аналогичного синтаксиса.  
Он используется для создания пар "ключ-значение".

- **Синтаксис**:

  ```
  {ключ: значение for элемент in итерируемый_объект}
  ```

### 27.4 Пример: Поменять местами значения и ключи

```python
my_dict = {"неудовл.": 2, "удовл.": 3, "хорошо": '4', "отлично": '5'}
swapped_dict = {value: key for key, value in my_dict.items()}
print(swapped_dict)
# {2: 'неудовл.', 3: 'удовл.', '4': 'хорошо', '5': 'отлично'}
```

### Вывод:

Таким образом, генераторы множеств и словарей в Python позволяют эффективно создавать коллекции с использованием компактного и понятного синтаксиса.

### Задачи:

1. На вход программе подается строка со списком оценок, например: `2 неудовлетворительно удовлетворительно хорошо отлично`. Первая цифра - это числовое значение первой оценки. Остальные оценки имеют возрастающие числа на 1. Необходимо прочитать эту строку и с помощью генератора словарей сформировать словарь d, в котором ключами будут выступать числа, а значениями - слова.

2. На автомойку в течение квартала заезжали машины. Их гос. номера фиксировались в журнале, следующим образом: `auto = ["Е220СК","А120МВ","В101АА","Е220СК","А120МВ"]`. На основе этого списка через генератор множеств сформировать еще один список уникальных машин. На экран вывести число уникальных машин.

3. На вход программе подается строка со словами, записанными через пробел. Необходимо прочитать эту строку и с помощью генератора множеств сформировать множество из уникальных слов без учета регистра и длина которых не менее трех символов. Вывести на экран размер этого множества.

4. На парковке записывают номера машин и время их пребывания: `cars = [("Е220СК", 3), ("А120МВ", 5), ("В101АА", 2), ("Е220СК", 1), ("А120МВ", 3)]`. формируйте словарь, где ключами будут номера машин, а значениями — общее время пребывания на парковке. Затем создайте множество машин, которые провели на парковке больше 3 часов. Выведите оба результата.

5. У вас есть список продуктов с их ценами и категориями: `products = [("Яблоки", 50, "Фрукты"), ("Бананы", 40, "Фрукты"), ("Молоко", 70, "Молочные"), ("Хлеб", 30, "Хлебобулочные")]`. Сформируйте словарь, где ключами будут категории, а значениями — суммы цен продуктов из этих категорий. Затем найдите категорию с наибольшими расходами. Выведите оба результата.

6. На вход программе подаются строки с именами клиентов и их заказами, разделённые пробелом, пока пользователь не введет слово `exit` (без учета регистра). Сформируйте словарь, где ключами будут имена клиентов, а значениями — множества уникальных заказов каждого клиента. Выведите итоговый словарь. Пример входных данных:

   ```
   Иван чай
   Анна кофе
   Иван булка
   Сергей чай
   Анна торт
   ```

7. На вход программе подаётся текст: `Привет мир! Этот мир полон чудес. Python помогает изучать этот мир.`. Создайте множество уникальных слов, удаляя пунктуацию и приводя их к нижнему регистру. Строка с символами пунктуации: `!"#$%&'()*+,-./:;<=>?@[\]^_{|}~`. Затем создайте словарь, где ключами будут эти слова, а значениями — длина каждого слова. Выведите оба результата.

## Урок 28: Функции. Оператор return.

### 28.1 Что такое функции?

**Функция в программировании** — это **именованный блок кода**, предназначенный для **выполнения определённой задачи**. Она **создаётся один раз** и **может быть вызвана любое количество раз**. Это позволяет упрощать и структурировать код.

**Пример функции**:

```python
def greeting():
    print("Welcome!")
```

#### Функции выполняют несколько ключевых задач:

- **Разделение задач на логические блоки**. Вместо **длинного кода, который сложно читать и поддерживать, мы можем разделить программу на небольшие функции, каждая из которых отвечает за конкретный аспект работы**.
- **Повторное использование кода**. Вызвав функцию, вы можете использовать её функционал без необходимости переписывать код.
- **Повышение читаемости и тестируемости**. Код становится более понятным и легко проверяемым, когда его структура разбита на функции.

#### Сравнение с другими подходами.

Без функций:

```python
# Повторяющийся код
print("Welcome!")
print("Welcome!")
print("Welcome!")
```

С функцией:

```python
def greeting():
    print("Welcome!")
    print("Welcome!")
    print("Welcome!")

# Вызов функции
greeting()
greeting()
```

### 28.2 Синтаксис функции

**Функция создаётся** с использованием ключевого слова `def`, за которым следует **имя функции**, **круглые скобки** (возможно, с параметрами) и **двоеточие**. После этого идёт **тело функции — отступы обязательны**.

**Пример**:

```python
def function_name():
    # Тело функции
    print("This is an example function.")
```

#### Именование функций.

- **Используйте `snake_case` для названий**: слова разделяются подчёркиваниями и пишутся с маленькой буквы (`calculate_sum`, `get_result`).
- **Название должно быть осмысленным**: оно должно отражать, **что делает функция**.

### 28.3 Использование `return`

**Оператор `return`** **завершает выполнение функции** и **возвращает результат, который можно использовать в дальнейшем**.

**Пример с использованием `return`**:

```python
def add(a, b):
    return a + b

result = add(3, 5)  # Функция возвращает 8
print(result)       # Вывод: 8
```

**Функции без `return`** просто **выполняют действия**, но **не возвращают результат**.

**Пример без `return`**:

```python
def add_and_print(a, b):
    print(a + b)

add_and_print(3, 5)  # Вывод: 8, но результат не сохранён
```

### 28.4 Функции с параметрами

**Функции могут принимать входные данные — `параметры`**, которые **указываются в круглых скобках**. Это позволяет **гибко настраивать выполнение функции**.

**Пример**:

```python
def greeting(name):
    print(f"Hello, {name}!")

greeting("Anna")  # Вывод: Hello, Anna!
greeting("John")  # Вывод: Hello, John!
```

**Порядок аргументов имеет значение**. При вызове функции переданные значения сопоставляются с параметрами **в том порядке, в котором они указаны**.

**Пример**:

```python
def multiply(a, b):
    return a * b

result = multiply(2, 3)  # 2 * 3 = 6
print(result)
```

### 28.5 Возврат нескольких значений

**Функция может возвращать сразу несколько значений** с помощью кортежа. Это удобно, когда требуется передать несколько результатов.

**Пример**:

```python
def calculate(a, b):
    total = a + b
    difference = a - b
    return total, difference  # Возвращается кортеж

result = calculate(7, 3)
print(result)  # Вывод: (10, 4)
```

**Можно сразу распаковать значения**:

```python
total, difference = calculate(7, 3)
print(total)      # Вывод: 10
print(difference) # Вывод: 4
```

**Альтернативный способ** — возвращение списка, **если количество возвращаемых значений варьируется**.

**Пример**:

```python
def get_even_numbers(numbers):
    even_numbers = [x for x in numbers if x % 2 == 0]
    return even_numbers

result = get_even_numbers([1, 2, 3, 4, 5])
print(result)  # Вывод: [2, 4]
```

### Заключение:

**Функции** являются **мощным инструментом для создания структурированного, читаемого и многократно используемого кода**.

**Использование оператора `return` позволяет работать с результатами, делая функции ещё более гибкими**.

**Параметры и возможность возвращать несколько значений открывают множество вариантов для решения сложных задач**.

### Вопросы:

1. Что такое функция в программировании, и зачем она нужна?
2. Какие преимущества даёт использование функций по сравнению с повторяющимися блоками кода?
3. Какое ключевое слово используется для объявления функции в Python? Приведите пример.
4. Какие правила именования функций следует соблюдать в Python, согласно стандарту PEP 8?
5. Что делает оператор return в функции? В чём его отличие от использования функции, которая просто печатает (print)?
6. Как передаются параметры в функцию? Объясните с помощью примера.
7. Что произойдёт, если поменять порядок аргументов при вызове функции? Как это можно избежать?
8. Как функция может возвращать несколько значений?
9. Что будет, если функция с оператором return не возвращает никакого значения? Какое значение вернётся по умолчанию?

### Задачи:

1. Объявите в программе функцию, которая не имеет параметров и просто выводит на экран следующую строку: `It's my first function`. После объявления вызовите эту функцию.

2. Объявите в программе функцию без параметров, которая читает из входного потока (с клавиатуры) имя и фамилию, записанные в одну строку через пробел, и выводит на экран сообщение (без кавычек): `Уважаемый, <имя> <фамилия>! Вы верно выполнили это задание!`. После объявления вызовите эту функцию.

3. Объявите в программе функцию, которая имеет один параметр - вес предмета, и выводит на экран сообщение: `Предмет имеет вес: x кг.`, где `x` - переданное значение (аргумент) функции. После объявления функции прочитайте (с помощью функции `input`) вещественное число и вызовите функцию с этим числовым значением.

4. Объявите в программе функцию, которая в качестве параметра принимает список (`list`), находит максимальное, минимальное и сумму значений этого списка и выводит результат на экран в виде строки. После объявления функции прочитайте (с помощью функции `input`) строку целых чисел, записанных в одну строку через пробел, и вызовите функцию с передачей ей этого списка.

5. Объявите функцию с именем `is_triangle`, которая принимает три стороны треугольника (целые числа) и проверяет, можно ли из переданных аргументов составить треугольник. (Напомню, что у любого треугольника длина любой его стороны должна быть меньше суммы двух других). Если проверка проходит, функция должна возвращать булево значение `True`, а иначе `False`.

6. Объявите в программе функцию с одним параметром для проверки переданного числа на четность. Функция должна возвращать булево значение `True`, если переданное число четное и `False`, в противном случае. После объявления функции в цикле на каждой итерации необходимо читать (с помощью функции `input`) целочисленное числовое значение. Цикл должен работать пока `x` не равен `1`. Если прочитанное значение `x` четное (проверяется с помощью ранее объявленной функции), то число выводится на экран (каждое с новой строки).

7. На склад доставки поступает информация о статусе заказов. Вам необходимо создать функцию, которая проверяет, были ли доставлены все заказы. Информация о статусе заказов представлена в виде словаря, где ключом является идентификатор заказа, а значением — статус заказа. Если все заказы имеют статус `"доставлен"`, функция должна возвращать строку `"Все заказы доставлены"`. Если есть хотя бы один недоставленный заказ, функция должна возвращать список, содержащий идентификаторы таких заказов. Пример словаря с заказами:

   ```python
   d = {
       'A2b3': "доставлен",
       'x7Y4': "ожидание",
       'c1D8': "доставлен",
       '9eF0': "доставлен",
       'z3Q1': "доставлен",
   }
   ```

8. На вход программе подается строка чисел, разделенных пробелами. Создайте функцию, которая возвращает максимальное число из списка чисел, введенных пользователем. Нельзя пользоваться функцией `max()`. Пример входных данных: `12 45 78 34 89 23`.

9. На вход программы подается строка, содержащая список товаров и их цен в формате: `товар1 цена1; товар2 цена2; товар3 цена3;`. Напишите функцию, которая будет принимать строку с товарами и их ценами, рассчитывать скидку в 10% на каждую цену товара и возвращать словарь, где ключами являются названия товаров, а значениями — цены с учетом скидки. Пример входных данных: `хлеб 50; молоко 80; сыр 250`.

## Урок 29: Аргументы функции (позиционные и именованные аргументы, аргументы по умолчанию).

**Функции** — это не просто блоки кода, которые выполняют действия. Они — **основа организации программ**, позволяющая писать **эффективный**, **читаемый** и **универсальный код**. Чтобы сделать функции по-настоящему гибкими, нам нужно уметь передавать им данные. Это возможно благодаря аргументам, которые выступают **"мостом"** между вызовом функции и ее внутренним кодом.

### 29.1 Обзор типов аргументов

**Аргументы** — это **значения, передаваемые в функцию** при ее вызове. Они позволяют **параметризовать работу функции** и **сделать её универсальной**.

**Основные виды аргументов**:

- **Позиционные аргументы**.
- **Именованные аргументы**.
- **Аргументы по умолчанию**.

**Аргументы** позволяют **управлять входными данными функции**, **задавать поведение по умолчанию** и **создавать более читаемый код**.

### 29.2 Позиционные аргументы

**Позиционные аргументы** — это те, которые **передаются в функцию в строгом порядке**.

Давайте представим, что мы пишем **программу для расчета стоимости товара**:

```python
def calculate_price(price, quantity):
    total = price * quantity
    print(f"Цена за {quantity} единиц(ы) товара: {total} руб.")
```

Эта функция ожидает **два аргумента**:

- **price** — цена одной единицы товара.
- **quantity** — количество.

Порядок передачи важен! Давайте посмотрим, что произойдет, если перепутать местами значения:

```python
calculate_price(100, 2)  # Вывод: Цена за 2 единицы товара: 200 руб.
calculate_price(2, 100)  # Вывод: Цена за 100 единиц товара: 200 руб.
```

**Ошибки нет, но логика нарушена**. Если вы передаёте аргументы позиционно, убедитесь, что их порядок соответствует определению функции.

Позиционные аргументы особенно полезны, если их **немного** и их **порядок очевиден**.

### 29.3 Именованные аргументы

**Именованные аргументы** позволяют избежать путаницы с порядком. **Вместо передачи значений по позициям, вы явно указываете, какому параметру какое значение соответствует**.

Вернёмся к примеру с ценой товара, но теперь используем именованные аргументы:

```python
calculate_price(price=100, quantity=2)  # Вывод: Цена за 2 единицы товара: 200 руб.
calculate_price(quantity=2, price=100)  # Вывод: Цена за 2 единицы товара: 200 руб.
```

Как видите, **порядок перестал быть важным**. Это особенно удобно, когда в **функции много параметров**, и важно явно указать, за что отвечает каждое значение.

**Пример**: Представьте **форму заказа, где клиент может заполнить несколько полей, но не обязательно все**. Использование именованных аргументов помогает сделать вызов функции более наглядным:

```python
def place_order(dish, drink="вода", dessert=None):
    order = f"Ваш заказ: {dish} и {drink}"
    if dessert:
        order += f", десерт: {dessert}"
    print(order)

place_order("паста", dessert="мороженое")
# Вывод: Ваш заказ: паста и вода, десерт: мороженое
```

### 29.4 Аргументы по умолчанию

**Аргументы по умолчанию** — это **параметры, для которых можно заранее задать значение**. Если при вызове функции эти аргументы не указаны, используется значение по умолчанию.

**Пример**: Представьте программу для создания визитных карточек. Если пользователь не указывает компанию, мы считаем, что он — "Фрилансер". Это позволяет упростить создание визиток для частных специалистов.

```python
def create_business_card(name, phone, company="Фрилансер"):
    print(f"Имя: {name}")
    print(f"Телефон: {phone}")
    print(f"Компания: {company}")

# Если компания не указана, значение по умолчанию — "Фрилансер"
create_business_card("Анна", "+7-900-123-45-67")

# Пользователь явно указывает компанию
create_business_card("Иван", "+7-900-765-43-21", company="ТехноСтар")
```

**Аргументы со значением по умолчанию** всегда **указываются после обязательных аргументов**.

```python
def incorrect_function(a=10, b):  # Ошибка!
    pass
```

Нужно поменять порядок аргументов:

```python
def correct_function(b, a=10):
    pass
```

**Значения по умолчанию делают функцию универсальной и удобной**, особенно в случаях, когда большинство вызовов используют стандартные параметры.

### 29.5 Комбинирование разных типов аргументов

**Чтобы функции оставались удобными и универсальными, часто приходится комбинировать позиционные, именованные и аргументы по умолчанию**. Давайте напишем функцию для оформления заказа в ресторане:

```python
def order_food(main_course, drink="вода", dessert=None):
    print(f"Основное блюдо: {main_course}")
    print(f"Напиток: {drink}")
    if dessert:
        print(f"Десерт: {dessert}")

# Сценарии вызова:
order_food("пицца")                      # Вывод: Напиток: вода, Десерт: отсутствует
order_food("паста", dessert="пирожное")  # Задаём только десерт
order_food("суши", drink="сок")          # Указываем только напиток
```

### 29.6 Ошибки и тонкости

**Работая с аргументами, важно понимать, какие ошибки могут возникнуть**:

- **Пропущенные аргументы**: Если обязательные аргументы не переданы, Python выдаст ошибку:

  ```python
  def greet(name, age):
      print(f"Привет, {name}! Тебе {age} лет.")

  greet("Андрей")  # Ошибка: аргумент age не передан
  ```

- **Дублирование аргументов**: Если один и тот же аргумент передан и позиционно, и как именованный, Python не сможет понять, какое значение использовать:
  ```python
  greet("Андрей", age=25, name="Иван")  # Ошибка
  ```

### Вопросы:

1. Что такое позиционные аргументы? Как они передаются в функцию? Приведите пример.
2. Чем именованные аргументы отличаются от позиционных? Какой из способов вызова функции лучше использовать для читабельности кода?
3. Почему нельзя размещать обязательные аргументы после аргументов со значением по умолчанию в объявлении функции?
4. Что произойдёт, если вы попытаетесь передать значение именованного аргумента дважды: один раз как позиционный и второй раз как именованный?

### Задачи:

1. Напишите функцию `check_registration`, которая принимает имя и возраст пользователя. Если возраст меньше 18, функция возвращает строку: `"Регистрация запрещена." `Иначе: `"Вы успешно зарегистрированы!"` Аргумент age должен быть по умолчанию равен 17. Проверить работу функции.

2. Создайте словарь с продуктами и их ценами `products = {"Яблоко": 100, "Банан": 80, "Виноград": 150}`. Напишите функцию `apply_discount(products, discount=10)`, которая принимает название продукта и скидку в процентах. Значение скидки по умолчанию должно быть `10` процентов. Функция возвращает словарь с названиями продуктов и их итоговыми ценами. Проверить работу функции.

3. Объявите в программе функцию с именем `check_password`, которая первым параметром принимает строку (пароль) и имеет второй параметр `chars` с начальным значением в виде строки `"$%!?@#"`. Функция должна проверять, есть ли в пароле хотя бы один символ из chars и что длина пароля не менее 8 символов. Если проверка проходит, то функция возвращает булево `True`, иначе `False`.

4. На вход программе подается строка. Напишите функцию `character_statistics(text, ignore_spaces=True)`, которая считает количество букв, цифр и остальных символов. Аргумент `ignore_spaces` определяет, учитывать ли пробелы. Пример входных данных: `Python 3.8 is awesome!`.

5. На вход программе подается строка со словами записанными через пробел и минимальная длина строки. Напишите функцию `filter_strings(strings, min_length=5)`, которая возвращает список строк, длина которых больше или равна минимальной длине.

6. Напишите функцию `generate_password`, которая создает пароль заданной длины из цифр, букв и символов. Используйте цикл для генерации символов.

7. Создайте словарь курсов валют. Напишите функцию `convert_currency(amount, currency="USD")`, которая конвертирует сумму в указанную валюту. Курсы:` {"USD": 60, "EUR": 70}`.

8. Объявите в программе функцию, которая первым параметром принимает строку, а второй формальный параметр `tag` с начальным значением в виде строки `"h1"` определяет тег, в который должна заключаться первая переданная строка. Например, мы передаем строку `"Hello Python"` и заключаем в тег `"h1"`. Функция должна вернуть строку (без кавычек): `<h1>Hello Python</h1>`. После объявления функции далее в программе прочитайте из входного потока строку и дважды вызовите функцию (с выводом результата ее работы на экран): первый раз только со строкой, второй раз со строкой и именованным аргументом `tag` со значением `'div'`.

## Урок 30: Обработка произвольного количества аргументов (\*args и \*\*kwargs)

### 30.1 Что такое \*args и \*\*kwargs

`*args `и `**kwargs` — это специальные конструкции в Python, которые позволяют **передавать функции произвольное количество позиционных** (`*args`) или **именованных** (`**kwargs`) аргументов.

- `*args` собирает переданные позиционные аргументы в кортеж.
- `**kwargs` собирает переданные именованные аргументы в словарь.

**Иногда** при создании функций **невозможно заранее предугадать**, сколько аргументов понадобится. Используя `*args` и `**kwargs`, мы можем сделать функцию более гибкой, не ограничивая пользователя в количестве передаваемых аргументов.

### 30.2 Объяснение механизма работы \*args

Когда **функция** принимает `*args`, она преобразует все позиционные аргументы в кортеж. Это значит, что **внутри функции можно перебирать эти аргументы с помощью цикла или обращаться к ним по индексу**.

**Пример**:

```python
def process_numbers(*args):
    print("Переданные числа:", args)

process_numbers(1, 2, 3, 4, 5)
```

**Пример функции с обработкой `*args`**: Создадим функцию, которая суммирует все переданные числа.

```python
def sum_numbers(*args):
    total = 0  # Инициализируем переменную для суммы
    for number in args:  # Перебираем все переданные аргументы
        total += number  # Добавляем каждый аргумент к общей сумме
    return total

print(sum_numbers(1, 2, 3, 4))  # 10
print(sum_numbers(10, 20, 30))  # 60
```

#### Ограничения \*args:

- `*args` не может обрабатывать именованные аргументы. Передача таких аргументов вызовет ошибку:

  ```python
  def process_numbers(*args):
      print(args)

  process_numbers(a=5)  # Ошибка: именованные аргументы нельзя передать через *args
  ```

- Позиционные аргументы перед `*args` обязательны и должны быть указаны первыми:

  ```python
  def example(arg1, *args):
      print(arg1, args)

  example(10, 20, 30)  # arg1 = 10, args = (20, 30)
  ```

### 30.3 Объяснение механизма работы \*\*kwargs

Когда функция принимает `**kwargs`, она преобразует все именованные аргументы в словарь, где ключи — это имена аргументов, а значения — их значения.

**Пример**:

```python
def display_info(**kwargs):
    print("Переданные данные:", kwargs)

display_info(name="Alice", age=25, country="USA")
```

**Пример функции с обработкой** `**kwargs`: Создадим функцию, которая выводит переданные параметры в формате **"ключ: значение"**.

```python
def print_info(**kwargs):
    for key in kwargs:  # Перебираем ключи словаря
        print(f"{key}: {kwargs[key]}")  # Выводим ключ и соответствующее значение

print_info(name="Alice", age=25, country="USA")
```

### 30.4 Комбинирование \*args и \*\*kwargs

**Можно объединять оба механизма в одной функции**. При этом порядок аргументов должен быть следующим:

- **Позиционные аргументы**.
- `*args` (**дополнительные позиционные аргументы**).
- **Именованные аргументы с значениями по умолчанию**.
- `**kwargs` (**дополнительные именованные аргументы**).

**Пример**:

```python
def full_function(arg1, *args, arg2=10, **kwargs):
    print(f"Обязательный аргумент: {arg1}")
    print(f"Дополнительные позиционные аргументы: {args}")
    print(f"Именованный аргумент с дефолтным значением: {arg2}")
    print(f"Именованные аргументы: {kwargs}")

full_function(1, 2, 3, arg2=20, name="Alice", age=25)
```

### 30.5 Передача аргументов с помощью \* и \*\*

`*` и `**` можно использовать для **распаковки списков и словарей в аргументы функций**.

**Пример Распаковки списка в** `*args`:

```python
def process_numbers(*args):
    for num in args:
        print(num)

numbers = [10, 20, 30]
process_numbers(*numbers)
```

**Пример Распаковки словаря в** `**kwargs`:

```python
def display_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

info = {'name': 'Alice', 'age': 25, 'country': 'USA'}
display_info(**info)
```

**Пример Комбинации распаковок**:

```python
def full_function(*args, **kwargs):
    print("Позиционные аргументы:", args)
    print("Именованные аргументы:", kwargs)

numbers = [1, 2, 3]
info = {'name': 'Alice', 'age': 25}
full_function(*numbers, **info)
```

### 30.6 Практические примеры использования:

1. **Функция для расчета средней оценки**. Создадим функцию, которая **принимает произвольное количество оценок (позиционные аргументы) и возвращает `среднюю оценку`**:

   ```python
   def calculate_average(*args):
       total = 0
       count = 0
       for grade in args:
           total += grade
           count += 1
       return total / count if count > 0 else 0

   print(calculate_average(85, 90, 78, 92))  # 86.25
   print(calculate_average(100, 95))        # 97.5
   ```

2. **Конструктор данных для двумерного списка**. Функция **принимает количество строк и столбцов как первые два аргумента**, а **дополнительные аргументы (\*args) — это значения, которые нужно распределить по ячейкам**.

   ```python
   def create_matrix(rows, cols, *args):
       matrix = []
       values = list(args)
       index = 0
       for i in range(rows):
           row = []
           for j in range(cols):
               if index < len(values):
                   row.append(values[index])
                   index += 1
               else:
                   row.append(0)  # Если значений меньше, чем ячеек, заполняем нулями
           matrix.append(row)
       return matrix

   matrix = create_matrix(3, 3, 1, 2, 3, 4, 5)
   for row in matrix:
       print(row)
   ```

3. **Функция проверки условий**. Функция **принимает переменную, список условий через \*args (например, строки `"проверить больше 5"`, `"проверить четность"`), а затем выводит результаты каждой проверки**.

   ```python
   def check_conditions(value, *args):
       results = []
       for condition in args:
           if condition == "проверить больше 5":
               results.append(value > 5)
           elif condition == "проверить четность":
               results.append(value % 2 == 0)
           elif condition == "проверить отрицательное":
               results.append(value < 0)
           else:
               results.append(False)  # Если условие неизвестно
       return results

   print(check_conditions(7, "проверить больше 5", "проверить четность"))  # [True, False]
   print(check_conditions(-3, "проверить отрицательное"))                 # [True]
   ```

4. **Построение дерева параметров из \*\*kwargs**. Функция **принимает именованные аргументы** (`**kwargs`) и **строит иерархическую структуру, где ключи становятся узлами дерева**.

   ```python
   def build_tree(**kwargs):
       tree = {}
       for key, value in kwargs.items():
           if isinstance(value, dict):  # Если значение — это словарь, рекурсивно создаем поддерево
               tree[key] = build_tree(**value)
           else:
               tree[key] = value
       return tree

   nested_tree = build_tree(
       root1={"child1": {"leaf1": "data1", "leaf2": "data2"}},
       root2={"child2": {"leaf3": "data3"}}
   )

   print(nested_tree)
   ```

5. **Комбинация** `*args` и `**kwargs` **для динамической фильтрации данных**. Функция **принимает список чисел** (`*args`) **и параметры фильтрации через** `**kwargs`**(например,`min_value`, `max_value`)**, а затем **возвращает отфильтрованный список**.

   ```python
   def filter_numbers(*args, **kwargs):
       min_value = kwargs.get('min_value', float('-inf'))
       max_value = kwargs.get('max_value', float('inf'))
       only_even = kwargs.get('only_even', False)

       filtered = []
       for number in args:
           if min_value <= number <= max_value:
               if only_even and number % 2 != 0:
                   continue  # Пропускаем нечетные числа, если фильтр установлен
               filtered.append(number)
       return filtered

   print(filter_numbers(1, 2, 3, 4, 5, 6, min_value=3, max_value=5, only_even=True))  # [4]
   print(filter_numbers(10, 15, 20, only_even=True))                                # [10, 20]
   ```

6. **Генератор отчетов о данных**. Функция **принимает названия секций** (`*args`) **и информацию по каждой секции через** `**kwargs`. **Каждая секция отображается с соответствующими данными**.

   ```python
   def generate_report(*args, **kwargs):
       report = ""
       for section in args:
           report += f"Секция: {section}\n"
           if section in kwargs:
               data = kwargs[section]
               for key, value in data.items():
                   report += f"  {key}: {value}\n"
           else:
               report += "  Нет данных\n"
           report += "\n"
       return report

   report = generate_report(
       "Продажи", "Финансы", "Персонал",
       Продажи={"Январь": 5000, "Февраль": 7000},
       Финансы={"Бюджет": 10000, "Расходы": 8000}
   )
   print(report)
   ```

### Вопросы:

1. Что такое `*args` в Python?
2. Что такое `**kwargs` в Python?
3. В какой тип данных собираются аргументы, переданные через `*args`?
4. В какой тип данных собираются аргументы, переданные через `**kwargs`?
5. Могут ли `*args` и `**kwargs` использоваться в одной функции?
6. Какие ограничения есть у `*args`?
7. Какой тип аргументов следует указывать перед `*args`?
8. Можно ли указать аргументы по умолчанию в функции с `*args` и `**kwargs`?
9. Какой порядок следования аргументов должен быть в функции с `*args` и `**kwargs`?
10. Почему важно учитывать порядок аргументов при использовании `*args` и `**kwargs`?

### Задачи:

1. Создать функцию, которая принимает `*args` и возвращает сумму всех переданных чисел.

   - **Пример входных данных**:
     ```python
     1, 2, 3, 4, 5
     ```
   - **Ожидаемый результат**:
     ```python
     15
     ```

2. Создать функцию, которая принимает `**kwargs` и возвращает строку, содержащую все ключи и значения в формате ключ=значение.

   - Пример входных данных:

     ```python
     name="John", age=30, city="New York"
     ```

   - Ожидаемый результат:

     ```python
     "name=John, age=30, city=New York"
     ```

3. Создать функцию, которая принимает `*args` и возвращает кортеж, содержащий только строки.

   - **Пример входных данных**:
     ```python
     "hello", 123, "world", 456
     ```
   - Ожидаемый результат:
     ```python
     ("hello", "world")
     ```

4. Создать функцию, которая принимает `**kwargs` и возвращает список ключей, у которых значения — строки.

   - **Пример входных данных**:

     ```python
     a=10, b="hello", c=3.14, d="world"
     ```

   - **Ожидаемый результат**:

     ```python
     ["b", "d"]
     ```

5. Создать функцию, которая принимает строку, преобразует её в список слов и возвращает количество слов, длина которых больше 4. Используйте `*args`.

   - **Пример входных данных**:

     ```python
     "The quick brown fox jumps over the lazy dog"
     ```

   - **Ожидаемый результат**:

     ```python
     3
     ```

6. Создать функцию, которая принимает `*args`, преобразует каждое строковое значение в заглавные буквы и возвращает их в списке.

   - **Пример входных данных**:

     ```python
     "python", "is", "fun", 123
     ```

   - **Ожидаемый результат**:

     ```python
     ["PYTHON", "IS", "FUN"]
     ```

7. Создать функцию, которая принимает `**kwargs` и возвращает новый словарь, где все значения преобразованы в строки.

   - **Пример входных данных**:

     ```python
     a=10, b=True, c=None
     ```

   - **Ожидаемый результат**:

     ```python
     {"a": "10", "b": "True", "c": "None"}
     ```

8. Создать функцию, которая принимает `*args` и `**kwargs`, а затем проверяет, есть ли в `*args` элементы, совпадающие с любыми значениями в `**kwargs`.

   - **Пример входных данных**:

     ```python
     *args: 10, 20, 30, "hello"
     **kwargs: a=30, b="world", c="hello"
     ```

   - **Ожидаемый результат**:

     ```python
     ["hello", 30]
     ```

9. Создать функцию, которая принимает строку, преобразует её в словарь (`ключ:значение` через запятую) и возвращает новый словарь, где к каждому значению добавляется префикс из `**kwargs`.

   - **Пример входных данных**:

     ```python
     "a:1, b:2, c:3", prefix="value_"
     ```

   - **Ожидаемый результат**:

     ```python
     {"a": "value_1", "b": "value_2", "c": "value_3"}
     ```

10. Создать функцию, которая принимает список чисел через `*args` и возвращает словарь, где ключами будут индексы, а значениями — числа, умноженные на коэффициент из `**kwargs`.

    - **Пример входных данных**:

      ```python
      1, 2, 3, multiplier=2
      ```

    - **Ожидаемый результат**:

      ```python
      {0: 2, 1: 4, 2: 6}
      ```

11. Создать функцию, которая принимает `\*args`, где каждое значение — строка, и возвращает словарь с подсчетом количества каждого уникального слова.

    - **Пример входных данных**:

      ```python
      "apple", "banana", "apple", "orange", "banana", "banana"
      ```

    - Ожидаемый результат:

      ```python
      {"apple": 2, "banana": 3, "orange": 1}
      ```

12. Создать функцию, которая принимает `*args` и `**kwargs` и проверяет, присутствует ли в `*args` строка, начинающаяся с ключей из `**kwargs`.

    - **Пример входных данных**:

      ```python
      *args: "apple", "banana", "cherry", "apricot"
      **kwargs: prefix1="ap", prefix2="ba"
      ```

    - **Ожидаемый результат**:

      ```python
      ["apple", "banana", "apricot"]
      ```

13. Создать функцию, которая принимает `*args` и `**kwargs`, затем группирует все переданные аргументы в словарь. В kwargs записываются те, что начинаются с буквенных префиксов, а в `*args` — все остальные.

    - **Пример входных данных**:

      ```python
      *args: "123", "apple", 456, "banana"
      **kwargs: prefix1="ap", prefix2="ba"
      ```

    - **Ожидаемый результат**:

      ```python
      {"prefix1": ["apple"], "prefix2": ["banana"], "args": ["123", 456]}
      ```

## Урок 31: Лямбда-функции. Функции map(), filter(), sorted().

### 31.1 Что такое лямбда-функции?

**Лямбда-функции** — это **анонимные функции, которые создаются с помощью ключевого слова `lambda`**. Они позволяют **описывать простые однострочные функции без необходимости их явного объявления через `def`**.

#### Лямбда-функции полезны, когда:

- **Требуется быстро создать простую функцию**.
- **Функция нужна только для короткого использования**.
- **Использование именованной функции кажется избыточным**.

#### Преимущества лямбда-функций:

- **Компактность**: код становится короче.
- **Гибкость**: удобно использовать как аргумент в функциях **высшего порядка** (map, filter, sorted).

#### Ограничения:

- **Лямбда-функция может содержать только одно выражение**.
- **Отсутствие аннотаций типов аргументов**.
- **Сложные выражения могут снизить читаемость**.

### 31.2 Общая структура

- Синтаксис лямбда-функции:

  ```
  lambda аргументы: выражение
  ```

  - **Аргументы**: **список входных параметров, разделенных запятыми**.
  - **Выражение**: **одно выражение, результат которого возвращается автоматически**.

**Пример лямбда-функции для сложения двух чисел**:

```python
add = lambda x, y: x + y
print(add(2, 3))  # Вывод: 5
```

**Эта функция эквивалентна следующей функции**, определенной через `def`:

```python
def add(x, y):
    return x + y
```

### 31.3 Примеры простых лямбда-функций

#### Пример 1: Возведение числа в квадрат

```python
square = lambda x: x**2
print(square(5))  # Вывод: 25
```

#### Пример 2: Проверка числа на четность

```python
is_even = lambda x: x % 2 == 0
print(is_even(4))  # Вывод: True
print(is_even(5))  # Вывод: False
```

#### Пример 3: Вычисление площади прямоугольника

```python
rectangle_area = lambda length, width: length * width
print(rectangle_area(4, 5))  # Вывод: 20
```

### 31.4 Функции высшего порядка. Функции `map()`, `filter()`, `sorted()`

**Функция** считается `функцией высшего порядка`, если она:

- **Принимает другую функцию в качестве аргумента**.
- **Возвращает функцию в качестве результата**.
- **Примеры функций** высшего порядка в Python — это `map()`, `filter()`, `sorted()`.

**Эти функции часто используются вместе с `лямбда-функциями`** для выполнения сложных операций над данными.

### 31.5 Краткое описание функций

**Функции `map()`, `filter()`, и `sorted()` часто используются для работы с последовательностями**. Рассмотрим их базовые примеры.

- **Функция** `map()` **применяет заданную функцию ко всем элементам последовательности и возвращает новый итератор**.

  **Синтаксис**:

  ```python
  map(функция, последовательность)
  ```

  **Пример: Преобразование чисел в строки**

  ```python
  def to_string(x):
      return str(x)

  numbers = [1, 2, 3, 4]
  result = list(map(to_string, numbers))
  print(result)  # Вывод: ['1', '2', '3', '4']
  ```

  **Здесь каждый элемент списка numbers преобразуется в строку с помощью функции `to_string`**.

- **Функция** `filter()` **выбирает только те элементы последовательности, для которых заданная функция возвращает `True`**.

  **Синтаксис**:

  ```python
  filter(функция, последовательность)
  ```

  **Пример: Отбор чисел больше 5**

  ```python
  def greater_than_five(x):
      return x > 5

  numbers = [3, 6, 8, 2, 7]
  result = list(filter(greater_than_five, numbers))
  print(result)  # Вывод: [6, 8, 7]
  ```

  **Здесь из списка numbers отбираются только числа, которые больше 5**.

- **Функция** `sorted()` **возвращает новый отсортированный список из элементов последовательности**.

  **Синтаксис**:

  ```python
  sorted(последовательность, key=функция, reverse=логическое_значение)
  ```

  - `key`: задает функцию для определения порядка сортировки (опционально).
  - `reverse`: если `True`, **сортировка выполняется в обратном порядке**.

  **Пример: Сортировка списка строк по алфавиту**

  ```python
  words = ['banana', 'apple', 'cherry']
  result = sorted(words)
  print(result)  # Вывод: ['apple', 'banana', 'cherry']
  ```

  **Пример: Сортировка чисел в обратном порядке**

  ```python
  numbers = [5, 2, 9, 1]
  result = sorted(numbers, reverse=True)
  print(result)  # Вывод: [9, 5, 2, 1]
  ```

### 31.6 Использование `map()` с лямбда-функциями

**Функция `map()` проходит по каждому элементу последовательности и применяет к нему указанную функцию**.

- **Пример: Умножение каждого элемента списка на 2**

  ```python
  numbers = [1, 2, 3, 4, 5]
  doubled = list(map(lambda x: x * 2, numbers))
  print(doubled)  # Вывод: [2, 4, 6, 8, 10]
  ```

- **Пример: Преобразование строк в заглавные буквы**
  ```python
  words = ["hello", "world"]
  uppercase = list(map(lambda word: word.upper(), words))
  print(uppercase)  # Вывод: ['HELLO', 'WORLD']
  ```

### 31.7 Использование `filter()` с лямбда-функциями

**Функция `filter()` возвращает только те элементы, для которых функция-условие возвращает `True`**.

- **Пример: Фильтрация четных чисел**
  ```python
  numbers = [1, 2, 3, 4, 5]
  evens = list(filter(lambda x: x % 2 == 0, numbers))
  print(evens)  # Вывод: [2, 4]
  ```
- **Пример: Фильтрация строк длиной больше 3 символов**
  ```python
  words = ["cat", "elephant", "dog", "mouse"]
  long_words = list(filter(lambda word: len(word) > 3, words))
  print(long_words)  # Вывод: ['elephant', 'mouse']
  ```

### 31.8 Использование `sorted()` с лямбда-функциями

**Функция `sorted()` позволяет сортировать последовательности на основе функции, переданной в параметре `key`**.

- **Пример: Сортировка списка кортежей по второму элементу**
  ```python
  pairs = [(1, 'a'), (3, 'c'), (2, 'b')]
  sorted_pairs = sorted(pairs, key=lambda x: x[1])
  print(sorted_pairs)  # Вывод: [(1, 'a'), (2, 'b'), (3, 'c')]
  ```
- **Пример: Сортировка списка словарей по значению ключа**
  ```python
  people = [{"name": "Alice", "age": 25}, {"name": "Bob", "age": 20}]
  sorted_people = sorted(people, key=lambda person: person['age'])
  print(sorted_people)
  # Вывод: [{'name': 'Bob', 'age': 20}, {'name': 'Alice', 'age': 25}]
  ```

### 31.9 Комбинирование функций `map()`, `filter()`, и `sorted()`

**Эти функции можно объединять для создания цепочек преобразований данных**.

- **Пример: Отобрать четные числа, возвести их в квадрат и отсортировать**
  ```python
  numbers = [1, 2, 3, 4, 5, 6]
  result = sorted(
      map(lambda x: x**2, filter(lambda x: x % 2 == 0, numbers))
  )
  print(result)  # Вывод: [4, 16, 36]
  ```
- **Пример: Преобразование строк и их сортировка по длине**
  ```python
  words = ["apple", "banana", "kiwi", "cherry"]
  result = sorted(
      map(lambda word: word.upper(), filter(lambda word: len(word) > 4, words)),
      key=lambda word: len(word)
  )
  print(result)  # Вывод: ['APPLE', 'BANANA', 'CHERRY']
  ```

### 31.10 Примеры близкие к реальным задачам.

1. **Обработка списка товаров с ценами**

   **Предположим, у нас есть список товаров с их названиями и ценами**.

   Нужно:

   - **Преобразовать названия товаров в заглавные буквы**.
   - **Отобрать только товары дороже 50 единиц**.
   - **Отсортировать оставшиеся товары по цене по убыванию**.

     ```python
     products = [
         {"name": "apple", "price": 30},
         {"name": "banana", "price": 20},
         {"name": "cherry", "price": 60},
         {"name": "date", "price": 80},
     ]

     # 1. Преобразуем названия товаров в заглавные буквы
     products = list(map(lambda p: {**p, "name": p["name"].upper()}, products))

     # 2. Отбираем только товары дороже 50 единиц
     expensive_products = list(filter(lambda p: p["price"] > 50, products))

     # 3. Сортируем товары по цене по убыванию
     sorted_products = sorted(expensive_products, key=lambda p: p["price"], reverse=True)

     print(sorted_products)
     ```

2. **Анализ посещений сайта**

   **Имеется список посещений сайта в виде (страница, количество посещений)**.

   Нужно:

   - **Увеличить количество посещений на `10%`**.
   - **Отобрать страницы с посещениями больше `500`**.
   - **Отсортировать страницы по убыванию количества посещений**.

     ```python
     visits = [
         ("homepage", 450),
         ("products", 600),
         ("blog", 300),
         ("contact", 800),
     ]

     # 1. Увеличиваем количество посещений на 10%
     updated_visits = list(map(lambda v: (v[0], int(v[1] * 1.1)), visits))

     # 2. Отбираем страницы с посещениями больше 500
     popular_pages = list(filter(lambda v: v[1] > 500, updated_visits))

     # 3. Сортируем по убыванию посещений
     sorted_pages = sorted(popular_pages, key=lambda v: v[1], reverse=True)

     print(sorted_pages)
     ```

3. **Управление списком сотрудников**

   **Есть список сотрудников с их именами и зарплатами**.

   Задача:

   - **Преобразовать имена сотрудников, чтобы они начинались с заглавной буквы**.
   - **Отобрать только тех сотрудников, чья зарплата превышает среднюю по компании**.
   - **Отсортировать таких сотрудников по имени в алфавитном порядке**.

     ```python
     employees = [
         {"name": "john", "salary": 50000},
         {"name": "jane", "salary": 60000},
         {"name": "doe", "salary": 45000},
         {"name": "smith", "salary": 70000},
     ]

     # 1. Преобразуем имена сотрудников
     employees = list(map(lambda e: {**e, "name": e["name"].capitalize()}, employees))

     # 2. Рассчитываем среднюю зарплату
     average_salary = sum(e["salary"] for e in employees) / len(employees)

     # Отбираем сотрудников с зарплатой выше средней
     above_average = list(filter(lambda e: e["salary"] > average_salary, employees))

     # 3. Сортируем таких сотрудников по имени
     sorted_employees = sorted(above_average, key=lambda e: e["name"])

     print(sorted_employees)
     ```

4. **Подготовка данных для графиков**

   **Представим, что у нас есть данные о продажах за год в виде (месяц, доход)**.

   Нужно:

   - **Преобразовать названия месяцев в их порядковые номера (январь = 1, февраль = 2 и т.д.)**.
   - **Отобрать месяцы, где доход был выше `100000`**.
   - **Отсортировать их по возрастанию дохода**.

     ```python
     sales = [
         ("January", 95000),
         ("February", 120000),
         ("March", 130000),
         ("April", 85000),
     ]

     # Словарь для преобразования названий месяцев в номера
     month_to_number = {
         "January": 1, "February": 2, "March": 3, "April": 4,
         "May": 5, "June": 6, "July": 7, "August": 8,
         "September": 9, "October": 10, "November": 11, "December": 12
     }

     # 1. Преобразуем названия месяцев в номера
     numbered_sales = list(map(lambda s: (month_to_number[s[0]], s[1]), sales))

     # 2. Отбираем месяцы с доходом выше 100000
     high_income_months = list(filter(lambda s: s[1] > 100000, numbered_sales))

     # 3. Сортируем по возрастанию дохода
     sorted_high_income = sorted(high_income_months, key=lambda s: s[1])

     print(sorted_high_income)
     ```

### Вопросы:

1. Что такое `lambda-функция` в Python?
2. Чем `lambda-функции` отличаются от обычных функций, определяемых с помощью `def`?
3. В каких случаях удобно использовать `lambda-функции`?
4. Что такое функции высшего порядка? Назовите примеры таких функций.
5. Для чего используется функция `map()`? Какие аргументы она принимает?
6. Для чего используется функция `filter()`? Какие аргументы она принимает?
7. Что возвращает функция `filter()`? Как преобразовать результат функции в список?
8. Какова роль функции `sorted()`? Какие параметры можно указать в её вызове?
9. Чем полезен параметр `key` в функциях `sorted()` и `map()`?
10. Могут ли `lambda-функции` принимать несколько аргументов? Если да, то приведите пример общего синтаксиса.
11. Если в `filter()` передать условие, которое никогда не выполняется, что будет возвращено?

### Задачи:

1. **Преобразование строк в числа**. У вас есть список строк, представляющих числа. Преобразуйте их в список чисел с помощью `map()`.

   - **Входные данные**:

     ```python
     numbers = ["1", "2", "3", "4", "5"]
     ```

   - **Ожидаемый результат**:

     ```python
     [1, 2, 3, 4, 5]
     ```

2. **Увеличение чисел**. Дан список чисел. С помощью `map()` увеличьте каждое число на `10`.

   - Входные данные:

     ```python
     nums = [5, 10, 15, 20]
     ```

   - Ожидаемый результат:

     ```python
     [15, 20, 25, 30]
     ```

3. **Фильтрация строк по длине**. Дан список строк. Оставьте только те строки, длина которых больше 4 символов, используя `filter()`.

   - **Входные данные**:

     ```python
     words = ["apple", "cat", "banana", "dog", "kiwi"]
     ```

   - **Ожидаемый результат**:

     ```python
     ["apple", "banana"]
     ```

4. **Сортировка строк по алфавиту**. Дан список строк. Отсортируйте его в обратном алфавитном порядке с помощью `sorted()`.

   - **Входные данные**:

     ```python
     cities = ["Paris", "London", "Berlin", "Tokyo"]
     ```

   - **Ожидаемый результат**:

     ```python
     ["Tokyo", "Paris", "London", "Berlin"]
     ```

5. **Преобразование имен**. Дан список имен. Сделайте так, чтобы все имена начинались с заглавной буквы, используя `map()`.

   - **Входные данные**:

     ```python
     names = ["john", "sara", "michael", "anna"]
     ```

   - **Ожидаемый результат**:

     ```python
     ["John", "Sara", "Michael", "Anna"]
     ```

6. **Отбор четных чисел**. Дан список чисел. Оставьте только четные числа, используя `filter()`.

   - **Входные данные**:

     ```python
     nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]
     ```

   - **Ожидаемый результат**:

     ```python
     [2, 4, 6, 8]
     ```

7. **Удвоение четных чисел**. Дан список чисел. Увеличьте только четные числа в два раза, используя `map()`.

   - **Входные данные**:

     ```python
     nums = [1, 2, 3, 4, 5, 6]
     ```

   - **Ожидаемый результат**:

     ```python
     [1, 4, 3, 8, 5, 12]
     ```

8. **Фильтрация пользователей по возрасту**. Дан словарь, где ключи — имена, а значения — возраст. Оставьте только тех пользователей, возраст которых больше `18`.

   - **Входные данные**:

     ```python
     users = {"Alice": 25, "Bob": 17, "Charlie": 19, "David": 15}
     ```

   - **Ожидаемый результат**:

     ```python
     {"Alice": 25, "Charlie": 19}
     ```

9. **Сортировка товаров по цене**. Дан список словарей, где каждый словарь представляет товар с ценой. Отсортируйте список по возрастанию цен.

   - **Входные данные**:

     ```python
     products = [{"name": "apple", "price": 100}, {"name": "banana", "price": 80}, {"name": "cherry", "price": 150}]
     ```

   - **Ожидаемый результат**:

     ```python
     [{"name": "banana", "price": 80}, {"name": "apple", "price": 100}, {"name": "cherry", "price": 150}]
     ```

10. **Удаление пустых строк**. Дан список строк. Удалите все пустые строки с помощью `filter()`.

    - **Входные данные**:

      ```python
      lines = ["hello", "", "world", "", "python"]
      ```

    - **Ожидаемый результат**:

      ```python
      ["hello", "world", "python"]
      ```

11. **Сортировка сотрудников по имени**. Дан список сотрудников, представленных словарями. Отсортируйте их по имени, не учитывая регистр букв.

    - **Входные данные**:

      ```python
      employees = [{"name": "John", "age": 28}, {"name": "alice", "age": 24}, {"name": "Bob", "age": 30}]
      ```

    - **Ожидаемый результат**:

      ```python
      [{"name": "alice", "age": 24}, {"name": "Bob", "age": 30}, {"name": "John", "age": 28}]
      ```

12. **Фильтрация и преобразование списка пользователей**. Дан список словарей, где каждый словарь представляет пользователя с его именем и возрастом. Оставьте только тех, кому больше `20 лет`, и преобразуйте имена в заглавные буквы.

    - **Входные данные**:

      ```python
      users = [{"name": "john", "age": 19}, {"name": "sara", "age": 22}, {"name": "mike", "age": 20}]
      ```

    - **Ожидаемый результат**:

      ```python
      [{"name": "SARA", "age": 22}]
      ```

13. **Сортировка заказов по дате**. Дан список заказов, где каждая дата представлена строкой. Отсортируйте их по убыванию даты.

    - **Входные данные**:

      ```python
      orders = [{"id": 1, "date": "2023-11-28"}, {"id": 2, "date": "2023-10-15"}, {"id": 3, "date": "2023-12-01"}]
      ```

    - **Ожидаемый результат**:

      ```python
      [{"id": 3, "date": "2023-12-01"}, {"id": 1, "date": "2023-11-28"}, {"id": 2, "date": "2023-10-15"}]
      ```

14. **Анализ текстовых данных**. Дана строка текста. Найдите все слова длиннее 4 символов, преобразуйте их в заглавные буквы и отсортируйте по алфавиту.

    - **Входные данные**:

      ```python
      text = "Python is a powerful programming language for data analysis"
      ```

    - **Ожидаемый результат**:

      ```python
      ["ANALYSIS", "LANGUAGE", "POWERFUL", "PROGRAMMING"]
      ```

15. **Анализ статистики заказов**. Дан список заказов, где каждый заказ представлен словарем с полем `price`. Найдите все заказы дороже `1000`, округлите их цены до сотен и отсортируйте по убыванию цены.

    - **Входные данные**:

      ```python
      orders = [{"id": 1, "price": 950}, {"id": 2, "price": 1200}, {"id": 3, "price": 850}, {"id": 4, "price": 1500}]
      ```

    - **Ожидаемый результат**:

      ```python
      [{"id": 4, "price": 1500}, {"id": 2, "price": 1200}]
      ```

## Урок 32: Глобальные и локальные переменные. Импорт и работа с модулями в Python

### 32.1 Пространство имен (Namespace)

**Пространство имен (`namespace`)** — это **механизм, который связывает имена** (переменные, функции, классы) **с их значениями**. В Python **каждое имя существует в определенном пространстве имен**, чтобы избежать конфликтов между именами.

#### **Типы пространств имен**:

- **Локальное** (`Local`) — **существует внутри функции**. Переменные, объявленные внутри функции, принадлежат локальному пространству имен.
- **Глобальное** (`Global`) — **существует на уровне модуля**. Переменные, объявленные **вне всех функций, принадлежат глобальному пространству имен**.

**Пример**:

```python
x = 10  # Глобальное пространство имен

def my_function():
    x = 5  # Локальное пространство имен
    print(f"Локальная переменная x: {x}")

my_function()
print(f"Глобальная переменная x: {x}")
```

#### **Поиск имени выполняется в следующем порядке**:

1. **Локальное** пространство имен функции.
2. **Глобальное** пространство имен модуля.
3. **Встроенное** пространство имен Python (содержит встроенные функции Python, такие как `print()`, `len()`).

### 32.2 Глобальные переменные и оператор `global`

#### **Оператор `global`** позволяет изменять значение глобальной переменной внутри функции.

```python
counter = 0  # Глобальная переменная

def increment():
    global counter  # Даем доступ к глобальной переменной
    counter += 1

increment()
print(counter)  # Вывод: 1
```

#### **Оператор `global`** позволяет **создать глобальную переменную внутри функции**

```python
def create_global():
    global new_var
    new_var = "I am global now!"

create_global() # Создаем глобальную переменную
print(new_var)  # Вывод: I am global now!
```

### 32.3 Конфликт имен в Python: локальная и глобальная область видимости

**Если переменная с одинаковым именем объявлена и в `глобальной`, и в `локальной` области видимости, то Python будет использовать `локальную` переменную внутри функции, а глобальная переменная останется неизменной**.

**Пример конфликта имен**:

```python
my_str = "Global" # Глобальная переменная

def my_function():
    my_str = "Local" # Локальная переменная с таким же именем
    print(f"Локальная переменная my_str внутри функции: {my_str}")

# Вызов функции
my_function()

# Глобальная переменная остается неизменной
print(f"Глобальная переменная my_str вне функции: {my_str}")
```

#### **Ошибки при конфликте имен**

**Если попытаться изменить глобальную переменную внутри функции без использования `global`**, Python выдаст **ошибку** `UnboundLocalError`. Это происходит потому, что Python считает, что **вы пытаетесь использовать локальную переменную до ее объявления**.

```python
x = 10

def my_function():
    x += 5  # Ошибка: попытка изменить глобальную переменную без global
    print(x)

my_function()
```

**В случае конфликта имен между локальной и глобальной областью видимости Python всегда отдает приоритет локальной переменной**. Чтобы изменить глобальную переменную внутри функции, необходимо **использовать оператор `global`**.

### 32.4 Оператор `nonlocal`. Внешняя область видимости.

**Оператор `nonlocal` в Python используется для работы с переменными, которые находятся во `внешней области видимости`, но `не являются глобальными`**. Это позволяет изменять переменные, объявленные во внешней функции, из вложенной функции.

#### **Оператор nonlocal применяется в следующих случаях**:

- Когда у вас **есть вложенные функции** (функции внутри функций).
- Когда **нужно изменить значение переменной, объявленной во внешней функции, из внутренней функции**.
- Когда **переменная не является глобальной, но находится в области видимости внешней функции**.

#### **Как работает nonlocal?**

- Если вы **объявляете переменную с помощью `nonlocal`, Python ищет эту переменную во внешней области видимости** (но не в глобальной).
- Если **переменная найдена, она становится доступной для изменения внутри вложенной функции**.
- Если **переменная не найдена, Python выдаст ошибку `SyntaxError`**.

#### **Изменение переменной внешней функции**:

```python
def outer_function():
    x = 10  # Переменная во внешней функции

    def inner_function():
        nonlocal x  # Указываем, что будем использовать переменную из внешней функции
        x += 5  # Изменяем значение переменной
        print(f"Внутри inner_function: x = {x}")

    inner_function()
    print(f"Внутри outer_function: x = {x}")

outer_function()
```

#### **Несколько вложенных функций**:

**Оператор `nonlocal`** позволяет работать с переменными **на любом уровне вложенности**.

```python
def outer_function():
    x = 10  # Переменная во внешней функции

    def middle_function():
        def inner_function():
            nonlocal x  # Используем переменную из outer_function
            x += 5
            print(f"Внутри inner_function: x = {x}")

        inner_function()
        print(f"Внутри middle_function: x = {x}")

    middle_function()
    print(f"Внутри outer_function: x = {x}")

outer_function()
```

#### **Использование nonlocal для замыканий**:

**Оператор `nonlocal`** используется в `замыканиях` для **сохранения состояния между вызовами функций**.

```python
def counter():
    count = 0  # Переменная для хранения состояния

    def increment():
        nonlocal count
        count += 1
        return count

    return increment

# Создаем замыкание
counter_function = counter()

print(counter_function())  # Вывод: 1
print(counter_function())  # Вывод: 2
print(counter_function())  # Вывод: 3
```

### 32.5 Стандартные модули Python.

**Python предоставляет множество стандартных модулей, которые позволяют разработчикам использовать готовые функции и классы для выполнения различных задач**. Эти модули **являются частью стандартной библиотеки Python** и могут быть легко **импортированы в ваши программы**.

#### **Модуль `random`**

**Модуль `random` предоставляет функции для генерации случайных чисел**. Он полезен в играх, симуляциях и других приложениях, где требуется случайность.

```python
import random

# Генерация случайного числа от 1 до 10
random_number = random.randint(1, 10) # генерирует случайное целое число в заданном диапазоне.
print(f"Случайное число: {random_number}")

# Генерация случайного числа с плавающей точкой от 0 до 1
random_float = random.random() # возвращает случайное число с плавающей точкой от 0 до 1
print(f"Случайное число с плавающей точкой: {random_float}")

# Перемешивание списка
my_list = [1, 2, 3, 4, 5]
random.shuffle(my_list) # перемешивает элементы списка на месте
print(f"Перемешанный список: {my_list}")
```

#### **Модуль `datetime`**

**Модуль `datetime` предоставляет классы для работы с датами и временем**. Он позволяет выполнять операции с датами, форматировать их и получать текущее время.

```python
from datetime import datetime, timedelta

# Получение текущей даты и времени
now = datetime.now() # возвращает текущую дату и время
print(f"Текущая дата и время: {now}")

# Форматирование даты
formatted_date = now.strftime("%Y-%m-%d %H:%M:%S") # используется для форматирования даты в строку
print(f"Отформатированная дата: {formatted_date}")

# Добавление 7 дней к текущей дате
future_date = now + timedelta(days=7) # позволяет выполнять арифметические операции с датами, например, добавлять или вычитать дни
print(f"Дата через 7 дней: {future_date}")
```

#### **Модуль `os`**

**Модуль `os` предоставляет функции для взаимодействия с операционной системой**. Он позволяет работать с файловой системой, управлять процессами и получать информацию о среде выполнения.

```python
import os

# Получение текущей рабочей директории
current_directory = os.getcwd() # возвращает путь к текущей рабочей директории
print(f"Текущая рабочая директория: {current_directory}")

# Список файлов в текущей директории
files = os.listdir(current_directory) # возвращает список файлов и папок в указанной директории
print(f"Файлы в текущей директории: {files}")

# Создание новой директории
new_directory = "new_folder"
os.makedirs(new_directory, exist_ok=True) # создает новую директорию, если она не существует
print(f"Создана директория: {new_directory}")
```

### 32.6 Операторы `import`, `from` и `as`

**В Python для работы с модулями и пакетами используются операторы `import`, `from` и `as`**. Эти операторы позволяют разработчикам **организовывать код, повторно использовать функции и классы, а также улучшать читаемость и структуру программ**.

#### **Оператор `import`**

**Оператор `import` используется для импорта целого модуля**. После импорта модуля, все его **функции и классы доступны через его имя**.

```python
import math

# Используем функцию sqrt из модуля math
result = math.sqrt(16)
print(f"Квадратный корень из 16: {result}")
```

#### **Оператор `from`**

**Оператор `from` позволяет импортировать конкретные функции или классы из модуля**. Это удобно, когда вам нужны только определенные элементы из модуля, и вы хотите избежать необходимости указывать имя модуля каждый раз.

```python
from math import pi, sin

# Используем импортированные функции и константы напрямую
print(f"Число π: {pi}")
print(f"Синус 90 градусов: {sin(90)}")
```

#### **Оператор `as`**

**Оператор `as` позволяет задать псевдоним для модуля или функции**. Это может быть полезно для **сокращения длинных имен или для избежания конфликтов имен**, особенно если вы импортируете несколько модулей с одинаковыми именами.

```python
import numpy as np

# Используем псевдоним np для доступа к функциям модуля numpy
array = np.array([1, 2, 3, 4])
print(f"Созданный массив: {array}")
```

#### Сравнение методов импорта

- `import module_name`: **Импортирует весь модуль**. Используется, когда нужно много функций из модуля, и вы хотите сохранить ясность кода.
- `from module_name import function_name`: **Импортирует конкретные функции или классы**. Удобно, когда нужны только определенные элементы.
- `import module_name as alias`: **Импортирует модуль с псевдонимом**. Полезно для сокращения длинных имен или избежания конфликтов.

### 32.7 Создание собственных модулей.

`Модуль в Python` — **это файл с расширением `.py`, который содержит код на языке Python**. Он может **включать функции, классы и переменные, которые могут быть использованы в других файлах**. **Создание модулей** позволяет **структурировать код и разделять его на более мелкие, управляемые части**.

#### **Создание собственного модуля**

- **Создание файла модуля**: `my_module.py`
- **Определение функций в модуле**:
  - `greet(name)`: принимает имя и возвращает приветствие.
  - `add(a, b)`: принимает два числа и возвращает их сумму.
  - `multiply(a, b)`: принимает два числа и возвращает их произведение.

```python
# my_module.py

def greet(name):
    """Функция для приветствия пользователя."""
    return f"Привет, {name}!"

def add(a, b):
    """Функция для сложения двух чисел."""
    return a + b

def multiply(a, b):
    """Функция для умножения двух чисел."""
    return a * b
```

#### **Использование функций из собственного модуля**.

**Пример содержимого `main.py`**:

```python
# main.py

# Импортируем весь модуль
import my_module

# Используем функции из модуля
name = "Алиса"
greeting = my_module.greet(name)
print(greeting)  # Вывод: Привет, Алиса!

# Используем функции для математических операций
sum_result = my_module.add(5, 3)
print(f"Сумма: {sum_result}")  # Вывод: Сумма: 8

product_result = my_module.multiply(4, 7)
print(f"Произведение: {product_result}")  # Вывод: Произведение: 28
```

**Пример использования `from`**:

```python
# main.py

# Импортируем конкретные функции из модуля
from my_module import greet, add

# Используем импортированные функции
name = "Боб"
greeting = greet(name)
print(greeting)  # Вывод: Привет, Боб!

# Используем функцию для сложения
sum_result = add(10, 5)
print(f"Сумма: {sum_result}")  # Вывод: Сумма: 15
```

### 32.8 Константы в Python

**В Python `константы` представляют собой значения, которые не должны изменяться в течение выполнения программы**. Хотя в Python `нет встроенного механизма для объявления констант`, **существует общепринятая практика: константы обычно именуются с использованием заглавных букв и подчеркиваний для разделения слов**. Это позволяет разработчикам легко **отличать константы от обычных переменных**.

#### **Создание модуля с константами**

Создадим файл `constants.py`, в котором определим несколько констант:

```python
# constants.py

PI = 3.14159
E = 2.71828
GRAVITY = 9.81  # Ускорение свободного падения, м/с²
```

#### **Создание модуля с функциями**

Теперь создадим другой **модуль, который будет содержать функции, использующие эти константы**. Назовем его `math_functions.py`.

```python
# math_functions.py

from constants import PI, GRAVITY

def circle_area(radius):
    """Вычисляет площадь круга по заданному радиусу."""
    return PI * (radius ** 2)

def free_fall_time(height):
    """Вычисляет время падения с заданной высоты."""
    return (2 * height / GRAVITY) ** 0.5
```

#### **Использование модулей в основном файле**

Теперь **создадим основной файл `main.py`**.

```python
# main.py

from math_functions import circle_area, free_fall_time

# Пример использования функции для вычисления площади круга
radius = 5
area = circle_area(radius)
print(f"Площадь круга с радиусом {radius}: {area}")

# Пример использования функции для вычисления времени падения
height = 20
time = free_fall_time(height)
print(f"Время падения с высоты {height} м: {time:.2f} секунд")
```

### 32.9 Конструкция `if __name__ == "__main__"`

`Конструкция if __name__ == "__main__"` является важным элементом в Python, который **позволяет определить, выполняется ли файл как основная программа или импортируется как модуль в другой файл**. Это помогает **избежать выполнения определенного кода при импорте модуля**, что делает код более гибким и управляемым.

#### **Зачем нужна эта конструкция?**

1. **Разделение логики**: Конструкция позволяет **разделить код, который должен выполняться при запуске файла**, и **код, который должен выполняться только при импорте**. Это **особенно полезно для тестирования и отладки**.

2. **Управление импортом**: **Когда файл импортируется как модуль, код внутри блока `if __name__ == "__main__"` не будет выполнен**. Это п**редотвращает нежелательные побочные эффекты**, которые могут возникнуть при выполнении кода, предназначенного только для запуска.

3. **Удобство тестирования**: Вы можете **включать тесты или демонстрационные функции в файл**, который также может быть использован как модуль, не беспокоясь о том, что они будут выполнены при каждом импорте.

#### **Пример 1: Основная программа и модуль**

**Создадим два файла: `module.py` и `main.py`**.

```python
# module.py

def greet(name):
    return f"Привет, {name}!"

if __name__ == "__main__":
    # Этот код выполнится только при запуске module.py
    print(greet("Мир"))
```

```python
# main.py

from module import greet

# Используем функцию greet из модуля
print(greet("Алиса"))
```

**Объяснение**:

- Если вы запустите `module.py`, выведется `"Привет, Мир!"`.
- Если вы запустите `main.py`, выведется `"Привет, Алиса!"`, и код внутри `if __name__ == "__main__"` в `module.py` не выполнится.

#### Пример 2: Тестирование функций

**Вы можете использовать эту конструкцию для включения тестов в модуль**.

```python
# calculator.py

def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

if __name__ == "__main__":
    # Тестирование функций
    print("Тестирование функций:")
    print(f"2 + 3 = {add(2, 3)}")
    print(f"5 - 2 = {subtract(5, 2)}")
```

**Объяснение**:

- При запуске `calculator.py` будут выполнены тесты для функций `add` и `subtract`.
- Если вы импортируете `calculator` в другой файл, тесты не будут выполнены, и вы сможете использовать функции без лишнего вывода.

### 32.10 Примеры, приближенные к реальным проектам

#### **Пример 1: Создание 100 пользователей с рандомными именами**

- **Модуль `user_generator.py`**

  ```python
  import random
  import string

  # Генерирует случайное имя пользователя и пароль
  def generate_random_user():
      username = ''.join(random.choices(string.ascii_letters + string.digits, k=8))
      password = ''.join(random.choices(string.ascii_letters + string.digits, k=12))
      return username, password

  # Создает файл с заданным количеством пользователей
  def create_users_file(filename, count=100):
      with open(filename, 'w') as file:
          for _ in range(count):
              user = generate_random_user()
              file.write(f"{user[0]},{user[1]}\n")
  ```

- **Основной файл `main.py`**

  ```python
  from user_generator import create_users_file

  if __name__ == "__main__":
      create_users_file('users.txt', 100)
  ```

- **Объяснение кода**:

  - **Импортируем библиотеки**: `random` для генерации случайных данных и `string` для доступа к символам. Параметр `k` указывает на количество элементов, которые будут выбраны из заданного набора символов.
  - **Функция `generate_random_user`**: генерирует случайное имя пользователя и пароль, используя символы и цифры.
  - **Функция `create_users_file`**: создает файл и записывает в него 100 пользователей, вызывая `generate_random_user`.

- **Алгоритм работы модуля**:
  - Импортировать необходимые библиотеки.
  - Определить функцию для генерации случайных пользователей.
  - Определить функцию для создания файла и записи пользователей.
  - Запустить функцию создания файла.

#### **Пример 2: Создание уникального пользователя**

- **Модуль `unique_user_creator.py`**

  ```python
  # Проверяет, уникален ли логин в файле
  def is_unique(username, filename):
      with open(filename, 'r') as file:
          for line in file:
              if line.split(',')[0] == username:
                  return False
      return True

  # Создает нового пользователя с уникальным логином
  def create_user(filename):
      username = input("Введите логин: ")
      password = input("Введите пароль: ")

      if is_unique(username, filename):
          with open(filename, 'a') as file:
              file.write(f"{username},{password}\n")
          print("Пользователь успешно создан.")
      else:
          print("Логин уже существует. Попробуйте другой.")
  ```

- **Основной файл `main.py`**

  ```python
  from unique_user_creator import create_user

  if __name__ == "__main__":
      create_user('users.txt')
  ```

- **Объяснение кода**

  - **Функция `is_unique`**: проверяет, существует ли логин в файле.
  - **Функция `create_user`**: запрашивает у пользователя логин и пароль, проверяет уникальность и записывает в файл.

- **Алгоритм работы модуля**
  - Определить функцию для проверки уникальности логина.
  - Определить функцию для создания нового пользователя.
  - Запрашивать данные у пользователя и проверять их.
  - Записывать данные в файл, если логин уникален.

#### **Пример 3: Объединение двух предыдущих примеров**

- **Модуль `main.py`**

  ```python
  import sys
  from user_generator import create_users_file
  from unique_user_creator import create_user

  def main():
      if len(sys.argv) != 2:
          print("Использование: python main.py [rand|new]")
          return

      option = sys.argv[1]
      if option == 'rand':
          create_users_file('users.txt', 100)
          print("Создано 100 пользователей с рандомными данными.")
      elif option == 'new':
          create_user('users.txt')
      else:
          print("Неверный аргумент. Используйте 'rand' или 'new'.")

  if __name__ == "__main__":
      main()
  ```

- **Объяснение кода**

  - **Импортируем модули**: для генерации пользователей и создания уникальных пользователей.
  - **Функция `main`**: проверяет аргументы командной строки и вызывает соответствующие функции.

- **Алгоритм работы модуля**

  - Проверить количество аргументов командной строки.
  - В зависимости от аргумента (`rand` или `new`), вызвать соответствующую функцию.
  - Обработать неверные аргументы.
  - Запуск программы

- **Для создания 100 рандомных пользователей**:
  ```bash
  python main.py rand
  ```
- **Для создания нового уникального пользователя**:
  ```bash
  python main.py new
  ```

### Вопросы:
1. Что такое глобальная переменная в Python?
2. Что такое локальная переменная в Python?
3. Какое ключевое слово используется для изменения глобальной переменной внутри функции?
4. Что такое пространство имен (namespace) в Python?
5. Какая область видимости считается локальной?
6. Что произойдет, если в функции объявить переменную с тем же именем, что и глобальная переменная?
7. Каким образом можно импортировать функции из другого модуля? Приведите устно примеры синтаксиса.
8. Что делает конструкция `if __name__ == "__main__":`?
9. Что произойдет, если в функции использовать ключевое слово nonlocal?
10. Для чего используется оператор `from` ... `import` ... `as` ...?
11. Можно ли использовать глобальные и локальные переменные с одинаковыми именами в одной программе? Если да, то как Python решает, какую переменную использовать?
12. Какая разница между импортом `import module` и `from module import something`? Когда использовать каждый из них?

### Задачи:
1. Есть глобальная переменная `count`, равная `0`. Напишите функцию, которая увеличивает значение этой переменной на `1` при каждом вызове этой функции.

2. Создайте функцию, которая принимает строку, преобразует ее в список символов и возвращает количество уникальных символов. Используйте локальную переменную для хранения результата.
   - **Пример входных данных**:
     ```python
     "hello" # Уникальные символы: h, e, o
     ```

3. Создайте глобальный словарь `user_data`. Напишите функцию, которая добавляет в этот словарь новую пару ключ-значение, где ключ – имя пользователя, а значение – его возраст. Имя пользователя и возраст пользователь вводит через терминал. Вызовите функцию для проверки.

4. Напишите функцию `outer`, которая внутри себя содержит функцию `inner`. Внутри функции `outer` должна быть переменная-счетчик. Функция `inner` должна увеличивать переменную-счетчик. Вызовите функцию для проверки.

5. На вход программе подается строка. Создайте функцию, которая принимает строку и возвращает список случайно перемешанных символов из этой строки. Вызовите функцию для проверки.

6. На вход программе подаются слова, записанные в одну строчку через пробел. Создайте функцию, которая принимает список строк и создает файл `output.txt`. В этот файл записываются строки из списка, каждая с новой строки.

7. На вход программе подается строка - имя пользователя. Создайте модуль `user_utils.py`, содержащий функцию `validate_username`(username), которая проверяет, состоит ли имя пользователя только из букв и цифр. Импортируйте модуль и используйте его в основном файле.

8. Создайте модуль `calculator.py`, который выполняет операции сложения, вычитания, умножения и деления. Если модуль запускается напрямую, он должен принять два числа от пользователя и вывести результат их сложения. Если функции из модуля запускаются из файла `main.py` (основного файла) они должны исполнять свои действия.

9. Создайте функцию, которая принимает не ограниченное количество словарей, объединяет их в один и записывает результат в файл `merged.json`. Вызовите функцию для проверки.

10. \* Создайте модуль `user_generator.py`, который генерирует 100 пользователей с уникальными логинами и паролями и записывает их в файл `users.txt`.

11. \* Создайте модуль `user_creator.py`. В нем создайте функцию, которая принимает строку в формате `login:password` и добавляет пользователя в файл `users.txt`, если такого логина еще нет.

12. \* Создайте модуль `user_getter`. В нем создайте функцию, которая выводит всех пользователей из файла `users.txt`, в котором уже находятся минимум `100` пользователей.

13. \* Создайте модуль `user_manager.py` для управления пользователями. Модули из прошлых задач должны быть уже реализованны (`user_generator.py`, `user_creator.py`, `user_getter`). При запуске модуля `user_manager.py` с аргументами программа должна:
    - с аргументом `--generate` генерировать 100 случайных пользователей.
    - с вргументом `--add для` добавлять нового пользователя вручную.
    - с аргументом `--list` выводить всех пользователей.